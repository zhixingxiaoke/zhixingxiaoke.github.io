<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="RFC761 TCP 协议中文翻译 # 这是 RFC 上较早关于 TCP 协议标准的文档，站在现在的角度来看，它可能不是很准确或者不是很完整，但是非常有学习价值。
原文： DoD standard Transmission Control Protocol
封面 # RFC(Request for Comments): 761
IEN(Internet Experiment Note): 129
DOD STANDARD
美国国防部标准
TRANSMISSION CONTROL PROTOCOL TCP 协议 January 1980 1980 年 1 月
prepared for
Defense Advanced Research Projects Agency
国防高级研究计划局
Information Processing Techniques Office
信息处理技术办公室
1400 Wilson Boulevard
威尔逊大道 1400 号 Arlington, Virginia 22209
弗吉尼亚州阿灵顿 22209
by
Information Sciences Institute
信息科学研究所
University of Southern California"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="RFC761 DoD standard TCP 协议"><meta property="og:description" content="RFC761 TCP 协议中文翻译 # 这是 RFC 上较早关于 TCP 协议标准的文档，站在现在的角度来看，它可能不是很准确或者不是很完整，但是非常有学习价值。
原文： DoD standard Transmission Control Protocol
封面 # RFC(Request for Comments): 761
IEN(Internet Experiment Note): 129
DOD STANDARD
美国国防部标准
TRANSMISSION CONTROL PROTOCOL TCP 协议 January 1980 1980 年 1 月
prepared for
Defense Advanced Research Projects Agency
国防高级研究计划局
Information Processing Techniques Office
信息处理技术办公室
1400 Wilson Boulevard
威尔逊大道 1400 号 Arlington, Virginia 22209
弗吉尼亚州阿灵顿 22209
by
Information Sciences Institute
信息科学研究所
University of Southern California"><meta property="og:type" content="article"><meta property="og:url" content="http://x.zhixing.io/docs/translations/rfc761/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-03-11T22:14:32+08:00"><title>RFC761 DoD standard TCP 协议 | 知行小课</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.a82d7e77ceb134d151c4d7e381eeb30623fbd5a524d58c584d8716ecec0205bd.css integrity="sha256-qC1+d86xNNFRxNfjge6zBiP71aUk1YxYTYcW7OwCBb0=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.78166b9d46e23e0ea915cb6887a30b633e7bc4fad10c8b6b9f6fa532271c19ba.js integrity="sha256-eBZrnUbiPg6pFctoh6MLYz57xPrRDItrn2+lMiccGbo=" crossorigin=anonymous></script>
<script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/logo-128.png alt=Logo><span>知行小课</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><span>翻译</span><ul><li><a href=/docs/translations/rfc761/ class=active>RFC761 DoD standard TCP 协议</a></li><li><a href=/docs/translations/rfc793/>RFC793 TCP 协议</a></li></ul></li></ul><ul><li><a href=https://team.zhixing.co target=_blank rel=noopener>关于</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>RFC761 DoD standard TCP 协议</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#封面>封面</a></li><li><a href=#目录>目录</a></li><li><a href=#前言>前言</a></li><li><a href=#介绍>介绍</a><ul><li><a href=#动机>动机</a></li><li><a href=#范围>范围</a></li><li><a href=#关于本文>关于本文</a></li><li><a href=#接口>接口</a></li><li><a href=#操作>操作</a></li></ul></li><li><a href=#基本原理>基本原理</a><ul><li><a href=#互联网系统的要素>互联网系统的要素</a></li><li><a href=#运作模式>运作模式</a></li><li><a href=#主机环境>主机环境</a></li><li><a href=#接口-1>接口</a></li><li><a href=#与其他协议的关系>与其他协议的关系</a></li><li><a href=#可靠的通信>可靠的通信</a></li><li><a href=#连接的建立和清除>连接的建立和清除</a></li><li><a href=#数据通信>数据通信</a></li><li><a href=#优先级和安全性>优先级和安全性</a></li><li><a href=#稳健性原则>稳健性原则</a></li></ul></li><li><a href=#功能规范>功能规范</a><ul><li><a href=#头部格式>头部格式</a></li><li><a href=#术语表>术语表</a></li><li><a href=#序列号>序列号</a></li><li><a href=#建立连接>建立连接</a></li><li><a href=#关闭连接>关闭连接</a></li><li><a href=#优先级和安全性-1>优先级和安全性</a></li><li><a href=#数据通信-1>数据通信</a></li><li><a href=#接口-2>接口</a></li><li><a href=#事件处理>事件处理</a></li></ul></li><li><a href=#词汇表>词汇表</a></li><li><a href=#参考文献>参考文献</a></li></ul></nav></aside></header><article class=markdown><h1 id=rfc761-tcp-协议中文翻译>RFC761 TCP 协议中文翻译
<a class=anchor href=#rfc761-tcp-%e5%8d%8f%e8%ae%ae%e4%b8%ad%e6%96%87%e7%bf%bb%e8%af%91>#</a></h1><p>这是 RFC 上较早关于 TCP 协议标准的文档，站在现在的角度来看，它可能不是很准确或者不是很完整，但是非常有学习价值。</p><p>原文：
<a href=https://datatracker.ietf.org/doc/rfc761/>DoD standard Transmission Control Protocol</a></p><h2 id=封面>封面
<a class=anchor href=#%e5%b0%81%e9%9d%a2>#</a></h2><p>RFC(Request for Comments): 761<br>IEN(Internet Experiment Note): 129</p><div class=text-center><p>DOD STANDARD<br>美国国防部标准</p><p>TRANSMISSION CONTROL PROTOCOL
TCP 协议
January 1980
1980 年 1 月</p><p>prepared for</p><p>Defense Advanced Research Projects Agency<br>国防高级研究计划局<br>Information Processing Techniques Office<br>信息处理技术办公室<br>1400 Wilson Boulevard<br>威尔逊大道 1400 号
Arlington, Virginia 22209<br>弗吉尼亚州阿灵顿 22209</p><p>by</p><p>Information Sciences Institute<br>信息科学研究所<br>University of Southern California<br>南加州大学<br>4676 Admiralty Way<br>4676 金钟路<br>Marina del Rey, California 90291<br>加利福尼亚州玛丽安德尔湾 90291</p></div><h2 id=目录>目录
<a class=anchor href=#%e7%9b%ae%e5%bd%95>#</a></h2><div class=text-center>TABLE OF CONTENTS</div><p>PREFACE 前言</p><p>1.INTRODUCTION 介绍<br> 1.1 Motivation 动机<br> 1.2 Scope 范围<br> 1.3 About This Document 关于本文<br> 1.4 Interfaces 接口<br> 1.5 Operation 操作</p><p>2.PHILOSOPHY 基本原理<br> 2.1 Elements of the Internetwork System 互联网系统的要素<br> 2.2 Model of Operation 运作模式<br> 2.3 The Host Environment 主机环境<br> 2.4 Interfaces 接口<br> 2.5 Relation to Other Protocols 与其他协议的关系<br> 2.6 Reliable Communication 可靠的通信<br> 2.7 Connection Establishment and Clearing 连接的建立和清除<br> 2.8 Data Communication 数据通信<br> 2.9 Precedence and Security 优先级和安全性<br> 2.10 Robustness Principle 稳健性原则</p><p>3.FUNCTIONAL SPECIFICATION 功能规范<br> 3.1 Header Format 头部格式<br> 3.2 Terminology 术语表<br> 3.3 Sequence Numbers 序列号<br> 3.4 Establishing a connection 建立连接<br> 3.5 Closing a Connection 关闭连接<br> 3.6 Precedence and Security 优先级和安全性<br> 3.7 Data Communication 数据通信<br> 3.8 Interfaces 接口<br> 3.9 Event Processing 事件处理</p><p>GLOSSARY 词汇表</p><p>REFERENCES 参考文献</p><h2 id=前言>前言
<a class=anchor href=#%e5%89%8d%e8%a8%80>#</a></h2><p><strong>PREFACE</strong></p><p>This document describes the DoD Standard Transmission Control Protocol
(TCP).<br>本文描述了美国国防部标准传输控制协议（TCP 协议）。</p><p>There have been eight earlier editions of the ARPA TCP specification on which this standard is based, and the present text draws heavily from them.<br>ARPA TCP 规范已经有 8 个早期版本，本文中的 TCP 标准是基于它们，并且很多内容都是借鉴它们的。</p><p>There have been many contributors to this work both in terms of concepts and in terms of text.<br>在概念和编纂方面，都有很多人对这项工作做出贡献。</p><p>This edition incorporates the addition of security, compartmentation, and precedence concepts into the TCP specification.<br>此版本在 TCP 规范中加入了安全、区段和优先级概念。</p><div class=text-right><p>Jon Postel</p><p>Editor</p></div><h2 id=介绍>介绍
<a class=anchor href=#%e4%bb%8b%e7%bb%8d>#</a></h2><p><strong>1.INTRODUCTION</strong></p><p>The Transmission Control Protocol (TCP) is intended for use as a highly reliable host-to-host protocol between hosts in packet-switched computer communication networks, and especially in interconnected systems of such networks.<br>传输控制协议（TCP）旨在作为分组交换计算机通信网络中主机之间的高度可靠的主机到主机协议使用，特别是在这种网络的互连系统中。</p><p>This document describes the functions to be performed by the Transmission Control Protocol, the program that implements it, and its interface to programs or users that require its services.<br>本文描述了传输控制协议（TCP）所要执行的功能、实现它的程序以及它与需要其服务的程序或用户的接口。</p><h3 id=动机>动机
<a class=anchor href=#%e5%8a%a8%e6%9c%ba>#</a></h3><p><strong>1.1. Motivation</strong></p><p>Computer communication systems are playing an increasingly important role in military, government, and civilian environments.<br>计算机通信系统在军事、政府和民用环境中发挥越来越重要的作用。</p><p>This document primarily focuses its attention on military computer communication requirements, especially robustness in the presence of communication unreliability and availability in the presence of congestion, but many of these problems are found in the civilian and government sector as well.<br>本文着重关注军用计算机通信系统的要求，尤其是通信不可靠时的健壮性和通讯拥堵时的可用性，但是这些问题大多也存在于民用和政府部门的计算机通讯系统中。</p><p>As strategic and tactical computer communication networks are developed and deployed, it is essential to provide means of interconnecting them and to provide standard interprocess communication protocols which can support a broad range of applications.<br>随着战略和战术计算机通信网络的开发和部署，使它们互联并提供标准的进程间通信协议变得很有必要，这样才能够让它们能够得到广泛的应用。</p><p>In anticipation of the need for such standards, the Deputy Undersecretary of Defense for Research and Engineering has declared the Transmission Control Protocol (TCP) described herein to be a basis for DoD-wide inter-process communication protocol standardization.<br>鉴于对此类标准的需求，负责研究和工程的国防部副部长宣布本文所述的传输控制协议（TCP）为美国国防部范围内进程间通信协议标准化的基础。</p><p>TCP is a connection-oriented, end-to-end reliable protocol designed to fit into a layered hierarchy of protocols which support multi-network applications.<br>TCP 是一个面向连接的、端到端的可靠协议，旨在适应支持多网络应用的协议分层结构。</p><p>The TCP provides for reliable inter-process communication between pairs of processes in host computers attached to distinct but interconnected computer communication networks.<br>TCP 协议为处于同一网络中，但是处于不同计算机中的两个进程提供可靠的进程间通信。</p><p>Very few assumptions are made as to the reliability of the communication protocols below the TCP layer.<br>TCP 层以下的通信协议被认为是不可靠的。</p><p>TCP assumes it can obtain a simple, potentially unreliable datagram service from the lower level protocols.<br>TCP 假设它可以从更低的协议中获取简单但可能是不可靠的数据包服务。</p><p>In principle, the TCP should be able to operate above a wide spectrum of communication systems ranging from hard-wired connections to packet-switched or circuit-switched networks.<br>原则上，TCP 协议应该可以在从硬线连接到分组交换或电路交换网络的广泛通信系统中运行。</p><p>TCP is based on concepts first described by Cerf and Kahn in [1].<br>TCP 协议基于 Cerf 和 Kahn 最先提出的概念。</p><p>The TCP fits into a layered protocol architecture just above a basic Internet Protocol [2] which provides a way for the TCP to send and receive variable-length segments of information enclosed in internet datagram &ldquo;envelopes&rdquo;.<br>TCP 协议是适用于一个分层协议结构，它在 IP 协议之上，IP 协议为 TCP 层提供了一种发送和接收可变长度的信息段的网络数据包的方式。</p><p>The internet datagram provides a means for addressing source and destination TCPs in different networks.<br>网络数据包提供了一种在不同网络中寻找 TCP 源地址和目的地址的方法。</p><p>The internet protocol also deals with any fragmentation or reassembly of the TCP segments required to achieve transport and delivery through multiple networks and interconnecting gateways.<br>IP 协议也处理通过多个网络和网关实现传输和交付所需的 TCP 段的任何分段或重组。</p><p>The internet protocol also carries information on the precedence, security classification and compartmentation of the TCP segments, so this information can be communicated end-to-end across multiple networks.<br>IP 协议还携带关于 TCP 段的优先级、安全分类和区段的信息，因此这些信息可以在多个网络中被端到端的进行传递。</p><div class=text-center><p>Protocol Layering<br>协议分层</p><pre tabindex=0><code>+---------------------+
|     higher-level    |
+---------------------+
|        TCP          |
+---------------------+
|  internet protocol  |
+---------------------+
|communication network|
+---------------------+
</code></pre><p>Figure 1</p></div><p>Much of this document is written in the context of TCP implementations which are co-resident with higher level protocols in the host computer.<br>本文的大部分内容是在 TCP 实现的背景下编写的，这些实现与主机中更高级别的协议共存。</p><p>As a practical matter, many computer systems will be connected to networks via front-end computers which house the TCP and internet protocol layers, as well as network specific software.<br>实际上，许多计算机系统将会通过包含 TCP 和 IP 协议层以及网络软件的前置机连接到网络。</p><p>The TCP specification describes an interface to the higher level protocols which appears to be implementable even for the front-end case, as long as a suitable host-to-front end protocol is implemented.<br>TCP 规范描述了一个到更高层协议的接口，只要实现了合适的主机到前端的协议，即使对于前端情况，该接口似乎也是可实现的。</p><h3 id=范围>范围
<a class=anchor href=#%e8%8c%83%e5%9b%b4>#</a></h3><p><strong>1.2. Scope</strong></p><p>The TCP is intended to provide a reliable process-to-process communication service in a multinetwork environment.<br>TCP 旨在在多网络环境中提供可靠的进程到进程通信服务。</p><p>The TCP is intended to be a host-to-host protocol in common use in multiple networks.<br>TCP 旨在成为多网络环境中常用的主机到主机协议。</p><h3 id=关于本文>关于本文
<a class=anchor href=#%e5%85%b3%e4%ba%8e%e6%9c%ac%e6%96%87>#</a></h3><p><strong>1.3. About this Document</strong></p><p>This document represents a specification of the behavior required of any TCP implementation, both in its interactions with higher level protocols and in its interactions with other TCPs.<br>本文描述了所有 TCP 实现所需的行为规范，无论是与其它更高级的协议交互还是与其它 TCP 的交互。</p><p>The rest of this section offers a very brief view of the protocol interfaces and operation.<br>本节的其余部分非常简要地介绍了协议接口和操作。</p><p>Section 2 summarizes the philosophical basis for the TCP design.<br>第 2 节概述了 TCP 设计的哲学基础。</p><p>Section 3 offers both a detailed description of the actions required of TCP when various events occur (arrival of new segments, user calls, errors, etc.) and the details of the formats of TCP segments.<br>第 3 节详细描述了当各种事件发生时（新段的到来、用户呼叫、错误等）TCP 所需的行动，以及 TCP 段格式的细节。</p><h3 id=接口>接口
<a class=anchor href=#%e6%8e%a5%e5%8f%a3>#</a></h3><p><strong>1.4. Interfaces</strong></p><p>The TCP interfaces on one side to user or application processes and on the other side to a lower level protocol such as Internet Protocol.<br>TCP 一端连接到用户或应用程序进程，另一端连接到较低级别的协议，比如 IP 协议。</p><p>The interface between an application process and the TCP is illustrated in reasonable detail.<br>相当详细地说明了应用程序进程和 TCP 之间的接口。</p><p>This interface consists of a set of calls much like the calls an operating system provides to an application process for manipulating files.<br>这个接口由一组调用组成，很像操作系统为操作文件的应用进程提供的调用。</p><p>For example, there are calls to open and close connections and to send and receive letters on established connections.<br>例如，有调用打开和关闭连接，以及在已建立的连接上发送和接收数据。</p><p>It is also expected that the TCP can asynchronously communicate with application programs.<br>还期望 TCP 能够与应用程序进行异步通信。</p><p>Although considerable freedom is permitted to TCP implementors to design interfaces which are appropriate to a particular operating system environment, a minimum functionality is required at the TCP/user interface for any valid implementation.<br>尽管允许 TCP 实现者有相当大的自由来设计适合特定操作系统环境的接口，但对于任何有效的实现，TCP/user 接口都需要最少的功能。</p><p>The interface between TCP and lower level protocol is essentially unspecified except that it is assumed there is a mechanism whereby the two levels can asynchronously pass information to each other.<br>除了假设两个级别可以相互异步传递信息的机制之外，基本上没有指定 TCP 和较低级别协议之间的接口。</p><p>Typically, one expects the lower level protocol to specify this interface.<br>通常情况下，是由低级别的协议指定这个接口。</p><p>TCP is designed to work in a very general environment of interconnected networks.<br>TCP 被设计为可以在互连网络的非常普遍的环境中工作。</p><p>The lower level protocol which is assumed throughout this document is the Internet Protocol [2].<br>本文中假定的较低级别协议是 IP 协议。</p><h3 id=操作>操作
<a class=anchor href=#%e6%93%8d%e4%bd%9c>#</a></h3><p><strong>1.5. Operation</strong></p><p>As noted above, the primary purpose of the TCP is to provide reliable, securable logical circuit or connection service between pairs of processes.<br>如上所述，TCP 的主要目的是在进程对之间提供可靠、安全的逻辑线路或连接服务。</p><p>To provide this service on top of a less reliable internet communication system requires facilities in the following areas:<br>要在不太可靠的互联网通信系统之上提供这种服务，需要在以下方面的设施：</p><ul><li>Basic Data Transfer 基础数据传输</li><li>Reliability 可靠性</li><li>Flow Control 流量控制</li><li>Multiplexing 多路复用</li><li>Connections 连接</li><li>Precedence and Security 优先级和安全性</li></ul><p>The basic operation of the TCP in each of these areas is described in the following paragraphs.<br>以下段落描述了 TCP 在每个方面的基本操作。</p><p><strong>Basic Data Transfer:</strong><br><strong>基础数据传输</strong></p><p>The TCP is able to transfer a continuous stream of octets in each direction between its users by packaging some number of octets into segments for transmission through the internet system.<br>TCP 能够在其用户之间的每个方向传输连续的字节流，将一些字节数据打包成段，通过互联网传输。</p><p>In this stream mode, the TCPs decide when to block and forward data at their own convenience.<br>在这种流模式下，TCP 根据自己的情况来决定阻止和转发数据。</p><p>For users who desire a record-oriented service, the TCP also permits the user to submit records, called letters, for transmission.<br>对于需要面向记录的服务的用户，TCP 还允许用户提交记录以供传输。</p><p>When the sending user indicates a record boundary (end-of-letter), this causes the TCPs to promptly forward and deliver data up to that point to the receiver.<br>当发送记录边界时，这会使得 TCP 立即转发数据，并将数据传递到接收者。</p><p><strong>Reliability:</strong><br><strong>可靠性</strong></p><p>The TCP must recover from data that is damaged, lost, duplicated, or delivered out of order by the internet communication system.<br>TCP 必须从因特网通信系统损坏、丢失、复制或乱序传送的数据中恢复。</p><p>This is achieved by assigning a sequence number to each octet transmitted, and requiring a positive acknowledgment (ACK) from the
receiving TCP.<br>这是通过给传输的每个字节分配一个序列号，并要求接收的 TCP 回复一个确认（ACK）来实现的。</p><p>If the ACK is not received within a timeout interval, the data is retransmitted.<br>如果在规定的时间隔内没有收到 ACK，则重传数据。</p><p>At the receiver, the sequence numbers are used to correctly order segments that may be received out of order and to eliminate duplicates.<br>在接收方，序列号用来按顺序排列可能接收到的乱序的片段，并消除重复的片段。</p><p>Damage is handled by adding a checksum to each segment transmitted, checking it at the receiver, and discarding damaged segments.<br>通过在传输的每个片段上添加一个校验和，在接收方进行检查，并丢弃损坏的片段。</p><p>As long as the TCPs continue to function properly and the internet system does not become completely partitioned, no transmission errors will affect the users.<br>只要 TCP 各端继续正常运行，网络系统也没有断开，传输错误就不会影响到用户。</p><p>TCP recovers from internet communication system errors.<br>TCP 从互联网通信错误中恢复。</p><p><strong>Flow Control:</strong><br><strong>流量控制</strong></p><p>TCP provides a means for the receiver to govern the amount of data sent by the sender.<br>TCP 为接收方提供了一种方法来管理发送方发送的数据量。</p><p>This is achieved by returning a &ldquo;window&rdquo; with every ACK indicating a range of acceptable sequence numbers beyond the last segment successfully received.<br>这是通过在每个 ACK 中返回一个 &ldquo;窗口&rdquo; 来实现的，窗口表示在成功接收的最后一个片段之外的可接受的序列号范围。</p><p>For stream mode, the window indicates an allowed number of octets that the sender may transmit before receiving further permission.<br>对于流模式，窗口表示发送者在收到后续指示之前可以传输的字节数。</p><p>For record mode, the window indicates an allowed amount of buffer space the sender may consume, this may be more than the number of data octets transmitted if there is a mismatch between letter size and buffer size.<br>对于记录模式，窗口表示发送方可能消耗的缓冲空间的数量，如果数据包大小和缓冲区大小不匹配，可能超过传输的数据字节数。</p><p><strong>Multiplexing:</strong><br><strong>多路复用</strong></p><p>To allow for many processes within a single Host to use TCP communication facilities simultaneously, the TCP provides a set of addresses or ports within each host.<br>为了允许单个主机内的多个进程同时使用 TCP 进行通信，TCP 在每个主机内提供了一组地址或端口。</p><p>Concatenated with the network and host addresses from the internet communication layer, this forms a socket.<br>从互联网通信层连接网络和主机地址，形成一个套接字。</p><p>A pair of sockets uniquely identifies each connection.<br>一对套接字唯一标识每个连接。</p><p>That is, a socket may be simultaneously used in multiple connections.<br>也就是说，一个套接字可以同时在多个连接中使用。</p><p>The binding of ports to processes is handled independently by each Host.<br>每个主机单独处理端口与进程的绑定。</p><p>However, it proves useful to attach frequently used processes (e.g., a &ldquo;logger&rdquo; or timesharing service) to fixed sockets which are made known to the public.<br>然而，事实证明，将常用的进程（例如，&ldquo;logger"或 timesharing 服务）附加到固定的套接字上会很有用。</p><p>These services can then be accessed through the known addresses. Establishing and learning the port addresses of other processes may involve more dynamic mechanisms.<br>通过已知地址就可以访问这些服务，建立和学习其他进程的端口地址可能涉及更多的动态机制。</p><p>Connections:<br>连接</p><p>The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream.<br>上述的可靠性和流量控制机制要求 TCP 初始化和维护每个数据流的某些状态信息。</p><p>The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.<br>这些信息（包括套接字、序列号和窗口大小）的组合称为连接。</p><p>Each connection is uniquely specified by a pair of sockets identifying its two sides.<br>每个连接都由标识其两端的一对套接字唯一指定。</p><p>When two processes wish to communicate, their TCP&rsquo;s must first establish a connection (initialize the status information on each side).<br>当两个进程想要进行通信时，它们必须先建立 TCP 连接（初始化每一端的状态信息）。</p><p>When their communication is complete, the connection is terminated or closed to free the resources for other uses.<br>当他们的通信完成后，连接被终止或关闭，以释放资源用于其他用途。</p><p>Since connections must be established between unreliable hosts and over the unreliable internet communication system, a handshake mechanism with clock-based sequence numbers is used to avoid erroneous initialization of connections.<br>由于必须在不可靠的主机之间和通过不可靠的互联网通信系统建立连接，因此使用了基于时钟序列号的握手机制，以避免连接的错误初始化。</p><p><strong>Precedence and Security:</strong><br><strong>优先级和安全性</strong></p><p>The users of TCP may indicate the security and precedence of their communication.<br>TCP 的用户可以指定其通信的安全性和优先级。</p><p>Provision is made for default values to be used when these features are not needed.<br>规定在不需要这些功能时，会使用默认值。</p><h2 id=基本原理>基本原理
<a class=anchor href=#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86>#</a></h2><p><strong>2.PHILOSOPHY</strong></p><h3 id=互联网系统的要素>互联网系统的要素
<a class=anchor href=#%e4%ba%92%e8%81%94%e7%bd%91%e7%b3%bb%e7%bb%9f%e7%9a%84%e8%a6%81%e7%b4%a0>#</a></h3><p><strong>2.1. Elements of the Internetwork System</strong></p><p>The internetwork environment consists of hosts connected to networks which are in turn interconnected via gateways.<br>互联网络环境由连接到网络的主机组成，这些网络又通过网关互连。</p><p>It is assumed here that the networks may be either local networks (e.g., the ETHERNET) or large networks (e.g., the ARPANET), but in any case are based on packet switching technology.<br>这里假设网络可以是本地网络（如 ETHERNET）或大型网络（如 ARPANET），但在任何情况下都是基于分组交换技术。</p><p>The active agents that produce and consume messages are processes.<br>进程是产生和消费消息的活跃元素。</p><p>Various levels of protocols in the networks, the gateways, and the hosts support an interprocess communication system that provides two-way data flow on logical connections between process ports.<br>网络、网关和主机中的各种级别的协议支持进程间通信系统，该系统在进程端口之间的逻辑连接上提供双向数据流。</p><p>We specifically assume that data is transmitted from host to host through means of a set of networks.<br>我们特别假设数据通过一组网络从一个主机传输到另一个主机。</p><p>When we say network, we have in mind a packet switched network (PSN).<br>当我们说网络时，我们想到的是分组交换网络(PSN)。</p><p>This assumption is probably unnecessary, since a circuit switched network or a hybrid combination of the two could also be used; but for concreteness, we explicitly assume that the hosts are connected to one or more packet switches of a PSN.<br>这一假设可能是不必要的，因为也可以使用电路交换网络或两者的混合组合。但为了具体起见，我们明确假设主机连接到 PSN 的一个或多个分组交换机。</p><p>The term packet is used generically here to mean the data of one transaction between a host and a packet switch.<br>术语 &ldquo;数据包&rdquo; 在这里泛指主机和数据包交换机之间的一次事务处理数据。</p><p>The format of data blocks exchanged between the packet switches in a network will generally not be of concern to us.<br>我们通常不会关心网络中分组交换机之间交换的数据块的格式。</p><p>Hosts are computers attached to a network, and from the communication network&rsquo;s point of view, are the sources and destinations of packets.<br>主机是连接到网络的计算机，从通信网络的角度来看，主机是数据包的来源和目的地。</p><p>Processes are viewed as the active elements in host computers (in accordance with the fairly common definition of a process as a program in execution).<br>进程被看作是主机中的活跃元素（根据相当普遍的定义，进程是一个正在执行的程序）。</p><p>Even terminals and files or other I/O devices are viewed as communicating with each other through the use of processes.<br>甚至终端和文件或其他 I/O 设备也被看作是通过使用进程来相互通信的。</p><p>Thus, all communication is viewed as inter-process communication.<br>因此，所有的通信都被看作是进程间的通信。</p><p>Since a process may need to distinguish among several communication streams between itself and another process (or processes), we imagine that each process may have a number of ports through which it communicates with the ports of other processes.<br>因为一个进程可能需要区分它和另一个进程(或多个进程)之间的几个通信流，所以我们假设每个进程可能有许多端口，它通过这些端口与其他进程的端口进行通信。</p><h3 id=运作模式>运作模式
<a class=anchor href=#%e8%bf%90%e4%bd%9c%e6%a8%a1%e5%bc%8f>#</a></h3><p><strong>2.2. Model of Operation</strong></p><p>Processes transmit data by calling on the TCP and passing buffers of data as arguments.<br>进程通过调用 TCP 并将数据缓冲区作为参数来传输数据。</p><p>The TCP packages the data from these buffers into segments and calls on the internet module to transmit each segment to the destination TCP.<br>TCP 将这些缓冲区中的数据打包成 TCP 段，并调用网络模块将每个 TCP 段传输到目的主机的 TCP。</p><p>The receiving TCP places the data from a segment into the receiving user&rsquo;s buffer and notifies the receiving user.<br>接收 TCP 将 TCP 段中的数据放入接收用户的缓冲区，并通知接收用户。</p><p>The TCPs include control information in the segments which they use to ensure reliable ordered data transmission.<br>TCP 把控制信息放在 TCP 段中，它们用于确保可靠有序的数据传输。</p><p>The model of internet communication is that there is an internet protocol module associated with each TCP which provides an interface to the local network.<br>互联网通信的模型是有一个互联网协议模块与每个 TCP 相关联，它提供到本地网络的接口。</p><p>This internet module packages TCP segments inside internet datagrams and routes these datagrams to a destination internet module or intermediate gateway.<br>这个互联网模块将 TCP 段封装在网络数据报中，并将这些数据报路由到目标互联网模块或中间网关。</p><p>To transmit the datagram through the local network, it is embedded in a local network packet.<br>为了通过本地网络传输数据报，它被嵌入到本地网络数据包中。</p><p>The packet switches may perform further packaging, fragmentation, or other operations to achieve the delivery of the local packet to the destination internet module.<br>分组交换机可以执行进一步的打包、分段或其他操作，以实现将本地数据包发送到目的地互联网模块。</p><p>At a gateway between networks, the internet datagram is &ldquo;unwrapped&rdquo; from its local packet and examined to determine through which network the internet datagram should travel next.<br>在网关时，网络数据报从其本地数据包中 &ldquo;解包&rdquo; 并进行检查并决定该网络数据报接下来应通过哪个网络传输。</p><p>The internet datagram is then &ldquo;wrapped&rdquo; in a local packet suitable to the next network and routed to the next gateway, or to the final destination.<br>然后，网络数据报在适合于下一个网络的本地数据包中被 &ldquo;包装&rdquo; ，并被路由到下一个网关或最终目的地。</p><p>A gateway is permitted to break up an internet datagram into smaller internet datagram fragments if this is necessary for transmission through the next network.<br>如果有必要的话，允许网关将网络数据报分解成更小的网络数据报片段，再传输到下一个网络。</p><p>To do this, the gateway produces a set of internet datagrams; each carrying a fragment.<br>为此，网关生成一组网络数据报；每个数据包携带一个片段。</p><p>Fragments may be broken into smaller ones at intermediate gateways.<br>数据包片段可以在中间网关处分解成更小的片段。</p><p>The internet datagram fragment format is designed so that the destination internet module can reassemble fragments into internet datagrams.<br>网络数据报片段格式的设计使得目的地的互联网模块可以将片段重组为网络数据报。</p><p>A destination internet module unwraps the segment from the datagram (after reassembling the datagram, if necessary) and passes it to the destination TCP.<br>目的地互联网模块从数据报中解开 TCP 段(如果需要，在重组数据报之后)，并将其传递给 TCP。</p><p>This simple model of the operation glosses over many details.<br>这个简单的运作模式掩盖了许多细节。</p><p>One important feature is the type of service.<br>一个重要的特征是服务的类型。</p><p>This provides information to the gateway (or internet module) to guide it in selecting the service parameters to be used in traversing the next network.<br>这为网关（或互联网模块）提供了信息，指导它选择遍历下一个网络时使用的服务参数。</p><p>Included in the type of service information is the precedence of the datagram.<br>服务类型信息中包括数据报的优先级。</p><p>Datagrams may also carry security information to permit host and gateways that operate in multilevel secure environments to properly segregate datagrams for security considerations.<br>数据报还可以携带安全信息，使得在多级安全环境中操作的主机和网关出于安全考虑可以适当地分离数据报。</p><h3 id=主机环境>主机环境
<a class=anchor href=#%e4%b8%bb%e6%9c%ba%e7%8e%af%e5%a2%83>#</a></h3><p><strong>2.3. The Host Environment</strong></p><p>The TCP is assumed to be a module in a time sharing operating system.<br>假定 TCP 是分时操作系统中的一个模块。</p><p>The users access the TCP much like they would access the file system.<br>用户访问 TCP 就像他们访问文件系统一样。</p><p>The TCP may call on other operating system functions, for example, to manage data structures.<br>TCP 可以调用其他操作系统的功能，例如，管理数据结构。</p><p>The actual interface to the network is assumed to be controlled by a device driver module.<br>假设到网络的实际接口由设备驱动模块控制。</p><p>The TCP does not call on the network device driver directly, but rather calls on the internet datagram protocol module which may in turn call on the device driver.<br>TCP 不直接调用网络设备驱动程序，而是调用网络数据报协议模块，而后者又可能调用设备驱动程序。</p><p>Though it is assumed here that processes are supported by the host operating system, the mechanisms of TCP do not preclude implementation of the TCP in a front-end processor.<br>虽然这里假设进程是由主机操作系统支持的，但 TCP 的机制并不排除在前端处理器中实现 TCP。</p><p>However, in such an implementation, a host-to-front-end protocol must provide the functionality to support the type of TCP-user interface described above.<br>然而，在这样的实现中，主机到前端协议必须提供支持上述类型的 TCP-用户接口的功能。</p><h3 id=接口-1>接口
<a class=anchor href=#%e6%8e%a5%e5%8f%a3-1>#</a></h3><p><strong>2.4. Interfaces</strong></p><p>The TCP/user interface provides for calls made by the user on the TCP to OPEN or CLOSE a connection, to SEND or RECEIVE data, or to obtain STATUS about a connection.<br>TCP/用户接口提供了用户控制 TCP 的调用，用来打开或关闭连接、发送或接收数据或获取有关连接的状态。</p><p>These calls are like other calls from user programs on the operating system, for example, the calls to open, read from, and close a file.<br>这些调用类似于操作系统上用户程序的其他调用，例如打开、读取和关闭文件的调用。</p><p>The TCP/internet interface provides calls to send and receive datagrams addressed to TCP modules in hosts anywhere in the internet system.<br>TCP/互联网接口提供了调用，用来发送和接收寻址到互联网系统中任何地方的主机中的 TCP 模块的数据报。</p><p>These calls have parameters for passing the address, type of service, precedence, security, and other control information.<br>这些调用有参数用于传递地址、服务类型、优先级、安全性和其他控制信息。</p><h3 id=与其他协议的关系>与其他协议的关系
<a class=anchor href=#%e4%b8%8e%e5%85%b6%e4%bb%96%e5%8d%8f%e8%ae%ae%e7%9a%84%e5%85%b3%e7%b3%bb>#</a></h3><p><strong>2.5. Relation to Other Protocols</strong></p><p>The following diagram illustrates the place of the TCP in the protocol hierarchy:<br>下图说明了 TCP 在协议层次结构中的位置</p><pre tabindex=0><code>       +------+ +-----+ +-----+       +-----+
       |Telnet| | FTP | |Voice|  ...  |     |  Application Level
       +------+ +-----+ +-----+       +-----+
             |   |         |             |
            +-----+     +-----+       +-----+
            | TCP |     | RTP |  ...  |     |  Host Level
            +-----+     +-----+       +-----+
               |           |             |
            +-------------------------------+
            |      Internet Protocol        |  Gateway Level
            +-------------------------------+
                           |
              +---------------------------+
              |   Local Network Protocol  |    Network Level
              +---------------------------+
                           |
</code></pre><div class=text-center><p>Protocol Relationships<br>协议关系</p><p>Figure 2</p></div><p>It is expected that the TCP will be able to support higher level protocols efficiently.<br>预计 TCP 将能够有效地支持更高级别的协议。</p><p>It should be easy to interface higher level protocols like the ARPANET Telnet [3] or AUTODIN II THP to the TCP.<br>应该很容易将更高层次的协议如 ARPANET Telnet[3]或 AUTODIN II THP 连接到 TCP。</p><h3 id=可靠的通信>可靠的通信
<a class=anchor href=#%e5%8f%af%e9%9d%a0%e7%9a%84%e9%80%9a%e4%bf%a1>#</a></h3><p><strong>2.6. Reliable Communication</strong></p><p>A stream of data sent on a TCP connection is delivered reliably and in order at the destination.<br>通过 TCP 连接上发送的数据流在目的地可靠且有序地传送。</p><p>Transmission is made reliable via the use of sequence numbers and acknowledgments.<br>通过使用序列号和确认机制，使得传输变得可靠。</p><p>Conceptually, each octet of data is assigned a sequence number.<br>从概念上讲，每个字节的数据都分配有一个序列号。</p><p>The sequence number of the first octet of data in a segment is the sequence number transmitted with that segment and is called the segment sequence number.<br>TCP 段中数据的第一个字节的序号是与该 TCP 段一起传输的序列号，称为 segment sequence number。</p><p>Segments also carry an acknowledgment number which is the sequence number of the next expected data octet of transmissions in the reverse direction.<br>TCP 段还携带一个确认号码，这是期望对方传输的下一个字节数据包的序列号。</p><p>When the TCP transmits a segment, it puts a copy on a retransmission queue and starts a timer; when the acknowledgment for that data is received, the segment is deleted from the queue.<br>当 TCP 传输一个 TCP 段时，它会将 TCP 段的一个副本放在重传队列中，并启动一个计时器；当收到该数据的确认时，则将该 TCP 段将从重传队列中删除。</p><p>If the acknowledgment is not received before the timer runs out, the segment is retransmitted.<br>如果在定时器结束之前没有收到确认，则重传该 TCP 段。</p><p>An acknowledgment by TCP does not guarantee that the data has been delivered to the end user, but only that the receiving TCP has taken the responsibility to do so.<br>TCP 的确认并不保证数据已经交付给最终用户，而只是表明接收的 TCP 已经接收了这份数据。</p><p>To govern the flow of data into a TCP, a flow control mechanism is employed.<br>为了管理进入 TCP 的数据流，采用了流量控制机制。</p><p>The the data receiving TCP reports a window to the sending TCP.<br>数据接收 TCP 向发送 TCP 报告一个窗口。</p><p>This window specifies the number of octets, starting with the acknowledgment number that the data receiving TCP is currently prepared to receive.<br>该窗口指定字节的数量，从数据接收的 TCP 目前准备接收的确认号码开始。</p><h3 id=连接的建立和清除>连接的建立和清除
<a class=anchor href=#%e8%bf%9e%e6%8e%a5%e7%9a%84%e5%bb%ba%e7%ab%8b%e5%92%8c%e6%b8%85%e9%99%a4>#</a></h3><p><strong>2.7. Connection Establishment and Clearing</strong></p><p>To identify the separate data streams that a TCP may handle, the TCP provides a port identifier.<br>为了识别 TCP 可以处理的单独数据流，TCP 提供了端口标识符。</p><p>Since port identifiers are selected independently by each operating system, TCP, or user, they might not be unique.<br>由于端口标识符是由每个操作系统、TCP 或用户独立选择的，它们可能不是唯一的。</p><p>To provide for unique addresses at each TCP, we concatenate an internet address identifying the TCP with a port identifier to create a socket which will be unique throughout all networks connected together.<br>为了给每个 TCP 提供唯一的地址，我们将识别 TCP 的网络地址与端口标识符连接起来，以创建一个套接字，该套接字在所有连接在一起的网络中是唯一的。</p><p>A connection is fully specified by the pair of sockets at the ends.<br>一个连接完全由两端的一对套接字指定。</p><p>A local socket may participate in many connections to different foreign sockets.<br>一个本地套接字可以参与许多与不同的外部套接字的连接。</p><p>A connection can be used to carry data in both directions, that is, it is &ldquo;full duplex&rdquo;.<br>一个连接可以用来双向传输数据，也就是说，它是 &ldquo;全双工&rdquo;。</p><p>TCPs are free to associate ports with processes however they choose.<br>TCP 可以自由地将端口与进程联系起来，不管他们如何选择。</p><p>However, several basic concepts seem necessary in any implementation.<br>然而，在任何实现中，有几个基本概念几乎都是必须的。</p><p>There must be well-known sockets which the TCP associates only with the &ldquo;appropriate&rdquo; processes by some means.<br>有一些有名的套接字，TCP 通过某种方式将其与 &ldquo;适当&rdquo; 的进程联系起来。</p><p>We envision that processes may &ldquo;own&rdquo; ports, and that processes can only initiate connections on the ports they own.<br>我们设想进程可以 &ldquo;拥有&rdquo; 端口，而且这些进程只能在它们拥有的端口上发起连接。</p><p>(Means for implementing ownership is a local issue, but we envision a Request Port user command, or a method of uniquely allocating a group of ports to a given process, e.g., by associating the high order bits of a port name with a given process.)<br>实现所有权的方法是一个局部问题，但是我们设想了一个请求端口的用户命令，或者一个将一组端口唯一地分配给一个给定进程的方法，例如，通过将端口名称的高位 bit 与一个给定进程联系起来。</p><p>A connection is specified in the OPEN call by the local port and foreign socket arguments.<br>在 OPEN 调用中，通过本地端口和外部套接字参数指定一个连接。</p><p>In return, the TCP supplies a (short) local connection name by which the user refers to the connection in subsequent calls.<br>TCP 提供了一个（简短的）本地连接名称作为返回，用户在后续的调用中用这个名称来指代连接。</p><p>There are several things that must be remembered about a connection.<br>关于连接，必须记住几件事。</p><p>To store this information we imagine that there is a data structure called a Transmission Control Block (TCB).<br>为了存储这些信息，我们设想有一个叫做传输控制块（TCB）的数据结构。</p><p>One implementation strategy would have the local connection name be a pointer to the TCB for this connection.<br>一种实现策略是将本地连接名称作为指向该连接的 TCB 的指针。</p><p>The OPEN call also specifies whether the connection establishment is to be actively pursued, or to be passively waited for.<br>OPEN 调用还指定是主动连接建立，还是被动等待建立连接。</p><p>A passive OPEN request means that the process wants to accept incoming connection requests rather than attempting to initiate a connection.<br>被动 OPEN 请求意味着进程想要接受进来的连接请求，而不是尝试启动连接。</p><p>Often the process requesting a passive OPEN will accept a connection request from any caller.<br>被动 OPEN 的进程通常会接受来自任何调用者的连接请求。</p><p>In this case a foreign socket of all zeros is used to denote an unspecified socket.<br>在这种情况下，使用全 0 的外部套接字来表示未指定的套接字。</p><p>Unspecified foreign sockets are allowed only on passive OPENs.<br>未指定的外部套接字只允许在被动 OPEN 中使用。</p><p>A service process that wished to provide services for unknown other processes could issue a passive OPEN request with an unspecified foreign socket.<br>想要为未知的其他进程提供服务的服务进程可以使用未指定的外部套接字发起被动 OPEN 请求。</p><p>Then a connection could be made with any process that requested a connection to this local socket.<br>然后就可以与请求连接到此本地套接字的任何进程建立连接。</p><p>It would help if this local socket were known to be associated with this service.<br>如果已知这个本地套接字与此服务相关联，将会非常有用。</p><p>Well-known sockets are a convenient mechanism for a priori associating a socket address with a standard service.<br>well-known sockets 是一种便利的机制，可以先验地将套接字地址与标准服务联系起来。</p><p>For instance, the &ldquo;Telnet-Server&rdquo; process might be permanently assigned to a particular socket, and other sockets might be reserved for File Transfer, Remote Job Entry, Text Generator, Echoer, and Sink processes (the last three being for test purposes).<br>例如，&ldquo;Telnet-Server&rdquo; 进程可能被永久分配给一个特定的套接字，而其他套接字可能被保留用于文件传输、远程作业输入、文本生成器、回声器和接收器进程（最后三个用于测试目的）。</p><p>A socket address might be reserved for access to a &ldquo;Look-Up&rdquo; service which would return the specific socket at which a newly created service would be provided.<br>可以为访问 &ldquo;查找&rdquo; 服务保留套接字地址，该服务可以返回新创建服务的特定套接字。</p><p>The concept of a well-known socket is part of the TCP specification, but the assignment of sockets to services is outside this specification.<br>well-known socket 的概念是 TCP 规范的一部分，但将套接字分配给服务超出了该规范。</p><p>Processes can issue passive OPENs and wait for matching calls from other processes and be informed by the TCP when connections have been established.<br>进程可以发起被动的 OPEN，等待来自其他进程的相应调用，并在连接建立后由 TCP 通知。</p><p>Two processes which issue calls to each other at the same time are correctly connected.<br>两个在同一时间相互发出调用的进程可以正确建立连接。</p><p>This flexibility is critical for the support of distributed computing in which components act asynchronously with respect to each other.<br>这种灵活性对于支持分布式计算至关重要，在分布式计算中，组件彼此异步地工作。</p><p>There are two cases for matching the sockets in the local request and an incoming segment.<br>有两种情况用于匹配本地请求和收到 TCP 段中的套接字。</p><p>In the first case, the local request has fully specified the foreign socket. In this case, the match must be exact.<br>在第一种情况下，本地请求已经明确指定了外部套接字。在这种情况下，匹配是精确的。</p><p>In the second case, the local request has left the foreign socket unspecified. In this case, any foreign socket is acceptable as long as the local sockets match.<br>在第二种情况下，本地请求未指定外部套接字。在这种情况下，只要本地套接字匹配，任何外来套接字都是可以接受的。</p><p>If there are several pending passive OPENs (recorded in TCBs) with the same local socket, an incoming segment should be matched to a request with the specific foreign socket in the segment, if such a request exists, before selecting a request with an unspecified foreign socket.<br>如果有多个等待中的被动 OPEN（记录在 TCB 中）具有相同的本地套接字，则在选择具有未指定的外部套接字的请求之前，收到 TCP 段应该与拥有段中特定的外部套接字（如果存在此类请求）的请求相匹配。</p><p>The procedures to establish and clear connections utilize synchronize (SYN) and finis (FIN) control flags and involve an exchange of three messages.<br>建立和清除连接的过程使用同步 (SYN) 和结束 (FIN) 控制标志，并涉及三次消息交换。</p><p>This exchange has been termed a three-way hand shake [4].<br>这种交换被称为三次握手。</p><p>A connection is initiated by the rendezvous of an arriving segment containing a SYN and a waiting TCB entry created by a user OPEN command.<br>通过包含 SYN 的到达段和一个由用户 OPEN 命令创建的等待的 TCB 条目的会合而发起连接。</p><p>The matching of local and foreign sockets determines when a connection has been initiated.<br>本地套接字和外部套接字的匹配决定了连接何时开始。</p><p>The connection becomes &ldquo;established&rdquo; when sequence numbers have been synchronized in both directions.<br>当序列号在连接双向同步时，连接就建立了。</p><p>The clearing of a connection also involves the exchange of segments, in this case carrying the FIN control flag.<br>连接的清除也涉及到段的交换，在这种情况下，带有 FIN 控制标志。</p><h3 id=数据通信>数据通信
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e9%80%9a%e4%bf%a1>#</a></h3><p><strong>2.8. Data Communication</strong></p><p>The data that flows on a connection may be thought of as a stream of octets, or as a sequence of records.<br>在一个连接上流动的数据可以被认为是一个字节流，或者是一个记录的序列。</p><p>In TCP the records are called letters and are of variable length.
在 TCP 中，记录被称为信件，其长度是可变的。</p><p>The sending user indicates in each SEND call whether the data in that call completes a letter by the setting of the end-of-letter parameter.<br>发送用户在每个 SEND 调用中通过设置 end-of-letter 参数来表明该调用中的数据是否发送完了一个信件。</p><p>The length of a letter may be such that it must be broken into segments before it can be transmitted to its destination.
信件的长度可以是这样的：在将其传输到其目的地之前，必须将其分成多个段。</p><p>We assume that the segments will normally be reassembled into a letter before being passed to the receiving process.<br>我们假设这些片段通常会在传递给接收进程之前被重新组合成一个信件。</p><p>A segment may contain all or a part of a letter, but a segment never contains parts of more than one letter.<br>段可能包含一个信件的全部或部分，但一个段绝不包含多个信件的部分。</p><p>The end of a letter is marked by the appearance of an EOL control flag in a segment.<br>段中出现 EOL 控制标志表示一个信件的结束。</p><p>A sending TCP is allowed to collect data from the sending user and to send that data in segments at its own convenience, until the end of letter is signaled then it must send all unsent data.<br>发送 TCP 可以从发送用户那里收集数据，并在自己合适的时候分片发送这些数据，在发出信件结束的信号时，它必须发送所有未发送的数据。</p><p>When a receiving TCP has a complete letter, it must not wait for more data from the sending TCP before passing the letter to the receiving process.<br>当接收 TCP 收到一个完整的信件时，它必须先将信件传递给接收进程，然后再等待来自发送 TCP 的更多数据。</p><p>There is a coupling between letters as sent and the use of buffers of data that cross the TCP/user interface.<br>发送的信件和使用跨 TCP/用户接口的数据缓冲区之间存在耦合。</p><p>Each time an end-of-letter (EOL) flag is associated with data placed into the receiving user&rsquo;s buffer, the buffer is returned to the user for processing even if the buffer is not filled.<br>每当信件结尾（EOL）标志与放入接收用户缓冲区的数据相关联时，即使缓冲区未被填满，缓冲区也会返回给用户进行处理。</p><p>If a letter is longer than the user&rsquo;s buffer, the letter is passed to the user in buffer size units, the last of which may be only partly full.<br>如果一个信件比用户的缓冲区长，那么这个字母就会以缓冲区大小为单位传递给用户，最后一个缓冲区可能只有部分。</p><p>The receiving TCP&rsquo;s buffer size may be communicated to the sending TCP when the connection is being established.<br>在建立连接时，接收 TCP 的缓冲区大小可能会被传达给发送 TCP。</p><p>The TCP is responsible for regulating the flow of segments on the connections, as a way of preventing itself from becoming saturated or overloaded with traffic.<br>TCP 负责调节连接上的流量，以此来防止自己的流量达到饱和或过载。</p><p>This is done using a window flow control mechanism.<br>这是用流量窗口控制机制完成的。</p><p>The data receiving TCP reports to the data sending TCP a window which is the range of sequence numbers of data octets that data receiving TCP is currently prepared to accept.<br>接收 TCP 向发送 TCP 报告一个窗口，该窗口是数据接收 TCP 目前准备接受的字节数据的序列号范围。</p><p>TCP also provides a means to communicate to the receiver of data that at some point further along in the data stream than the receiver is currently reading there is urgent data.<br>TCP 还提供了一种方法来向数据的接收者传达，在数据流更远的地方中有比目前读取更紧急数据。</p><p>TCP does not attempt to define what the user specifically does upon being notified of pending urgent data, but the general notion is that the receiving process should take action to read through the end urgent data quickly.<br>TCP 并不试图定义用户在收到待处理紧急数据的通知后具体做什么，但一般的情况是，接收进程应该采取行动，尽快读完最后的紧急数据。</p><h3 id=优先级和安全性>优先级和安全性
<a class=anchor href=#%e4%bc%98%e5%85%88%e7%ba%a7%e5%92%8c%e5%ae%89%e5%85%a8%e6%80%a7>#</a></h3><p><strong>2.9. Precedence and Security</strong></p><p>The TCP makes use of the internet protocol type of service field and security option to provide precedence and security on a per connection basis to TCP users.
TCP 利用 IP 协议的服务类型字段和安全选项，在每个连接的基础上向 TCP 用户提供优先权和安全性。</p><p>Not all TCP modules will necessarily function in a multilevel secure environment, some may be limited to unclassified use only, and others may operate at only one security level and compartment.<br>并非所有 TCP 模块都必须在多级安全环境中运行，有些模块可能仅限于公开使用，而其他模块可能仅在一个安全级别和区段中运行。</p><p>Consequently, some TCP implementations and services to users may be limited to a subset of the multilevel secure case.<br>因此，某些 TCP 实现和对用户的服务可能仅限于多级安全情况的一个子集。</p><p>TCP modules which operate in a multilevel secure environment should properly mark outgoing segments with the security, compartment, and precedence.<br>在多级安全环境中运行的 TCP 模块应正确标记传出 TCP 段的安全性、分区和优先级。</p><p>Such TCP modules should also provide to their users or higher level protocols such as Telnet or THP an interface to allow them to specify the desired security level, compartment, and precedence of connections.<br>这样的 TCP 模块还应该为它们的用户或者更高层次的协议，例如 Telnet 或者 THP 提供一个接口，以便让它们指定所需的连接的安全级别、区段和优先级。</p><h3 id=稳健性原则>稳健性原则
<a class=anchor href=#%e7%a8%b3%e5%81%a5%e6%80%a7%e5%8e%9f%e5%88%99>#</a></h3><p><strong>2.10. Robustness Principle</strong></p><p>TCP implementations should follow a general principle of robustness: be conservative in what you do, be liberal in what you accept from others.<br>TCP 实现应该遵循一个一般的稳健性原则：在你做的事情上要保守，在你接受别人的事情上要自由。</p><h2 id=功能规范>功能规范
<a class=anchor href=#%e5%8a%9f%e8%83%bd%e8%a7%84%e8%8c%83>#</a></h2><p><strong>3.FUNCTIONAL SPECIFICATION</strong></p><h3 id=头部格式>头部格式
<a class=anchor href=#%e5%a4%b4%e9%83%a8%e6%a0%bc%e5%bc%8f>#</a></h3><p><strong>3.1. Header Format</strong></p><p>TCP segments are sent as internet datagrams. The Internet Protocol header carries several information fields, including the source and destination host addresses [2].<br>TCP 段以互联网数据报的形式发送。IP 协议报头携带多个信息字段，包括源主机地址和目的主机地址。</p><p>A TCP header follows the internet header, supplying information specific to the TCP protocol. This ivision allows for the existence of host level protocols other than TCP.<br>TCP 头部 在 IP 协议头部后面，提供 TCP 协议特定的信息。这种划分允许存在除 TCP 以外的主机级协议。</p><div class=text-center><p>TCP Header Format<br>TCP 头部格式</p><pre tabindex=0><code>0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |          Source Port          |       Destination Port        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        Sequence Number                        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                    Acknowledgment Number                      |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |  Data |           |U|A|E|R|S|F|                               |
  | Offset| Reserved  |R|C|O|S|Y|I|            Window             |
  |       |           |G|K|L|T|N|N|                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |           Checksum            |         Urgent Pointer        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                    Options                    |    Padding    |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                             data                              |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p>Note that one tick mark represents one bit position.<br>注意：一个刻度线代表一个比特位。</p><p>Figure 3.</p></div><p><strong>Source Port</strong>: 16 bits<br> The source port number.<br> 源端口号</p><p><strong>Destination Port</strong>: 16 bits<br> The destination port number.<br> 目标端口号</p><p><strong>Sequence Number</strong>: 32 bits<br> The sequence number of the first data octet in this segment (except when SYN is present).<br> 该段数据中第一个字节的序列号（有 SYN 标志除外）。</p><p><strong>Acknowledgment Number</strong>: 32 bits<br> If the ACK control bit is set this field contains the value of the next sequence number the sender of the segment is expecting to receive. Once a connection is established this is always sent.<br> 如果有 ACK 标志，这个字段表示发送者期望收到的下一个序列号的值。一旦建立了连接，一直会发送这个字段。</p><p><strong>Data Offset</strong>: 4 bits<br> The number of 32 bit words in the TCP Header. This indicates where the data begins. The TCP header including options is an integral number of 32 bits long.<br> 这个数表示 TCP 头部的长度有多少个 32 bit，表示真正数据开始的位置。TCP 头部（包括选项部分）的长度是 32 bit 的整数倍。</p><p><strong>Reserved</strong>: 6 bits<br> Reserved for future use. Must be zero.<br> 保留将来使用，全部为 0。</p><p><strong>Control Bits</strong>: 8 bits (from left to right):<br> URG: Urgent Pointer field significant 紧急标志<br> ACK: Acknowledgment field significant 确认标志<br> EOL: End of Letter 信件结束标志<br> RST: Reset the connection 重置标志<br> SYN: Synchronize sequence numbers 同步标志<br> FIN: No more data from sender 断开连接标志</p><p><strong>Window</strong>: 16 bits<br> The number of data octets beginning with the one indicated in the acknowledgment field which the sender of this segment is willing to accept.<br> 从确认序号开始，发送方可以接收的字节数。</p><p><strong>Checksum</strong>: 16 bits<br> The checksum field is the 16 bit one&rsquo;s complement of the one&rsquo;s complement sum of all 16 bit words in the header and text.<br> 检验和是头部和数据部分所有分割成 16 bit 数的经过二进制反码求和得到的数。<br> If a segment contains an odd number of header and text octets to be checksummed, the last octet is padded on the right with zeros to form a 16 bit word for checksum purposes.<br> 如果 TCP 段头部和数据部分是奇数个字节要进行校验，则在最后一个字节右边填充零，以形成一个 16 bit，用于校验。<br> The pad is not transmitted as part of the segment.<br> 填充不会作为 TCP 段的一部分进行传输。<br> While computing the checksum, the checksum field itself is replaced with zeros.<br> 在计算校验和时，校验和字段本身用零替换。</p><p> The checksum also covers a 96 bit pseudo header conceptually prefixed to the TCP header.<br> 在校验和时还包括一个 96 bit 的伪头部，加在 TCP 头部前面。<br> This pseudo header contains the Source Address, the Destination Address, the Protocol, and TCP length.<br> 这个伪头部包含源地址、目标地址、协议和 TCP 长度。<br> This gives the TCP protection against misrouted segments.<br> 这为 TCP 提供了防止错误路由 TCP 段的保护。<br> This information is carried in the Internet Protocol and is transferred across the TCP/Network interface in the arguments or results of calls by the TCP on the IP.<br> 这些信息在 IP 协议中携带，并在 TCP/网络 接口上通过 TCP 对 IP 的调用的参数或结果进行传输。</p><div class=text-center><pre tabindex=0><code>+--------------------------+
|      Source Address      |
+--------------------------+
|    Destination Address   |
+--------------------------+
| zero | PTCL | TCP Length |
+--------------------------+
</code></pre></div><p> The TCP Length is the TCP header plus the data length in octets (this is not an explicitly transmitted quantity, but is computed from the total length, and the header length).<br> TCP 长度是 TCP 报头加上数据部分的长度，单位是字节（这不是一个明确的传输量，而是从总长度和头部长度计算出来的）。</p><p><strong>Urgent Pointer</strong>: 16 bits<br> This field communicates the current value of the urgent pointer as a positive offset from the sequence number in this segment.<br> 这个字段表示当前紧急指针距离本段中序列号的正偏移。<br> The urgent pointer points to the sequence number of the octet following the urgent data.<br> 紧急指针指向紧急数据后的字节的序列号。<br> This field should only be interpreted in segments with the URG control bit set.<br> 这个字段只应在设置了 URG 标志的 TCP 段中使用。</p><p><strong>Options</strong>: variable<br> Options may occupy space at the end of the TCP header and are a multiple of 8 bits in length.<br> 选项部分可能占用 TCP 头的末尾的空间，长度为 8bit 的倍数。<br> All options are included in the checksum.<br> 选项部分也包括在检验和的计算中。<br> An option may begin on any octet boundary.<br> 选项部分可以从任何字节边界上开始。<br> There are two cases for the format of an option:<br> 选项的格式有两种情况：</p><ul><li>Case 1: A single octet of option-kind.<br>情况 1: 一个字节的选项类型。</li><li>Case 2: An octet of option-kind, an octet of option-length, and the actual option-data octets.<br>情况 2: 一个字节的选项类型、一个字节的选项长度和真正选项数据。</li></ul><p> The option-length counts the two octets of option-kind and option-length as well as the option-data octets.<br> 选项长度包括选项种类和选项长度的两个字节，以及选项数据的字节数。</p><p> Note that the list of options may be shorter than the data offset field might imply.<br> 注意：选项列表可能比数据偏移字段要短。<br> The content of the header beyond the End-of-Option option should be header padding (i.e., zero).<br> 头部中在选项之外的内容是填充（即，0）。</p><p> A TCP must implement all options.<br> TCP 必须实现所有选项。</p><p> Currently defined options include (kind indicated in octal):<br> 目前定义的选项包括（种类以八进制表示）：</p><pre tabindex=0><code>Kind     Length    Meaning
----     ------    -------
 0         -       End of option list.
 1         -       No-Operation.
100        -       Reserved.
105        4       Buffer Size.
</code></pre><p> Specific Option Definitions<br> 具体选项定义</p><p> End of Option List</p><pre tabindex=0><code>+--------+
|00000000|
+--------+
Kind=0
</code></pre><p> This option code indicates the end of the option list.<br> 该选项代码表示选项列表的结束。<br> This might not coincide with the end of the TCP header according to the Data Offset field.<br> 根据数据偏移字段，这可能与 TCP 头的结尾不一致。<br> This is used at the end of all options, not the end of each option, and need only be used if the end of the options would not otherwise coincide with the end of the TCP header.<br> 这用于所有选项的末尾，而不是每个选项的末尾，并且仅在选项末尾与 TCP 头末尾不一致时才需要使用。</p><p> No-Operation</p><pre tabindex=0><code>+--------+
|00000001|
+--------+
Kind=1
</code></pre><p> This option code may be used between options, for example, to align the beginning of a subsequent option on a word boundary.<br> 该选项代码可以在选项之间使用，例如，在一个字的边界上对准后续选项的开头。<br> There is no guarantee that senders will use this option, so receivers must be prepared to process options even if they do not begin on a word boundary.<br> 不能保证发送者会使用这个选项，所以接收者必须准备好处理选项，即使它们不以字的边界开始。</p><p> Buffer Size</p><pre tabindex=0><code>+--------+--------+---------+--------+
|01000101|00000100|    buffer size   |
+--------+--------+---------+--------+
Kind=105 Length=4
</code></pre><p> Buffer Size Option Data: 16 bits</p><p> If this option is present, then it communicates the receive buffer size at the TCP which sends this segment.<br> 如果该选项存在，那么它在发送该段的 TCP 上传达接收缓冲区的大小。<br> This field should only be sent in the initial connection request (i.e., in segments with the SYN control bit set).<br> 该字段应该只在初始连接请求中发送（即在设置了 SYN 标志的段中）。<br> If this option is not used, the default buffer size of one octet is assumed.<br> 如果不使用这个选项，则假定默认的缓冲区大小为一个字节。</p><p> Padding: variable</p><p> The TCP header padding is used to ensure that the TCP header ends and data begins on a 32 bit boundary. The padding is composed of zeros.<br> TCP 头的填充用于确保 TCP 头的结束和数据的开始都在 32 bit 边界上。填充是由零组成的。</p><h3 id=术语表>术语表
<a class=anchor href=#%e6%9c%af%e8%af%ad%e8%a1%a8>#</a></h3><p><strong>3.2. Terminology</strong></p><p>Before we can discuss very much about the operation of the TCP we need to introduce some detailed terminology.<br>在我们非常深入地讨论 TCP 的运作之前，我们需要介绍一些复杂的术语。</p><p>The maintenance of a TCP connection requires the remembering of several variables.<br>维护一个 TCP 连接需要记住几个变量。</p><p>We conceive of these variables being stored in a connection record called a Transmission Control Block or TCB.<br>我们设想这些变量被存储在一个叫做传输控制块或 TCB 的连接记录中。</p><p>Among the variables stored in the TCB are the local and remote socket numbers, the security and precedence of the connection, pointers to the user&rsquo;s send and receive buffers, pointers to the retransmit queue and to the current segment.<br>TCB 中存储的变量包括本地和远程套接字编号、连接的安全性和优先级、指向用户的发送和接收缓冲区的指针、指向重传队列和当前段的指针。</p><p>In addition several variables relating to the send and receive sequence numbers are stored in the TCB.<br>此外，与发送和接收序列号相关的几个变量存储在 TCB 中。</p><p>Send Sequence Variables<br>发送序列变量</p><pre tabindex=0><code>SND.UNA - send unacknowledged
SND.NXT - send sequence
SND.WND - send window
SND.BS  - send buffer size
SND.UP  - send urgent pointer
SND.WL  - send sequence number used for last window update
SND.LBB - send last buffer beginning
ISS     - initial send sequence number
</code></pre><p>Receive Sequence Variables<br>接收序列变量</p><pre tabindex=0><code>RCV.NXT - receive sequence
RCV.WND - receive window
RCV.BS  - receive buffer size
RCV.UP  - receive urgent pointer
RCV.LBB - receive last buffer beginning
IRS     - initial receive sequence number
</code></pre><p>The following diagrams may help to relate some of these variables to the sequence space.<br>下图可能有助于将其中一些变量与序列空间联系起来。<div class=text-center><pre tabindex=0><code>    1         2          3          4
----------|----------|----------|----------
SND.UNA    SND.NXT    SND.UNA
                     +SND.WND

1 - old sequence numbers which have been acknowledged
2 - sequence numbers of unacknowledged data
3 - sequence numbers allowed for new data transmission
4 - future sequence numbers which are not yet allowed
</code></pre><p>Send Sequence Space</p><p>Figure 4.</p></div></p><div class=text-center><pre tabindex=0><code>  1          2          3
----------|----------|----------
RCV.NXT    RCV.NXT
          +RCV.WND

1 - old sequence numbers which have been acknowledged
2 - sequence numbers allowed for new reception
3 - future sequence numbers which are not yet allowed
</code></pre><p>Receive Sequence Space</p><p>Figure 5.</p></div><p>There are also some variables used frequently in the discussion that take their values from the fields of the current segment.<br>还有一些在讨论中经常使用的变量，它们的值来自当前段的字段。</p><p>Current Segment Variables
当前段变量</p><pre tabindex=0><code>SEG.SEQ - segment sequence number
SEG.ACK - segment acknowledgment number
SEG.LEN - segment length
SEG.WND - segment window
SEG.UP  - segment urgent pointer
SEG.PRC - segment precedence value
</code></pre><p>A connection progresses through a series of states during its lifetime.<br>一个连接在其生命周期中会经历一系列的状态。</p><p>The states are: LISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, TIME-WAIT, CLOSE-WAIT, CLOSING, and the fictional state CLOSED.<br>这些状态是：LISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, TIME-WAIT, CLOSE-WAIT, CLOSING，以及虚构的状态 CLOSED。</p><p>CLOSED is fictional because it represents the state when there is no TCB, and therefore, no connection.<br>CLOSED 是虚构的，因为它代表了没有 TCB 的状态，也就是没有连接。</p><p>Briefly the meanings of the states are:<br>简而言之，这些状态的含义是：</p><p><strong>LISTEN</strong> - represents waiting for a connection request from any remote TCP and port.<br><strong>LISTEN</strong> - 表示等待来自任何远程 TCP 和端口的连接请求。</p><p><strong>SYN-SENT</strong> - represents waiting for a matching connection request after having sent a connection request.<br><strong>SYN-SENT</strong> - 表示在发送了一个连接请求后等待一个匹配的连接请求。</p><p><strong>SYN-RECEIVED</strong> - represents waiting for a confirming connection request acknowledgment after having both received and sent a connection request.<br><strong>SYN-RECEIVED</strong> - 表示在收到和发送连接请求后，等待确认连接请求的确认。</p><p><strong>ESTABLISHED</strong> - represents an open connection, ready to transmit and receive data segments.<br><strong>ESTABLISHED</strong> - 代表一个已建立的连接，准备发送和接收 TCP 段。</p><p><strong>FIN-WAIT-1</strong> - represents waiting for a connection termination request from the remote TCP, or an acknowledgment of the connection termination request previously sent.<br><strong>FIN-WAIT-1</strong> - 表示等待来自远程 TCP 的连接终止请求，或等待之前发送的终止连接请求的确认。</p><p><strong>FIN-WAIT-2</strong> - represents waiting for a connection termination request from the remote TCP.<br><strong>FIN-WAIT-2</strong> - 表示等待来自远程 TCP 的连接终止请求。</p><p><strong>TIME-WAIT</strong> - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.<br><strong>TIME-WAIT</strong> - 表示等待足够的时间来确保远程 TCP 收到其连接终止请求的确认。</p><p><strong>CLOSE-WAIT</strong> - represents waiting for a connection termination request from the local user.<br><strong>CLOSE-WAIT</strong> - 表示等待本端用户的连接终止请求。</p><p><strong>CLOSING</strong> - represents waiting for a connection termination request acknowledgment from the remote TCP.<br><strong>CLOSING</strong> - 表示等待来自远程 TCP 的连接终止请求确认。</p><p><strong>CLOSED</strong> - represents no connection state at all.<br><strong>CLOSED</strong> - 表示没有连接的状态。</p><p>A TCP connection progresses from one state to another in response to events.<br>TCP 连接根据事件从一个状态转换到另一个状态。</p><p>The events are the user calls, OPEN, SEND, RECEIVE, CLOSE, ABORT, and STATUS; the incoming segments, particularly those containing the SYN and FIN flags; and timeouts.<br>这些事件是用户调用 OPEN、SEND、RECEIVE、CLOSE、ABORT 和 STATUS；收到 TCP 段，特别是包含 SYN 和 FIN 标志的段；以及超时。</p><p>The Glossary contains a more complete list of terms and their definitions.<br>术语表包含了一个更完整的术语及其定义清单。</p><p>The state diagram in figure 6 only illustrates state changes, together with the causing events and resulting actions, but addresses neither error conditions nor actions which are not connected with state changes.<br>图 6 中的状态图只说明了状态的变化，以及引起的事件和触发的行为，但既没有涉及错误条件，也没有涉及与状态变化无关的行为。</p><p>In a later section, more detail is offered with respect to the reaction of the TCP to events.<br>在后面的章节中，将提供关于 TCP 对事件反应的更多细节。</p><pre tabindex=0><code>                              +---------+ ---------\      active OPEN
                              |  CLOSED |            \    -----------
                              +---------+&lt;---------\   \   create TCB
                                |     ^              \   \  snd SYN
                   passive OPEN |     |   CLOSE        \   \
                   ------------ |     | ----------       \   \
                    create TCB  |     | delete TCB         \   \
                                V     |                      \   \
                              +---------+            CLOSE    |    \
                              |  LISTEN |          ---------- |     |
                              +---------+          delete TCB |     |
                   rcv SYN      |     |     SEND              |     |
                  -----------   |     |    -------            |     V
 +---------+      snd SYN,ACK  /       \   snd SYN          +---------+
 |         |&lt;-----------------           ------------------&gt;|         |
 |   SYN   |                    rcv SYN                     |   SYN   |
 |   RCVD  |&lt;-----------------------------------------------|   SENT  |
 |         |                    snd ACK                     |         |
 |         |------------------           -------------------|         |
 +---------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +---------+
   |           --------------   |     |   -----------
   |                  x         |     |     snd ACK
   |                            V     V
   |  CLOSE                   +---------+
   | -------                  |  ESTAB  |
   | snd FIN                  +---------+
   |                   CLOSE    |     |    rcv FIN
   V                  -------   |     |    -------
 +---------+          snd FIN  /       \   snd ACK          +---------+
 |  FIN    |&lt;-----------------           ------------------&gt;|  CLOSE  |
 | WAIT-1  |------------------           -------------------|   WAIT  |
 +---------+          rcv FIN  \       /   CLOSE            +---------+
   | rcv ACK of FIN   -------   |     |   -------
   | --------------   snd ACK   |     |   snd FIN
   V        x                   V     V
 +---------+                  +---------+
 |FINWAIT-2|                  | CLOSING |
 +---------+                  +---------+
   | rcv FIN                          | rcv ACK of FIN
   | -------    Timeout=2MSL          | --------------
   V snd ACK    ------------          V   delete TCB
 +---------+     delete TCB   +---------+
 |TIME WAIT|-----------------&gt;| CLOSED  |
 +---------+                  +---------+
</code></pre><div class=text-center><p>TCP Connection State Diagram<br>TCP 连接状态图</p><p>Figure 6.</p></div><h3 id=序列号>序列号
<a class=anchor href=#%e5%ba%8f%e5%88%97%e5%8f%b7>#</a></h3><p><strong>3.3. Sequence Numbers</strong></p><p>A fundamental notion in the design is that every octet of data sent over a TCP connection has a sequence number.<br>TCP 设计中的一个基本概念是，通过 TCP 连接发送的每个字节的数据都有一个序列号。</p><p>Since every octet is sequenced, each of them can be acknowledged.<br>由于每个字节都是有顺序的，所以每个字节都可以被确认。</p><p>The acknowledgment mechanism employed is cumulative so that an acknowledgment of sequence number X indicates that all octets up to but not including X have been received.<br>TCP 所采用的确认机制是累积性的，因此序列号为 X 的确认表示已经收到了之前但不包括 X 的所有字节。</p><p>This mechanism allows for straight-forward duplicate detection in the presence of retransmission.<br>这种机制使得在存在重传的情况下可以直接进行重复检测。</p><p>Numbering of octets within a segment is that the first data octet immediately following the header is the lowest numbered, and the following octets are numbered consecutively.<br>TCP 段内字节的编号是，TCP 头后的第一个字节数据是最小的编号，后面字节的编号是连续递增。</p><p>It is essential to remember that the actual sequence number space is finite, though very large.<br>需要记住，实际的序列号范围是有限的，尽管非常大。</p><p>This space ranges from 0 to 2**32 - 1.<br>这个范围是从 0 到 2**32-1 。</p><p>Since the space is finite, all arithmetic dealing with sequence numbers must be performed modulo 2**32.<br>由于范围是有限的，所有处理序列号的运算都必须模 2**32。</p><p>This unsigned arithmetic preserves the relationship of sequence numbers as they cycle from 2**32 - 1 to 0 again.<br>这种无符号算术保留了序列号之间的关系，因为它们从 2**32-1 再重新到 0。</p><p>There are some subtleties to computer modulo arithmetic, so great care should be taken in programming the comparison of such values.<br>计算机模运算有一些细微的差异，所以在编程比较这些值时应该非常小心。</p><p>The typical kinds of sequence number comparisons which the TCP must perform include:<br>TCP 中需要操作的典型的序列号比较包括：</p><p>(a) Determining that an acknowledgment refers to some sequence number sent but not yet acknowledged.<br>(a) 确定一个确认是对应某个已发送但尚未确认的序列号。</p><p>(b) Determining that all sequence numbers occupied by a segment have been acknowledged (e.g., to remove the segment from a retransmission queue).<br>(b) 确定 TCP 段所占用的所有序列号都已被确认（例如，从重传队列中删除该 TCP 段）。</p><p>(c) Determining that an incoming segment contains sequence numbers which are expected (i.e., that the segment &ldquo;overlaps&rdquo; the receive window).<br>(c) 确定一个收到的 TCP 段包含预期的序列号（即该 TCP 段与接收窗口"重叠&rdquo;）。</p><p>On send connections the following comparisons are needed:<br>在发送端的连接上，需要进行以下比较：</p><pre tabindex=0><code>      older sequence numbers                        newer sequence numbers

            SND.UNA                SEG.ACK                 SND.NXT
              |                      |                       |
          ----|----XXXXXXX------XXXXXXXXXX---------XXXXXX----|----
              |    |            |    |             |         |
                   |            |                  |
                Segment 1    Segment 2          Segment 3

                         &lt;----- sequence space -----&gt;
</code></pre><div class=text-center><p>Sending Sequence Space Information<br>发送序列空间信息</p><p>Figure 7.</p></div><p>SND.UNA = oldest unacknowledged sequence number<br>SND.UNA = 最早的未确认的序列号</p><p>SND.NXT = next sequence number to be sent<br>SND.NXT = 下一个要发送的序列号</p><p>SEG.ACK = acknowledgment (next sequence number expected by the acknowledging TCP)<br>SEG.ACK = 确认（确认的 TCP 所期望的下一个序列号）。</p><p>SEG.SEQ = first sequence number of a segment<br>SEG.SEQ = TCP 段的第一个序列号</p><p>SEG.SEQ+SEG.LEN-1 = last sequence number of a segment<br>SEG.SEQ+SEG.LEN-1 = TCP 段的最后一个序列号</p><p>A new acknowledgment (called an &ldquo;acceptable ack&rdquo;), is one for which the inequality below holds:<br>一个新的确认（即 &ldquo;可接受的确认&rdquo;），会满足以下不等式。<br>SND.UNA &lt; SEG.ACK =&lt; SND.NXT</p><p>All arithmetic is modulo 2**32 and that comparisons are unsigned.<br>所有的运算都是模 2/**32，而且是无符号比较。</p><p>&ldquo;=&lt;&rdquo; means &ldquo;less than or equal&rdquo;.<br>&ldquo;=&lt;&rdquo; 表示 &ldquo;小于或等于&rdquo;。</p><p>A segment on the retransmission queue is fully acknowledged if the sum of its sequence number and length is less than the acknowledgment value in the incoming segment.<br>如果重传队列中的一个 TCP 段的序列号和长度之和小于收到段的确认值，则该段被完全确认。</p><p>SEG.LEN is the number of octets occupied by the data in the segment.<br>SEG.LEN 是 TCP 段中数据所占的字节数。</p><p>It is important to note that SEG.LEN must be non-zero; segments which do not occupy any sequence space (e.g., empty acknowledgment segments) are never placed on the retransmission queue, so would not go through this particular test.<br>值得注意的是，SEG.LEN 必须非零；不占用任何序列空间的 TCP 段（例如，空的确认段）永远不会被放在重传队列中，所以不用做这个特殊的测试。</p><p>On receive connections the following comparisons are needed:<br>在接收端的连接上，需要进行以下比较：</p><pre tabindex=0><code>      older sequence numbers                        newer sequence numbers

                    RCV.NXT                         RCV.NXT+RCV.WND
                      |                               |
          ---------XXX|XXX------XXXXXXXXXX---------XXX|XX---------
                    |  |         |                  |  |
                    |            |                  |
                Segment 1    Segment 2          Segment 3

                        &lt;----- sequence space -----&gt;
</code></pre><div class=text-center><p>Receiving Sequence Space Information<br>接收序列空间信息</p><p>Figure 8.</p></div><p>RCV.NXT = next sequence number expected on incoming segments<br>RCV.NXT = 下一个预期收到 TCP 段的序列号</p><p>RCV.NXT+RCV.WND = last sequence number expected on incoming segments, plus one
RCV.NXT+RCV.WND = 最后一个预期收到 TCP 段的序列号+1</p><p>SEG.SEQ = first sequence number occupied by the incoming segment<br>SEG.SEQ = 收到 TCP 段的第一个序列号</p><p>SEG.SEQ+SEG.LEN-1 = last sequence number occupied by the incoming segment
SEG.SEQ+SEG.LEN-1 = 收到 TCP 段的最后一个序列号</p><p>A segment is judged to occupy a portion of valid receive sequence space if<br>在下列情况下，一个 TCP 段被判断为占据了有效接收序列范围的一部分</p><p>0 =&lt; (SEG.SEQ+SEG.LEN-1 - RCV.NXT) &lt; (RCV.NXT+RCV.WND - RCV.NXT)</p><p>SEG.SEQ+SEG.LEN-1 is the last sequence number occupied by the segment; RCV.NXT is the next sequence number expected on an incoming segment; and RCV.NXT+RCV.WND is the right edge of the receive window.<br>SEG.SEQ+SEG.LEN-1 是该 TCP 段所占用的最后一个序列号；RCV.NXT 是下一个预期收到的 TCP 段的序列号；RCV.NXT+RCV.WND 是接收窗口的右边界。</p><p>Actually, it is a little more complicated than this. Due to zero windows and zero length segments, we have four cases for the acceptability of an incoming segment:<br>实际上，情况比这更复杂一些。由于零窗口和零长度的 TCP 段，我们有四种情况来判断一个收到的 TCP 段是否可接受：</p><pre tabindex=0><code>Segment Receive  Test
Length  Window
------- -------  -------------------------------------------
    0       0     SEG.SEQ = RCV.NXT
    0      &gt;0     RCV.NXT =&lt; SEG.SEQ &lt; RCV.NXT+RCV.WND
   &gt;0       0     not acceptable
   &gt;0      &gt;0     RCV.NXT &lt; SEG.SEQ+SEG.LEN =&lt; RCV.NXT+RCV.WND
</code></pre><p>Note that the acceptance test for a segment, since it requires the end of a segment to lie in the window, is somewhat more restrictive than is absolutely necessary.<br>请注意，TCP 段的验收测试，因为它要求 TCP 段的末端位于窗口中，所以比绝对必要的更具限制性。</p><p>If at least the first sequence number of the segment lies in the receive window, or if some part of the segment lies in the receive window, then the segment might be judged acceptable.<br>如果该 TCP 段至少第一个序列号在接收窗口内，或者该段的某些部分在接收窗口内，那么该 TCP 段可能被判定为可接受。</p><p>Thus, in figure 8, at least segments 1 and 2 are acceptable by the strict rule, and segment 3 may or may not be, depending on the strictness of interpretation of the rule.<br>因此，在图 8 中，根据严格的规则，至少第 1 和第 2 个 TCP 段是可以接受的，而第 3 个 TCP 段可能是，也可能不是，这取决于对规则解释的严格程度。</p><p>Note that when the receive window is zero no segments should be acceptable except ACK segments.<br>请注意，当接收窗口为零时，除了 ACK 段外，不应接受其他 TCP 段。</p><p>Thus, it should be possible for a TCP to maintain a zero receive window while transmitting data and receiving ACKs.<br>因此，TCP 应该有可能在传输数据和接收 ACK 的同时保持一个零接收窗口。</p><p>We have taken advantage of the numbering scheme to protect certain control information as well.
我们还利用了编号方案来保护某些控制信息。</p><p>This is achieved by implicitly including some control flags in the sequence space so they can be retransmitted and acknowledged without confusion (i.e., one and only one copy of the control will be acted upon).<br>这是通过在序列空间中隐含地包括一些控制标志来实现的，使得它们可以被重发和确认而不会产生混淆(即，将对控制的一个且仅一个副本进行操作)。</p><p>Control information is not physically carried in the segment data space.<br>控制信息不实际在 TCP 段数据空间中携带。</p><p>Consequently, we must adopt rules for implicitly assigning sequence numbers to control.
因此，我们必须采用隐式分配序列号的规则来控制。</p><p>The SYN and FIN are the only controls requiring this protection, and these controls are used only at connection opening and closing.<br>SYN 和 FIN 是唯一需要这种保护的控制，而且这些控制只在连接打开和关闭时使用。</p><p>For sequence number purposes, the SYN is considered to occur before the first actual data octet of the segment in which it occurs, while the FIN is considered to occur after the last actual data octet in a segment in which it occurs.<br>就序列号而言，SYN 被认为发生在其所在 TCP 段的实际数据第一个字节之前，而 FIN 被认为发生在其所在段的实际数据的最后一个字节之后。</p><p>The segment length includes both data and sequence space occupying controls.<br>TCP 段的长度包括数据和占用序列空间的控制信息。</p><p>When a SYN is present then SEG.SEQ is the sequence number of the SYN.<br>当存在 SYN 时，SEG.SEQ 是 SYN 的序列号。</p><p><strong>Initial Sequence Number Selection</strong><br><strong>初始序列号的选择</strong></p><p>The protocol places no restriction on a particular connection being used over and over again.<br>该协议不限制反复使用特定连接。</p><p>A connection is defined by a pair of sockets.<br>一个连接是由一对套接字确定的。</p><p>New instances of a connection will be referred to as incarnations of the connection.<br>连接的新实例会用来表示连接。</p><p>The problem that arises owing to this is &ndash; &ldquo;how does the TCP identify duplicate segments from previous incarnations of the connection?&rdquo;<br>由此产生的问题是 &ndash; &ldquo;TCP 如何识别来自以前连接中的重复段？&rdquo;</p><p>This problem becomes apparent if the connection is being opened and closed in quick succession, or if the connection breaks with loss of memory and is then reestablished.<br>如果快速连续地打开和关闭连接，或者如果连接因内存丢失而断开，然后重新建立，则此问题会变得明显。</p><p>To avoid confusion we must prevent segments from one incarnation of a connection from being used while the same sequence numbers may still be present in the network from an earlier incarnation.<br>为了防止出现混乱，我们必须防止使用来自先前连接中有相同序列号的数据段。</p><p>We want to assure this, even if a TCP crashes and loses all knowledge of the sequence numbers it has been using.<br>我们要保证这一点，即使 TCP 崩溃并失去了它使用的序列号的所有信息。</p><p>When new connections are created, an initial sequence number (ISN) generator is employed which selects a new 32 bit ISN.<br>当创建新连接时，使用初始序列号(ISN)生成器选择新的 32 位 ISN。</p><p>The generator is bound to a (possibly fictitious) 32 bit clock whose low order bit is incremented roughly every 4 microseconds.<br>发生器跟一个（可能是虚拟的）32 位时钟绑定，其低位大约每 4 微秒递增一次。</p><p>Thus, the ISN cycles approximately every 4.55 hours.<br>因此，ISN 大约每 4.55 小时循环一次。</p><p>Since we assume that segments will stay in the network no more than tens of seconds or minutes, at worst, we can reasonably assume that ISN&rsquo;s will be unique.<br>由于我们假设 TCP 段在网络中的停留时间不超过几十秒或几分钟，即使在最坏的情况下，我们仍然可以地假设 ISN 将是唯一的。</p><p>For each connection there is a send sequence number and a receive sequence number.<br>对于每个连接，都有一个发送序列号和一个接收序列号。</p><p>The initial send sequence number (ISS) is chosen by the data sending TCP, and the initial receive sequence number (IRS) is learned during the connection establishing procedure.<br>初始发送序列号（ISS）由发送方的 TCP 选择，初始接收序列号（IRS）在连接建立过程中得到。</p><p>For a connection to be established or initialized, the two TCPs must synchronize on each other&rsquo;s initial sequence numbers.<br>如果要建立或初始化的连接，两个 TCP 必须同步对方的初始序列号。</p><p>This is done in an exchange of connection establishing messages carrying a control bit called &ldquo;SYN&rdquo; (for synchronize) and the initial sequence numbers.<br>这是通过交换建立连接的信息来完成的，这些信息带有一个称为 &ldquo;SYN&rdquo;（用于同步）的控制位和初始序列号。</p><p>As a shorthand, messages carrying the SYN bit are also called &ldquo;SYNs&rdquo;.<br>简而言之，携带 SYN 位的消息也称为 &ldquo;SYNs&rdquo;。</p><p>Hence, the solution requires a suitable mechanism for picking an initial sequence number and a slightly involved handshake to exchange the ISN&rsquo;s.<br>因此，该解决方案需要一个合适的机制来挑选初始序列号，并需要一个稍微复杂的握手来交换 ISN。</p><p>A &ldquo;three way handshake&rdquo; is necessary because sequence numbers are not tied to a global clock in the network, and TCPs may have different mechanisms for picking the ISN&rsquo;s.
&ldquo;三次握手&rdquo; 是必要的，因为序列号没有绑定到网络中的全局时钟，并且 TCP 可能有不同的机制来挑选 ISN。</p><p>The receiver of the first SYN has no way of knowing whether the segment was an old delayed one or not, unless it remembers the last sequence number used on the connection (which is not always possible), and so it must ask the sender to verify this SYN.
第一个 SYN 的接收者没有办法知道这个 TCP 段是否是一个旧的延迟段，除非它记得连接上使用的最后一个序列号（这并不总是可能的），所以它必须要求发送者验证这个 SYN。</p><p>The &ldquo;three way handshake&rdquo; and the advantages of a &ldquo;clock-driven&rdquo; scheme are discussed in [4].<br>在[4]中讨论了 &ldquo;三次握手&rdquo; 和 &ldquo;时钟驱动&rdquo; 方案的优势。</p><p><strong>Knowing When to Keep Quiet</strong><br><strong>知道什么时候该保持静默</strong></p><p>To be sure that a TCP does not create a segment that carries a sequence number which may be duplicated by an old segment remaining in the network, the TCP must keep quiet for a maximum segment lifetime (MSL) before assigning any sequence numbers upon starting up or recovering from a crash in which memory of sequence numbers in use was lost.<br>为了确保 TCP 不会创建一个携带与网络中旧 TCP 段中序列号重复的 TCP 段，TCP 在启动时或从丢失当前使用序列号内存的崩溃中恢复时，在分配任何序列号之前保持最大网段寿命（MSL）的静默时间。</p><p>For this specification the MSL is taken to be 2 minutes.<br>在本规范中，MSL 是 2 分钟。</p><p>This is an engineering choice, and may be changed if experience indicates it is desirable to do so.<br>这是一个工程选择，它可能会根据经验改变。</p><p>Note that if a TCP is reinitialized in some sense, yet retains its memory of sequence numbers in use, then it need not wait at all; it must only be sure to use sequence numbers larger than those recently used.<br>请注意，如果一个 TCP 在某种情况被重新初始化，但保留了其正在使用的序列号的内存，那么它不需要等待；它只需要确保使用比最近使用的序列号大的序列号。</p><p>It should be noted that this strategy does not protect against spoofing or other replay type duplicate message problems.<br>应该注意的是，这种策略不能防止欺骗或其他重复发送相同信息问题。</p><h3 id=建立连接>建立连接
<a class=anchor href=#%e5%bb%ba%e7%ab%8b%e8%bf%9e%e6%8e%a5>#</a></h3><p><strong>3.4. Establishing a connection</strong></p><p>The &ldquo;three-way handshake&rdquo; is the procedure used to establish a connection.<br>&ldquo;三次握手"是用于建立连接的过程。</p><p>This procedure normally is initiated by one TCP and responded to by another TCP.<br>这个过程通常由一个 TCP 发起，由另一个 TCP 响应。</p><p>The procedure also works if two TCP simultaneously initiate the procedure.<br>如果两个 TCP 同时发起连接，该过程也应正常工作。</p><p>When simultaneous attempt occurs, the TCP receives a &ldquo;SYN&rdquo; segment which carries no acknowledgment after it has sent a &ldquo;SYN&rdquo;.<br>当同时尝试建立连接时，TCP 在发送 &ldquo;SYN&rdquo; 后，收到没有携带确认的 &ldquo;SYN&rdquo; 段。</p><p>Of course, the arrival of an old duplicate &ldquo;SYN&rdquo; segment can potentially make it appear, to the recipient, that a simultaneous connection initiation is in progress.<br>当然，当接收者收到一个旧的重复的 &ldquo;SYN&rdquo; 段时，有可能会认为是同时建立连接。</p><p>Proper use of &ldquo;reset&rdquo; segments can disambiguate these cases.<br>适当使用 &ldquo;reset&rdquo; 段可以消除这些情况。</p><p>Several examples of connection initiation follow.<br>下面是几个建立连接的例子。</p><p>Although these examples do not show connection synchronization using data-carrying segments, this is perfectly legitimate, so long as the receiving TCP doesn&rsquo;t deliver the data to the user until it is clear the data is valid (i.e., the data must be buffered at the receiver until the connection reaches the ESTABLISHED state).<br>虽然这些例子中连接同步没有显示携带数据，这是完全可以的，在接收 TCP 明确数据有效之前，它不向用户传递数据（即这些数据必须先放在接收者的缓存中，直到连接达到 ESTABLISHED 状态）。</p><p>The three-way handshake reduces the possibility of false connections.<br>三次握手降低了错误连接的可能性。</p><p>It is the implementation of a trade-off between memory and messages to provide information for this checking.<br>它是内存和消息之间的权衡的实现，为该检查提供信息。</p><p>The simplest three-way handshake is shown in figure 9 below.<br>最简单的三次握手如下面的图 9 所示。</p><p>The figures should be interpreted in the following way.<br>这些符号应作如下解释。</p><p>Each line is numbered for reference purposes.<br>每行都有编号，以便参考。</p><p>Right arrows (&ndash;>) indicate departure of a TCP segment from TCP A to TCP B, or arrival of a segment at B from A.<br>右箭头 (&ndash;>) 表示从 TCP A 发送到 TCP B 的 TCP 段，或 B 接收到 A 的 TCP 段。</p><p>Left arrows (&lt;&ndash;), indicate the reverse.<br>左箭头 (&lt;&ndash;) 表示相反方向。</p><p>Ellipsis (&mldr;) indicates a segment which is still in the network (delayed).<br>省略号 (&mldr;) 表示仍在网络中的 TCP 段(延迟了)。</p><p>An &ldquo;XXX&rdquo; indicates a segment which is lost or rejected.<br>&ldquo;XXX&rdquo; 表示丢失或被拒绝的 TCP 段。</p><p>Comments appear in parentheses.<br>括号中的是注释。</p><p>TCP states represent the state AFTER the departure or arrival of the segment (whose contents are shown in the center of each line).<br>TCP 状态表示数据段发送或到达后的状态(其内容显示在每行的中间)。</p><p>Segment contents are shown in abbreviated form, with sequence number, control flags, and ACK field.<br>TCP 段的内容以缩写的形式显示，包括序列号、控制标志和 ACK 字段。</p><p>Other fields such as window, addresses, lengths, and text have been left out in the interest of clarity.<br>为清楚起见，省略了其他字段，如窗口、地址、长度和文本。</p><pre tabindex=0><code>      TCP A                                                 TCP B
  1.  CLOSED                                                LISTEN
  2.  SYN-SENT    --&gt; &lt;SEQ=100&gt;&lt;CTL=SYN&gt;                --&gt; SYN-RECEIVED
  3.  ESTABLISHED &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt;   &lt;-- SYN-RECEIVED
  4.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;       --&gt; ESTABLISHED
  5.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;&lt;DATA&gt; --&gt; ESTABLISHED
</code></pre><div class=text-center><p>Basic 3-Way Handshake for Connection Synchronization<br>用于连接同步的基础三次握手协议</p><p>Figure 9.</p></div><p>In line 2 of figure 9, TCP A begins by sending a SYN segment indicating that it will use sequence numbers starting with sequence number 100.<br>在图 9 的第 2 行，TCP A 开始发送一个 SYN 段，表明它将使用从序列号 100 开始的序列号。</p><p>In line 3, TCP B sends a SYN and acknowledges the SYN it received from TCP A.<br>在第 3 行，TCP B 发送了一个 SYN，并确认了它从 TCP A 收到的 SYN。</p><p>Note that the acknowledgment field indicates TCP B is now expecting to hear sequence 101, acknowledging the SYN which occupied sequence 100.<br>注意，确认字段表明 TCP B 现在期望收到到序列 101，确认收到序列 100 的 SYN。</p><p>At line 4, TCP A responds with an empty segment containing an ACK for TCP B&rsquo;s SYN; and in line 5, TCP A sends some data.<br>在第 4 行，TCP A 发送一个包含 ACK 的空段回应 TCP B 的 SYN；在第 5 行，TCP A 发送了一些数据。</p><p>Note that the sequence number of the segment in line 5 is the same as in line 4 because the ACK does not occupy sequence number space (if it did, we would wind up ACKing ACK&rsquo;s!).<br>请注意，第 5 行的 TCP 段的序列号与第 4 行相同，因为 ACK 不占用序列号空间（如果它占用了，我们就会变成 ACK 的 ACK！）。</p><p>Simultaneous initiation is only slightly more complex, as is shown in figure 10.<br>同时建立连接只是稍微复杂一些，如图 10 所示。</p><p>Each TCP cycles from CLOSED to SYN-SENT to SYN-RECEIVED to ESTABLISHED.<br>每个 TCP 从 CLOSED 到 SYN-SENT 到 SYN-RECEIVED 到 ESTABLISHED 循环。</p><p>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.<br>三次握手的主要原因是为了防止旧的重复连接启动造成混乱。</p><p>To deal with this, a special control message, reset, has been devised.<br>为了解决这个问题，我们设计了一个特殊的控制消息&ndash;reset。</p><p>If the receiving TCP is in a non-synchronized state (i.e., SYN-SENT, SYN-RECEIVED), it returns to LISTEN on receiving an acceptable reset.<br>如果接收的 TCP 处于非同步状态（即 SYN-SENT，SYN-RECEIVED），它在收到有效的 reset 时返回到 LISTEN。</p><p>If the TCP is in one of the synchronized states (ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, TIME-WAIT, CLOSE-WAIT, CLOSING), it aborts the connection and informs its user.<br>如果 TCP 处于同步状态之一（ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, TIME-WAIT, CLOSE-WAIT, CLOSING），它将中止连接并通知其用户。</p><p>We discuss this latter case under &ldquo;half-open&rdquo; connections below.<br>我们将在下面的 &ldquo;half-open&rdquo; 连接下讨论后面一种情况。</p><pre tabindex=0><code>      TCP A                                        TCP B
  1.  CLOSED                                       CLOSED
  2.  SYN-SENT     --&gt; &lt;SEQ=100&gt;&lt;CTL=SYN&gt;          ...
  3.  SYN-RECEIVED &lt;-- &lt;SEQ=300&gt;&lt;CTL=SYN&gt;          &lt;-- SYN-SENT
  4.               ... &lt;SEQ=100&gt;&lt;CTL=SYN&gt;          --&gt; SYN-RECEIVED
  5.  SYN-RECEIVED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt; ...
  6.  ESTABLISHED  &lt;-- &lt;SEQ=301&gt;&lt;ACK=101&gt;&lt;CTL=ACK&gt; &lt;-- SYN-RECEIVED
  7.               ... &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt; --&gt; ESTABLISHED
</code></pre><div class=text-center><p>Simultaneous Connection Synchronization<br>同时连接同步</p><p>Figure 10.</p></div><pre tabindex=0><code>      TCP A                                                TCP B
  1.  CLOSED                                               LISTEN
  2.  SYN-SENT    --&gt; &lt;SEQ=100&gt;&lt;CTL=SYN&gt;               ...
  3.  (duplicate) ... &lt;SEQ=1000&gt;&lt;CTL=SYN&gt;              --&gt; SYN-RECEIVED
  4.  SYN-SENT    &lt;-- &lt;SEQ=300&gt;&lt;ACK=1001&gt;&lt;CTL=SYN,ACK&gt; &lt;-- SYN-RECEIVED
  5.  SYN-SENT    --&gt; &lt;SEQ=1001&gt;&lt;CTL=RST&gt;              --&gt; LISTEN

  6.              ... &lt;SEQ=100&gt;&lt;CTL=SYN&gt;               --&gt; SYN-RECEIVED
  7.  SYN-SENT    &lt;-- &lt;SEQ=400&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt;  &lt;-- SYN-RECEIVED
  8.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=401&gt;&lt;CTL=ACK&gt;      --&gt; ESTABLISHED
</code></pre><div class=text-center><p>Recovery from Old Duplicate SYN<br>从之前重复 SYN 中恢复</p><p>Figure 11.</p></div><p>As a simple example of recovery from old duplicates, consider figure 11.<br>从之前重复 SYN 中恢复的简单示例，请参见图 11。</p><p>At line 3, an old duplicate SYN arrives at TCP B.<br>在第 3 行，一个之前重复 SYN 到达了 TCP B。</p><p>TCP B cannot tell that this is an old duplicate, so it responds normally (line 4).<br>TCP B 无法断定这是之前的 SYN，所以它正常响应（第 4 行）。</p><p>TCP A detects that the ACK field is incorrect and returns a RST (reset) with its SEQ field selected to make the segment believable.<br>TCP A 检测到 ACK 字段不正确，然后返回一个 RST（重置），同时选择 SEQ 字段以使该 TCP 段可信。</p><p>TCP B, on receiving the RST, returns to the LISTEN state.<br>TCP B 收到 RST 后，返回到 LISTEN 状态。</p><p>When the original SYN (pun intended) finally arrives at line 6, the synchronization proceeds normally.<br>在第 6 行，当真正的 SYN（双关语）最终到达时，同步正常进行。</p><p>If the SYN at line 6 had arrived before the RST, a more complex exchange might have occurred with RST&rsquo;s sent in both directions.<br>如果第 6 行的 SYN 在 RST 之前到达，则可能会发生更复杂的交换，双方都会发送 RST。</p><p><strong>Half-Open Connections and Other Anomalies</strong><br><strong>半开放连接和其他异常情况</strong></p><p>An established connection is said to be &ldquo;half-open&rdquo; if one of the TCPs has closed or aborted the connection at its end without the knowledge of the other, or if the two ends of the connection have become desynchronized owing to a crash that resulted in loss of memory.<br>如果其中一个 TCP 在另一个不知道的情况下关闭或中止了连接，或者连接的两端由于崩溃导致内存丢失而变得不同步，则已建立的连接被称为 &ldquo;半开放&rdquo;。</p><p>Such connections will automatically become reset if an attempt is made to send data in either direction.<br>如果尝试向任一方向发送数据，这种连接将自动重置。</p><p>However, half-open connections are expected to be unusual, and the recovery procedure is mildly involved.<br>然而，半开放连接被认为是不正常的，恢复过程也涉及到一些问题。</p><p>If at site A the connection no longer exists, then an attempt by the user at site B to send any data on it will result in the site B TCP receiving a reset control message.<br>如果站点 A 的连接不再存在，那么站点 B 的用户试图在其上发送任何数据将导致站点 B 的 TCP 收到重置控制消息。</p><p>Such a message should indicate to the site B TCP that something is wrong, and it is expected to abort the connection.<br>这种消息表明 B 的 TCP 有问题，并希望它能中止连接。</p><p>Assume that two user processes A and B are communicating with one another when a crash occurs causing loss of memory to A&rsquo;s TCP.<br>假设两个用户进程 A 和 B 正在相互通信，当发生崩溃导致 A 的 TCP 丢失内存时。</p><p>Depending on the operating system supporting A&rsquo;s TCP, it is likely that some error recovery mechanism exists.<br>可能会存在一些错误恢复机制，这取决于 TCP A 所运行的操作系统。</p><p>When the TCP is up again, A is likely to start again from the beginning or from a recovery point.<br>当 TCP 再次启动时，A 可能会从头或从某个恢复点重新启动。</p><p>As a result, A will probably try to OPEN the connection again or try to SEND on the connection it believes open.<br>因此，A 可能会尝试再次打开连接或尝试在它认为已经打开的连接上发送。</p><p>In the latter case, it receives the error message &ldquo;connection not open&rdquo; from the local (A&rsquo;s) TCP.<br>在后面一种情况下，它会收到来自本地(A) TCP 的错误消息 &ldquo;Connection Not Open&rdquo;。</p><p>In an attempt to establish the connection, A&rsquo;s TCP will send a segment containing SYN.<br>在尝试建立连接时，A 的 TCP 将发送包含 SYN 的 TCP 段。</p><p>This scenario leads to the example shown in figure 12.<br>这种情况的示例如图 12 所示。</p><p>After TCP A crashes, the user attempts to re-open the connection.<br>在 TCP A 崩溃后，用户试图重新打开连接。</p><p>TCP B, in the meantime, thinks the connection is open.<br>在此期间，TCP B 认为连接是打开的。</p><pre tabindex=0><code>      TCP A                                           TCP B
  1.  (CRASH)                               (send 300,receive 100)
  2.  CLOSED                                           ESTABLISHED
  3.  SYN-SENT --&gt; &lt;SEQ=400&gt;&lt;CTL=SYN&gt;              --&gt; (??)
  4.  (!!)     &lt;-- &lt;SEQ=300&gt;&lt;ACK=100&gt;&lt;CTL=ACK&gt;     &lt;-- ESTABLISHED
  5.  SYN-SENT --&gt; &lt;SEQ=100&gt;&lt;CTL=RST&gt;              --&gt; (Abort!!)
  6.                                                   CLOSED
  7.  SYN-SENT --&gt; &lt;SEQ=400&gt;&lt;CTL=SYN&gt;              --&gt;
</code></pre><div class=text-center><p>Half-Open Connection Discovery<br>半开放连接发现</p><p>Figure 12.</p></div><p>When the SYN arrives at line 3, TCP B, being in a synchronized state, responds with an acknowledgment indicating what sequence it next expects to hear (ACK 100).<br>在第 3 行，当 SYN 到达时，处于同步状态的 TCP B 以确认的方式回应，表明它接下来希望收到的序列（ACK 100）。</p><p>TCP A sees that this segment does not acknowledge anything it sent and, being unsynchronized, sends a reset (RST) because it has detected a half-open connection.<br>TCP A 看到这个 TCP 段没有确认它所发送的任何东西，并且由于不同步，发送了一个重置（RST），因为它检测到一个半开放的连接。</p><p>TCP B aborts at line 5.<br>在第 5 行，TCP B 终止。</p><p>TCP A will continue to try to establish the connection; the problem is now reduced to the basic 3-way handshake of figure 9.<br>TCP A 会继续尝试建立连接；问题现在简化为图 9 中基础的三次握手。</p><p>An interesting alternative case occurs when TCP A crashes and TCP B tries to send data on what it thinks is a synchronized connection.<br>另一种有趣的情况是，当 TCP A 崩溃，而 TCP B 尝试在它认为是同步的连接上发送数据时。</p><p>This is illustrated in figure 13.<br>图 13 说明了这种情况。</p><p>In this case, the data arriving at TCP A from TCP B (line 2) is unacceptable because no such connection exists, so TCP A sends a RST.<br>在这种情况下，从 TCP B 到达 TCP A 的数据（第 2 行）是无效的，因为不存在这样的连接，所以 TCP A 发送了一个 RST。</p><p>The RST is acceptable so TCP B processes it and aborts the connection.<br>RST 是有效的，所以 TCP B 处理它并终止连接。</p><pre tabindex=0><code>      TCP A                                           TCP B
  1.  (CRASH)                                   (send 300,receive 100)
  2.  (??)    &lt;-- &lt;SEQ=300&gt;&lt;ACK=100&gt;&lt;DATA=10&gt;&lt;CTL=ACK&gt; &lt;-- ESTABLISHED
  3.          --&gt; &lt;SEQ=100&gt;&lt;CTL=RST&gt;                   --&gt; (ABORT!!)
</code></pre><div class=text-center><p>Active Side Causes Half-Open Connection Discovery<br>活跃端导致半开放连接的发现</p><p>Figure 13.</p></div><p>In figure 14, we find the two TCPs A and B with passive connections waiting for SYN.<br>在图 14 中，我们发现两个 TCPs A 和 B 是被动连接等待 SYN。</p><p>An old duplicate arriving at TCP B (line 2) stirs B into action.<br>一个以前重复的 SYN 到达 TCP B（第 2 行），导致 B 做出回应。</p><p>A SYN-ACK is returned (line 3) and causes TCP A to generate a RST (the ACK in line 3 is not acceptable).<br>一个 SYN-ACK 被返回（第 3 行），并导致 TCP A 产生一个 RST（第 3 行的 ACK 是无效的）。</p><p>TCP B accepts the reset and returns to its passive LISTEN state.<br>TCP B 接受重置，并返回到其被动的 LISTEN 状态。</p><pre tabindex=0><code>      TCP A                                         TCP B
  1.  LISTEN                                        LISTEN
  2.       ... &lt;SEQ=Z&gt;&lt;CTL=SYN&gt;                --&gt;  SYN-RECEIVED
  3.  (??) &lt;-- &lt;SEQ=X&gt;&lt;ACK=Z+1&gt;&lt;CTL=SYN,ACK&gt;   &lt;--  SYN-RECEIVED
  4.       --&gt; &lt;SEQ=Z+1&gt;&lt;CTL=RST&gt;              --&gt;  (return to LISTEN!)
  5.  LISTEN                                        LISTEN
</code></pre><div class=text-center><p>Old Duplicate SYN Initiates a Reset on two Passive Sockets<br>以前重复 SYN 在两个被动套接字上启动重置</p><p>Figure 14.</p></div><p>A variety of other cases are possible, all of which are accounted for by the following rules for RST generation and processing.<br>可能存在多种其他情况，所有这些情况都可以通过以下 RST 生成和处理规则解释。</p><p><strong>Reset Generation</strong><br><strong>重置生成</strong></p><p>As a general rule, reset (RST) should be sent whenever a segment arrives which apparently is not intended for the current or a future incarnation of the connection.<br>作为一般规则，当一个 TCP 段到达时，如果显然不是为当前或未来的连接准备的，就应该发送复位（RST）。</p><p>A reset should not be sent if it is not clear that this is the case.<br>如果不清楚是这种情况，就不应该发送重置段。</p><p>Thus, if any segment arrives for a nonexistent connection, a reset should be sent.<br>因此，如果有任何段到发送到一个不存在的连接时，就应该发送一个重置。</p><p>If a segment ACKs something which has never been sent on the current connection, then one of the following two cases applies.<br>如果一个 TCP 段 ACK（确认）了一些从未在当前连接上发送过的东西，那么分为以下两种情况。</p><p>1.If the connection is in any non-synchronized state (LISTEN, SYN-SENT, SYN-RECEIVED) or if the connection does not exist, a reset (RST) should be formed and sent for any segment that acknowledges something not yet sent.<br>1.如果连接处于任何非同步状态（LISTEN、SYN-SENT、SYN-RECEIVED），或者连接不存在时，对于任何尚未发送的确认段，应该生成重置（RST）并发送。</p><p>The RST should take its SEQ field from the ACK field of the offending segment (if the ACK control bit was set), and its ACK bit should be reset (zero), except to refuse a initial SYN.<br>RST 应该从违规段的 ACK 字段中获取其 SEQ 字段（如果 ACK 标志位被设置），并且其 ACK 位应该被重置（0），除非拒绝初始 SYN。</p><p>A reset is also sent if an incoming segment has a security level or compartment which does not exactly match the level and compartment requested for the connection.<br>如果一个接收段的安全级别或区段与连接要求的级别和区段不完全匹配，也会发送一个重置。</p><p>If the precedence of the incoming segment is less than the precedence level requested a reset is sent.<br>如果接收段的优先级低于要求的优先级，则发送重置段。</p><p>2.If the connection is in a synchronized state (ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, TIME-WAIT, CLOSE-WAIT, CLOSING), any unacceptable segment should elicit only an empty acknowledgment segment containing the current send-sequence number and an acknowledgment indicating the next sequence number expected to be received.<br>2.如果连接处于同步状态（ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、TIME-WAIT、CLOSE-WAIT、CLOSING），任何无效的 TCP 段应该只会触发一个包含当前发送序列号和一个表示预期将收到的下一个序列号的空确认段。</p><p><strong>Reset Processing</strong><br><strong>重置处理</strong></p><p>All reset (RST) segments are validated by checking their SEQ-fields.<br>所有的重置（RST）段都通过检查其 SEQ 字段来验证。</p><p>A reset is valid if its sequence number is in the window.<br>如果重置的序列号在窗口范围中，则重置有效。</p><p>In the case of a RST received in response to an initial SYN any sequence number is acceptable if the ACK field acknowledges the SYN.<br>在响应初始 SYN 而接收 RST 的情况下，如果 ACK 字段确认 SYN，则任何序列号都是有效的。</p><p>The receiver of a RST first validates it, then changes state.<br>RST 的接收者首先验证它，然后改变状态。</p><p>If the receiver was in the LISTEN state, it ignores it.<br>如果接收器处于 LISTEN 状态，就会忽略它。</p><p>If the receiver was in SYN-RECEIVED state and had previously been in the LISTEN state, then the receiver returns to the LISTEN state, otherwise the receiver aborts the connection and goes to the CLOSED state.<br>如果接收方处于 SYN-RECEIVED 状态，并且之前处于 LISTEN 状态，那么接收方返回到 LISTEN 状态，否则接收方中止连接，进入 CLOSED 状态。</p><p>If the receiver was in any other state, it aborts the connection and advises the user and goes to the CLOSED state.<br>如果接收方处于任何其它状态，它将中止连接并通知用户并进入 CLOSED 状态。</p><h3 id=关闭连接>关闭连接
<a class=anchor href=#%e5%85%b3%e9%97%ad%e8%bf%9e%e6%8e%a5>#</a></h3><p><strong>3.5. Closing a Connection</strong></p><p>CLOSE is an operation meaning &ldquo;I have no more data to send.&rdquo;<br>CLOSE 是一个操作，意思是 &ldquo;我没有更多的数据要发送&rdquo;。</p><p>The notion of closing a full-duplex connection is subject to ambiguous interpretation, of course, since it may not be obvious how to treat the receiving side of the connection.<br>当然，关闭全双工连接的概念会有模糊的解释，因为如何处理连接的接收方可能并不明显。</p><p>We have chosen to treat CLOSE in a simplex fashion.<br>我们选择以简单的方式来处理 CLOSE。</p><p>The user who CLOSEs may continue to RECEIVE until he is told that the other side has CLOSED also.<br>主动关闭的用户可以继续接收，直到他被告知另一方也关闭了。</p><p>Thus, a program could initiate several SENDs followed by a CLOSE, and then continue to RECEIVE until signaled that a RECEIVE failed because the other side has CLOSED.<br>因此，一个程序可以多次发送，然后关闭，再继续接收，直到有信号说接收失败，因为对方已经关闭。</p><p>We assume that the TCP will signal a user, even if no RECEIVEs are outstanding, that the other side has closed, so the user can terminate his side gracefully.<br>我们假设，即使没有未完成的接收，TCP 也会通知用户对方已经关闭，所以用户可以优雅地中止自己这端。</p><p>A TCP will reliably deliver all buffers SENT before the connection was CLOSED so a user who expects no data in return need only wait to hear the connection was CLOSED successfully to know that all his data was received at the destination TCP.<br>TCP 将在连接关闭前可靠地发送的所有缓冲区的数据，因此没有数据接收的用户只需等到连接被成功关闭，就能知道他的所有数据已经成功发送到目的地 TCP。</p><p>There are essentially three cases:<br>主要有三种情况：</p><p> 1) The user initiates by telling the TCP to CLOSE the connection<br> 1) 用户主动告诉 TCP 关闭连接</p><p> 2) The remote TCP initiates by sending a FIN control signal<br> 2) 远程 TCP 通过发送 FIN 控制标志开始关闭</p><p> 3) Both users CLOSE simultaneously<br> 3) 两个用户同时关闭</p><p>Case 1: Local user initiates the close<br>情况 1：本地用户发起关闭</p><p>In this case, a FIN segment can be constructed and placed on the outgoing segment queue.<br>在这种情况下，会生成一个 FIN 段，并将其加入到发送段队列中。</p><p>No further SENDs from the user will be accepted by the TCP, and it enters the FIN-WAIT-1 state.<br>TCP 将不再接受用户的发送，并进入 FIN-WAIT-1 状态。</p><p>RECEIVEs are allowed in this state.<br>在这种状态下，允许接收</p><p>All segments preceding and including FIN will be retransmitted until acknowledged.<br>在 FIN 之前和包括 FIN 在内的所有段超时将被重传，直到被确认。</p><p>When the other TCP has both acknowledged the FIN and sent a FIN of its own, the first TCP can ACK this FIN.<br>当另一个 TCP 既确认了 FIN 又发送了自己的 FIN 时，第一个 TCP 可以对这个 FIN 进行 ACK。</p><p>It should be noted that a TCP receiving a FIN will ACK but not send its own FIN until its user has CLOSED the connection also.<br>应该注意的是，收到 FIN 的 TCP 会进行 ACK，但不会发送自己的 FIN，直到其用户也关闭了连接。</p><p>Case 2: TCP receives a FIN from the network<br>情况 2：TCP 收到来自网络的 FIN</p><p>If an unsolicited FIN arrives from the network, the receiving TCP can ACK it and tell the user that the connection is closing.<br>如果来自网络的未经请求的 FIN 到达，接收的 TCP 可以确认该 FIN 并告诉用户连接正在关闭。</p><p>The user should respond with a CLOSE, upon which the TCP can send a FIN to the other TCP.<br>用户应该用 CLOSE 来回应，在此基础上，TCP 可以向其他 TCP 发送 FIN。</p><p>The TCP then waits until its own FIN is acknowledged whereupon it deletes the connection.<br>然后，TCP 等待，直到它自己的 FIN 被确认，然后它删除连接。</p><p>If an ACK is not forthcoming, after a timeout the connection is aborted and the user is told.<br>如果没有收到 ACK，在超时后，连接将被终止，并告诉用户。</p><p>Case 3: both users close simultaneously<br>情况 3：两个用户同时关闭</p><p>A simultaneous CLOSE by users at both ends of a connection causes FIN segments to be exchanged.<br>连接两端的用户同时关闭会交换 FIN 段。</p><p>When all segments preceding the FINs have been processed and acknowledged, each TCP can ACK the FIN it has received.<br>当 FIN 之前的所有段都被处理并确认后，每个 TCP 可以对它所收到的 FIN 进行 ACK。</p><p>Both will, upon receiving these ACKs, delete the connection.<br>两者都将在收到这些 ACK 后，删除连接。</p><pre tabindex=0><code>      TCP A                                                TCP B
  1.  ESTABLISHED                                          ESTABLISHED
  2.  (Close)
      FIN-WAIT-1  --&gt; &lt;SEQ=100&gt;&lt;CTL=FIN&gt;               --&gt; CLOSE-WAIT
  3.  FIN-WAIT-2  &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=ACK&gt;      &lt;-- CLOSE-WAIT
  4.                                                       (Close)
      TIME-WAIT   &lt;-- &lt;SEQ=301&gt;&lt;CTL=FIN&gt;               &lt;-- CLOSING
  5.  TIME-WAIT   --&gt; &lt;SEQ=100&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;      --&gt; CLOSED
  6.  (2 MSL)
      CLOSED
</code></pre><div class=text-center><p>Normal Close Sequence<br>正常关闭序列</p><p>Figure 15.</p></div><pre tabindex=0><code>      TCP A                                                TCP B
  1.  ESTABLISHED                                          ESTABLISHED
  2.  (Close)                                              (Close)
      FIN-WAIT-1  --&gt; &lt;SEQ=100&gt;&lt;CTL=FIN&gt;               ... FIN-WAIT-1
                  &lt;-- &lt;SEQ=300&gt;&lt;CTL=FIN&gt;               &lt;--
                  ... &lt;SEQ=100&gt;&lt;CTL=FIN&gt;               --&gt;
  3.  CLOSING     --&gt; &lt;SEQ=100&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;      ... CLOSING
                  &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=ACK&gt;      &lt;--
                  ... &lt;SEQ=100&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;      --&gt;
  4.  CLOSED                                               CLOSED
</code></pre><div class=text-center><p>Simultaneous Close Sequence<br>同时关闭序列</p><p>Figure 16.</p></div><h3 id=优先级和安全性-1>优先级和安全性
<a class=anchor href=#%e4%bc%98%e5%85%88%e7%ba%a7%e5%92%8c%e5%ae%89%e5%85%a8%e6%80%a7-1>#</a></h3><p><strong>3.6. Precedence and Security</strong></p><p>The intent is that connection be allowed only between ports operating with exactly the same security and compartment values and at the higher of the precedence level requested by the two parts.<br>目的是只允许在以完全相同的安全和区段值运行的端口之间进行连接，并且使用两端要求较高的优先级。</p><p>The precedence levels are:<br>优先级有：</p><pre tabindex=0><code>    flash override - 111
    flash          - 110
    immediate      - 10X
    priority       - 01X
    routine        - 00X
</code></pre><p>The security levels are:
安全等级有：</p><pre tabindex=0><code>    top secret    - 11
    secret        - 10
    confidential  - 01
    unclassified  - 00
</code></pre><p>The compartments are assigned by the Defense Communications Agency.<br>隔间是由国防通信局分配的。</p><p>The defaults are precedence: routine, security: unclassified, compartment: zero.<br>默认优先级：routine，安全：unclassified，隔间：zero。</p><p>A host which does not implement precedence or security feature should clear these fields to zero for segments it sends.<br>没有实现优先权或安全功能的主机应将其发送的 TCP 段中这些字段清除为零。</p><p>A connection attempt with mismatched security/compartment values or a lower precedence value should be rejected by sending a reset.<br>通过发送重置段来拒绝安全/区段值不匹配或优先级较低的连接尝试。</p><p>Note that TCP modules which operate only at the default value of precedence will still have to check the precedence of incoming segments and possibly raise the precedence level they use on the connection.<br>请注意，只在默认优先级值下运行的 TCP 模块仍然需要检查接收段的优先级，并可能提高它们在连接上使用的优先级。</p><h3 id=数据通信-1>数据通信
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e9%80%9a%e4%bf%a1-1>#</a></h3><p><strong>3.7. Data Communication</strong></p><p>Once the connection is established data is communicated by the exchange of segments.<br>一旦建立了连接，就通过交换 TCP 段来传递数据。</p><p>Because segments may be lost due to errors (checksum test failure), or network congestion, TCP uses retransmission (after a timeout) to ensure delivery of every segment.<br>由于 TCP 段可能因错误（校验和测试失败）或网络拥堵而丢失，TCP 使用重传（超时后）来确保每个段的交付。</p><p>Duplicate segments may arrive due to network or TCP retransmission.<br>由于网络或 TCP 重传，可能会出现重复的 TCP 段。</p><p>As discussed in the section on sequence numbers the TCP performs certain tests on the sequence and acknowledgment numbers in the segments to verify their acceptability.<br>正如在序列号一节中所讨论的，TCP 对段中的序列号和确认号进行某些测试，以验证其是否有效。</p><p>The sender of data keeps track of the next sequence number to use in the variable SND.NXT.<br>数据发送方在变量 SND.NXT 中记录下一个要使用的序列号。</p><p>The receiver of data keeps track of the next sequence number to expect in the variable RCV.NXT.<br>数据接收方在变量 RCV.NXT 中保存下一个期望的序列号。</p><p>The sender of data keeps track of the oldest unacknowledged sequence number in the variable SND.UNA.<br>数据发送方在变量 SND.UNA 中跟踪最久的未确认的序列号。</p><p>If the data flow is momentarily idle and all data sent has been acknowledged then the three variables will be equal.<br>如果数据流暂时处于空闲状态，并且所有发送的数据都被确认，那么这三个变量将是相等的。</p><p>When the sender creates a segment and transmits it the sender advances SND.NXT.<br>当发送方创建一个 TCP 段并发送时，发送方会推进 SND.NXT。</p><p>When the receiver accepts a segment it advances RCV.NXT and sends an acknowledgment.<br>当接收方接收一个 TCP 段时，它推进 RCV.NXT 并发送一个确认。</p><p>When the data sender receives an acknowledgment it advances SND.UNA.<br>当数据发送方收到确认时，它会推进 SND.UNA。</p><p>The extent to which the values of these variables differ is a measure of the delay in the communication.<br>这些变量值的不同程度是衡量通信延迟的一个标准。</p><p>Normally the amount by which the variables are advanced is the length of the data in the segment.<br>通常情况下，变量推进的数量是 TCP 段中数据的长度。</p><p>However, when letters are used there are special provisions for coordination the sequence numbers, the letter boundaries, and the receive buffer boundaries.<br>然而，当使用信件时，有特殊的规定来协调序列号、信件边界和接收缓冲区的边界。</p><p><strong>End of Letter Sequence Number Adjustments</strong><br><strong>信件结尾序列号调整</strong></p><p>There is provision in TCP for the receiver of data to optionally communicate to the sender of data on a connection at the time of the connection synchronization the receiver&rsquo;s buffer size.<br>在 TCP 中规定，数据的接收方在连接同步时可以选择向数据发送方传达接收方的缓冲区大小。</p><p>If this is done the receiver must use this fixed size of buffers for the lifetime of the connection.<br>如果这样的话，接收方必须在连接的有效期内一直使用这个固定大小的缓冲区。</p><p>If a buffer size is communicated then there is a coordination between receive buffers, letters, and sequence numbers.<br>如果传递了缓冲区大小，那么接收缓冲区、字母和序列号之间就有了协调。</p><p>Each time a buffer is completed either due to being filled or due to an end of letter, the sequence number is incremented through the end of that buffer.<br>每当一个缓冲区由于被填满或信件结束而完成时，序列号就会递增到该缓冲区的末端。</p><p>That is, whenever an EOL is transmitted, the sender advances its send sequence number, SND.NXT, by an amount sufficient to consume all the unused space in the receiver&rsquo;s buffer.<br>也就是说，每当传输 EOL 时，发送方将其发送序列号 SND.NXT 提前，其数量足以消耗接收方缓冲区的所有未使用空间。</p><p>The amount of space consumed in this fashion is subtracted from the send window just as is the space consumed by actual data.<br>以这种方式消耗的空间量将从发送窗口中减去，就像实际数据消耗的空间一样。</p><p>And, whenever an EOL is received, the receiver advances its receive sequence number, RCV.NXT, by an amount sufficient to consume all the unused space in the receiver&rsquo;s buffer.<br>而且，每当接收到 EOL 时，接收方就将其接收序列号 RCV.NXT 提前，其数量足以消耗接收方缓冲区中所有未使用的空间。</p><p>The amount of space consumed in this fashion is subtracted from the receive window just as is the space consumed by actual data.<br>以这种方式消耗的空间量从接收窗口中减去，就像实际数据所消耗的空间一样。</p><pre tabindex=0><code>    older sequence numbers                        newer sequence numbers

            |           Buffer 1            |   Buffer 2
            |                               |
        ----+-------------------------------+-----------------
            XXXXXXXXXXXXXXXXXXXXX+++++++++++
            |                    |          |
            |&lt;-----SEG.LEN------&gt;|          |
            |                    |          |
            |                    |          |
         SEG.SEQ                 A          B

                    XXX - data octets from segment
                    +++ - phantom data

                      &lt;----- sequence space -----&gt;
</code></pre><div class=text-center><p>End of Letter Adjustment<br>信件结尾调整</p><p>Figure 17.</p></div><p>In the case illustrated above, if the segment does not carry an EOL flag, the next value of SND.NXT or RCV.NXT will be A.
在上述情况下，如果 TCP 段没有携带 EOL 标志，则 SND.NXT 或 RCV.NXT 的下一个值将是 A。</p><p>If it does carry an EOL flag, the next value will be B.<br>如果它携带 EOL 标志，则下一个值将是 B。</p><p>The exchange of buffer size and sequencing information is done in units of octets.<br>缓冲区大小和排序信息的交换以字节为单位进行的。</p><p>If no buffer size is stated, then the buffer size is assumed to be 1 octet.<br>如果没有说明缓冲区大小，那么就假定缓冲区大小为 1 个字节。</p><p>The receiver tells the sender the size of the buffer in a SYN segment that contains the 16 bit buffer size data in an option field in the TCP header.<br>接收方在 SYN 段中告诉发送方缓冲区的大小，该段在 TCP 头的一个选项字段中包含 16 位的缓冲区大小数据。</p><p>Each EOL advances the sequence number (SN) to the next buffer boundary<br>每个 EOL 将序列号（SN）推进到下一个缓冲区边界。</p><p> While LBB &lt; SEG.SEQ+SEG.LEN<br> Do LBB &lt;- LBB + BS End<br> SN &lt;- LBB</p><p>where LBB is the Last Buffer Beginning, and BS is the buffer size.<br>其中 LBB 是最后一个缓冲区的起始点，BS 是缓冲区的大小。</p><p>The CLOSE user call implies an end of letter, as does the FIN control flag in an incoming segment.<br>CLOSE 用户调用意味着信件的结束，接收段的 FIN 控制标志也是如此。</p><p><strong>The Communication of Urgent Information</strong><br><strong>紧急信息的传递</strong></p><p>The objective of the TCP urgent mechanism is to allow the sending user to stimulate the receiving user to accept some urgent data and to permit the receiving TCP to indicate to the receiving user when all the currently known urgent data has been received by the user.<br>TCP 紧急机制的目的是允许发送者促使接收者接收一些紧急数据，并允许接收 TCP 告知接收者，用户何时已经接收到所有当前已知的紧急数据。</p><p>This mechanism permits a point in the data stream to be designated as the end of &ldquo;urgent&rdquo; information.<br>这一机制允许将数据流中的某一点指定为 &ldquo;紧急&rdquo; 信息的终点。</p><p>Whenever this point is in advance of the receive sequence number (RCV.NXT) at the receiving TCP, that TCP should tell the user to go into &ldquo;urgent mode&rdquo;; when the receive sequence number catches up to the urgent pointer, the TCP should tell user to go into &ldquo;normal mode&rdquo;.<br>只要这个点在接收 TCP 的接收序列号（RCV.NXT）之前，该 TCP 就应该告诉用户进入 &ldquo;紧急模式&rdquo;；当接收序列号赶上紧急指针时，该 TCP 应该告诉用户进入 &ldquo;正常模式&rdquo;。</p><p>If the urgent pointer is updated while the user is in &ldquo;read fast&rdquo; mode, the update will be invisible to the user.<br>如果紧急指针在用户处于 &ldquo;快速读取&rdquo; 模式时被更新，用户将看不到更新。</p><p>The method employs a urgent field which is carried in all segments transmitted.<br>该方法使用了一个紧急字段，它在所有传输的段中都会携带。</p><p>The URG control flag indicates that the urgent field is meaningful and should be added to the segment sequence number to yield the urgent pointer.<br>URG 控制标志表示紧急字段是有效的，应该加到段序列号中，以产生紧急指针。</p><p>The absence of this flag indicates that the urgent pointer has not changed.<br>没有这个标志表示紧急指针没有变化。</p><p>To send an urgent indication the user must also send at least one data octet.<br>要发送一个紧急指令，用户也必须发送至少一个字节的数据。</p><p>If the sending user also indicates end of letter, timely delivery of the urgent information to the destination process is enhanced.<br>如果发送用户也指示信件结束，则紧急信息会被更加及时地传递到目的地的进程。</p><p><strong>Managing the Window</strong><br><strong>管理窗口</strong></p><p>The window sent in each segment indicates the range of sequence number the sender of the window (the data receiver) is currently prepared to accept.<br>每个 TCP 段中发送的窗口表示窗口的发送方（数据接收方）目前准备接受的序列号范围。</p><p>There is an assumption that this is related to the currently available data buffer space available for this connection.<br>有一种假设是，这与当前可用于该连接的数据缓冲区空间有关。</p><p>The window information is a guideline to be aimed at.<br>窗口信息是一个指南，要以它为准。</p><p>Indicating a large window encourages transmissions.<br>发送较大的窗口有利于传输。</p><p>If more data arrives than can be accepted, it will be discarded.<br>如果接收的数据超过了可接受的范围，那么将被丢弃。</p><p>This will result in excessive retransmissions, adding unnecessarily to the load on the network and the TCPs.<br>这将导致过度的重传，增加不必要地网络和 TCP 的负载。</p><p>Indicating a small window may restrict the transmission of data to the point of introducing a round trip delay between each new segment transmitted.<br>发送较小的窗口可能会限制数据的传输，以至于在每个新传输段之间引入一个往返延迟。</p><p>The mechanisms provided allow a TCP to advertise a large window and to subsequently advertise a much smaller window without having accepted that much data.<br>这种机制允许 TCP 发送一个大窗口，并随后在不需要接收那么多数据时发送一个小得多的窗口。</p><p>This, so called &ldquo;shrinking the window,&rdquo; is strongly discouraged.<br>这就是所谓的 &ldquo;缩减窗口&rdquo;，是被强烈反对的。</p><p>The robustness principle dictates that TCPs will not shrink the window themselves, but will be prepared for such behavior on the part of other TCPs.<br>稳健性原则决定了 TCP 不会自己缩减窗口，但会对其他 TCP 的这种行为做好准备。</p><p>The sending TCP must be prepared to accept and send at least one octet of new data even if the send window is zero.<br>发送 TCP 必须准备好接收和发送至少一个字节的新数据，即使发送窗口为 0。</p><p>The sending TCP should regularly retransmit to the receiving TCP even when the window is zero.<br>即使窗口为 0，发送的 TCP 也应定期向接收的 TCP 重传。</p><p>Two minutes is recommended for the retransmission interval when the window is zero.<br>当窗口为 0 时，建议重传间隔为 2 分钟。</p><p>This retransmission is essential to guarantee that when either TCP has a zero window the re-opening of the window will be reliably reported to the other.<br>这种重传对于保证任一个窗口为 0 的 TCP，当窗口的重新打开将可靠地报告给另一端是非常重要的。</p><p>The sending TCP packages the data to be transmitted into segments which fit the current window, and may repackage segments on the retransmission queue.<br>发送 TCP 把要传输的数据打包成适合当前窗口的段，并可能在重传队列中重新打包段。</p><p>Such repackaging is not required, but may be helpful.<br>这种重新打包不是必须的，但可能会有用。</p><p>Users must keep reading connections they close for sending until the TCP says no more data.<br>用户必须继续读取他们关闭的连接，直到 TCP 说没有数据了。</p><p>In a connection with a one-way data flow, the window information will be carried in acknowledgment segments that all have the same sequence number so there will be no way to reorder them if they arrive out of order.<br>在一个单向数据流的连接中，窗口信息将携带在确认段中，这些确认段都有相同的序列号，所以如果它们不按顺序到达，就没有办法重新排序。</p><p>This is not a serious problem, but it will allow the window information to be on occasion temporarily based on old reports from the data receiver.<br>这不是一个严重的问题，但它会让窗口信息偶尔暂时基于数据接收者之前的信息。</p><h3 id=接口-2>接口
<a class=anchor href=#%e6%8e%a5%e5%8f%a3-2>#</a></h3><p><strong>3.8. Interfaces</strong></p><p>There are of course two interfaces of concern: the user/TCP interface and the TCP/IP interface.<br>有两个值得关注的接口：用户/TCP 接口和 TCP/IP 接口。</p><p>We have a fairly elaborate model of the user/TCP interface, but only a sketch of the interface to the lower level protocol module.<br>我们有一个相当详细的用户/TCP 接口模型，但只有一个简要的与低层协议模块交互接口。</p><p><strong>User/TCP Interface</strong><br><strong>用户/TCP 接口</strong></p><p>The functional description of user commands to the TCP is, at best, fictional, since every operating system will have different facilities.<br>对 TCP 的用户命令的功能描述几乎是抽象的，因为每个操作系统会有不同的特点。</p><p>Consequently, we must warn readers that different TCP implementations may have different user interfaces.<br>因此，我们必须提示读者，不同的 TCP 实现可能有不同的用户接口。</p><p>However, all TCPs must provide a certain minimum set of services to guarantee that all TCP implementations can support the same protocol hierarchy.<br>然而，所有的 TCP 都必须提供一个最低限度的服务，以保证所有的 TCP 实现都能支持相同的协议阶层。</p><p>This section specifies the functional interfaces required of all TCP implementations.<br>本节规定了所有 TCP 实现所需的功能接口。</p><p>TCP User Commands<br>TCP 用户命令</p><p>The following sections functionally characterize a USER/TCP interface.<br>下面的章节从功能上描述了 USER/TCP 接口的特性。</p><p>The notation used is similar to most procedure or function calls in high level languages, but this usage is not meant to rule out trap type service calls (e.g., SVCs, UUOs, EMTs).<br>使用的符号类似于高级语言中的大多数过程或函数调用，但这种用法并不意味着排除限定类型的服务调用（例如，SVCs、UUO、EMTs）。</p><p>The user commands described below specify the basic functions the TCP must perform to support interprocess communication.<br>下面描述的用户命令规定了 TCP 必须执行的基本功能，以支持进程间通信。</p><p>Individual implementations should define their own exact format, and may provide combinations or subsets of the basic functions in single calls.<br>不同的实现应该定义自己的具体格式，并且可以在单个调用中提供基本功能的组合或子集。</p><p>In particular, some implementations may wish to automatically OPEN a connection on the first SEND or RECEIVE issued by the user for a given connection.<br>特别是，某些实现可能希望在用户为给定连接发出的第一个 SEND 或 RECEIVE 时自动打开连接。</p><p>In providing interprocess communication facilities, the TCP must not only accept commands, but must also return information to the processes it serves.<br>在提供进程间通信功能时，TCP 不仅需要接受命令，还必须将信息返回给它所服务的进程。</p><p>The latter consists of:<br>后者包括：</p><p>(a) general information about a connection (e.g., interrupts, remote close, binding of unspecified foreign socket).<br>(a) 关于一个连接的基础信息（例如，中断、远程关闭、未指定的外部套接字的绑定）。</p><p>(b) replies to specific user commands indicating success or various types of failure.<br>(b) 对特定用户命令的回复，表明成功或各种类型的失败。</p><p><strong>Open</strong><br><strong>打开</strong></p><p>Format: OPEN (local port, foreign socket, active/passive [, buffer size] [, timeout] [, precedence] [, security/compartment]) -> local connection name<br>格式：OPEN（本地端口，外部套接字，主动/被动 [，缓冲区大小] [，超时] [，优先级] [，安全/区段]）-> 本地连接名称</p><p>We assume that the local TCP is aware of the identity of the processes it serves and will check the authority of the process to use the connection specified.<br>我们假设本地 TCP 知道它所服务的进程的身份，并将检查进程的权限以使用指定的连接。</p><p>Depending upon the implementation of the TCP, the local network and TCP identifiers for the source address will either be supplied by the TCP or by the processes that serve it (e.g., the program which interfaces the TCP network).<br>根据 TCP 的实现，本地网络和源地址的 TCP 标识符将由 TCP 或服务于它的进程（例如，连接 TCP 网络的程序）提供。</p><p>These considerations are the result of concern about security, to the extent that no TCP be able to masquerade as another one, and so on.<br>这些考虑是出于对安全的关注，以至于没有 TCP 能够伪装成另一个 TCP，等等。</p><p>Similarly, no process can masquerade as another without the collusion of the TCP.<br>同样，如果 TCP 没有串通，任何进程都无法伪装成另一个进程。</p><p>If the active/passive flag is set to passive, then this is a call to LISTEN for an incoming connection.<br>如果主动/被动标志被设置为被动，那么这就是一个调用 LISTEN 以获得一个外部的连接。</p><p>A passive open may have either a fully specified foreign socket to wait for a particular connection or an unspecified foreign socket to wait for any call.<br>一个被动打开可以完全指定一个外部套接字来等待一个特定的连接，也可以有一个不指定的外部套接字来等待任何连接。</p><p>A fully specified passive call can be made active by the subsequent execution of a SEND.<br>完全指定的被动调用可以通过随后执行 SEND 来激活。</p><p>A full-duplex transmission control block (TCB) is created and partially filled in with data from the OPEN command parameters.<br>创建一个全双工传输控制块 (TCB)，并用来自 OPEN 命令参数的数据部分填充。</p><p>On an active OPEN command, the TCP will begin the procedure to synchronize (i.e., establish) the connection at once.<br>在主动 OPEN 命令上，TCP 将立即开始同步（即建立）连接的过程。</p><p>The buffer size, if present, indicates that the caller will always receive data from the connection in that size of buffers.<br>如果存在缓冲区大小，则表明调用者将始终以该大小的缓冲区从连接中接收数据。</p><p>This buffer size is a measure of the buffer between the user and the local TCP. The buffer size between the two TCPs may be different.<br>这个缓冲区大小是对用户和本地 TCP 之间的缓冲区的衡量。两个 TCP 之间的缓冲区大小可能不同。</p><p>The timeout, if present, permits the caller to set up a timeout for all buffers transmitted on the connection.<br>如果存在超时，允许调用者为连接上传输的所有缓冲区设置一个超时。</p><p>If a buffer is not successfully delivered to the destination within the timeout period, the TCP will abort the connection.<br>如果在超时时间内没有成功将缓冲区送到目的地，TCP 将终止连接。</p><p>The present global default is 30 seconds.<br>目前全局默认为 30 秒。</p><p>The buffer retransmission rate may vary; most likely, it will be related to the measured time for responses from the remote TCP.<br>缓冲区重传率可能会有所不同； 最有可能的是，它与远程 TCP 响应的测量时间有关。</p><p>The TCP or some component of the operating system will verify the users authority to open a connection with the specified precedence or security/compartment.<br>TCP 或操作系统的某些组件会验证用户是否有权以指定的优先级或安全/区段打开连接。</p><p>The absence of precedence or security/compartment specification in the OPEN call indicates the default values should be used.<br>在 OPEN 调用中没有优先级或安全/区段规范，表明应该使用默认值。</p><p>TCP will accept incoming requests as matching only if the security/compartment information is exactly the same and only if the precedence is equal to or higher than the precedence requested in the OPEN call.<br>只有当安全/区段信息完全相同且优先级等于或高于 OPEN 调用中请求的优先级时，TCP 才会匹配收到请求。</p><p>The precedence for the connection is the higher of the values requested in the OPEN call and received from the incoming request, and fixed at that value for the life of the connection.<br>连接的优先级是 OPEN 调用中请求的值和从收到请求中收到的值中较高的一个，并在连接的有效期内固定为该值。</p><p>Depending on the TCP implementation, either a local connection name will be returned to the user by the TCP, or the user will specify this local connection name (in which case another parameter is needed in the call).<br>根据 TCP 的实现，要么 TCP 将向用户返回一个本地连接名，要么用户将指定这个本地连接名（在这种情况下，调用中需要另一个参数）。</p><p>The local connection name can then be used as a short hand term for the connection defined by the &lt;local socket, foreign socket> pair.<br>然后，本地连接名称可以用作 &lt;local socket, foreign socket> 对定义的连接的简称。</p><p><strong>Send</strong><br><strong>发送</strong></p><p>Format: SEND(local connection name, buffer address, byte count, EOL flag, URGENT flag [, timeout])<br>格式：SEND(本地连接名, 缓冲区地址, 字节数, EOL 标志, 紧急标志 [, 超时] )</p><p>This call causes the data contained in the indicated user buffer to be sent on the indicated connection.<br>这个调用将指定的用户缓冲区中包含的数据发送到指定的连接上。</p><p>If the connection has not been opened, the SEND is considered an error.<br>如果连接没有打开，SEND 会出现错误。</p><p>Some implementations may allow users to SEND first; in which case, an automatic OPEN would be done.<br>有些实现可能允许用户先 SEND，在这种情况下，连接会自动打开。</p><p>If the calling process is not authorized to use this connection, an error is returned.<br>如果调用进程没有被授权使用这个连接，将返回错误。</p><p>If the EOL flag is set, the data is the End Of a Letter, and the EOL bit will be set in the last TCP segment created from the buffer.<br>如果设置了 EOL 标志，则数据为信件结尾，EOL 位将设置在从缓冲区创建的最后一个 TCP 段中。</p><p>If the EOL flag is not set, subsequent SENDs will appear to be part of the same letter.<br>如果没有设置 EOL 标志，随后的 SEND 将显示为同一封信件的一部分。</p><p>If the URGENT flag is set, segments resulting from this call will have the urgent pointer set to indicate that some of the data associated with this call is urgent.<br>如果 URGENT 标志被设置，由该调用产生的段将设置紧急指针，以表明与该调用相关的一些数据是紧急的。</p><p>This facility, for example, can be used to simulate &ldquo;break&rdquo; signals from terminals or error or completion codes from I/O devices.<br>例如，这一特性可用于模拟来自终端的 &ldquo;中断&rdquo; 信号或来自 I/O 设备的错误或完成代码。</p><p>The semantics of this signal to the receiving process are unspecified.<br>这个信号对接收进程的语义没有明确说明。</p><p>The receiving TCP will signal the urgent condition to the receiving process as long as the urgent pointer indicates that data preceding the urgent pointer has not been consumed by the receiving process.<br>只要紧急指针表明紧急指针之前的数据尚未被接收进程消耗，接收 TCP 就会向接收进程发出紧急情况信号。</p><p>The purpose of urgent is to stimulate the receiver to accept some urgent data and to indicate to the receiver when all the currently known urgent data has been received.<br>紧急特性的目的是促使接收方接收一些紧急数据，并向接收方指示何时已经收到当前所有已知的紧急数据。</p><p>The number of times the sending user&rsquo;s TCP signals urgent will not necessarily be equal to the number of times the receiving user will be notified of the presence of urgent data.<br>发送用户的 TCP 发出紧急信号的次数不一定等于接收用户被通知有紧急数据的次数。</p><p>If no foreign socket was specified in the OPEN, but the connection is established (e.g., because a LISTENing connection has become specific due to a foreign segment arriving for the local socket), then the designated buffer is sent to the implied foreign socket.<br>如果在 OPEN 中没有指定外部套接字，但连接已经建立（例如，由于外部段到达本地套接字，监听的连接已经成为特定的连接），那么指定的缓冲区被发送到隐含的外部套接字。</p><p>In general, users who make use of OPEN with an unspecified foreign socket can make use of SEND without ever explicitly knowing the foreign socket address.<br>通常，对未指定的外部套接字使用 OPEN 的用户可以使用 SEND，而无需明确知道外部套接字地址。</p><p>However, if a SEND is attempted before the foreign socket becomes specified, an error will be returned.<br>然而，如果在外部套接字被指定之前尝试发送，将返回错误。</p><p>Users can use the STATUS call to determine the status of the connection.<br>用户可以使用 STATUS 调用来确定连接的状态。</p><p>In some implementations the TCP may notify the user when an unspecified socket is bound.<br>在一些实现中，当绑定了未指定的套接字时，TCP 可以通知用户。</p><p>If a timeout is specified, then the current timeout for this connection is changed to the new one.<br>如果指定了超时，那么这个连接的当前超时将被改变为新的超时。</p><p>In the simplest implementation, SEND would not return control to the sending process until either the transmission was complete or the timeout had been exceeded. However, this simple method is both subject to deadlocks (for example, both sides of the connection might try to do SENDs before doing any RECEIVEs) and offers poor performance, so it is not recommended.<br>在最简单的实现中，在传输完成或超时之前，Send 不会将控制权归还给发送进程。然而，这种简单的方法会受到死锁的影响(例如，连接的两端可能会在进行任何接收之前尝试进行发送)，并且性能较差，因此不建议使用这种方法。</p><p>A more sophisticated implementation would return immediately to allow the process to run concurrently with network I/O, and, furthermore, to allow multiple SENDs to be in progress.<br>一个更复杂的实现是立即返回，以允许进程与网络 I/O 同时运行，而且，允许多个 SENDs 同时进行。</p><p>Multiple SENDs are served in first come, first served order, so the TCP will queue those it cannot service immediately.<br>多个 SEND 以先到先得的顺序提供服务，因此 TCP 将对无法立即提供服务的 SEND 进行排队。</p><p>We have implicitly assumed an asynchronous user interface in which a SEND later elicits some kind of SIGNAL or pseudo-interrupt from the serving TCP.<br>我们隐式地假设了一个异步的用户接口，在这个接口中，一个 SEND 后来发出了某种 SIGNAL 或来自服务 TCP 的伪中断。</p><p>An alternative is to return a response immediately.<br>另一种方法是立即返回响应。</p><p>For instance, SENDs might return immediate local acknowledgment, even if the segment sent had not been acknowledged by the distant TCP.<br>例如，SENDs 可能会立即返回本地确认，即使发送的段没有被远端 TCP 确认。</p><p>We could optimistically assume eventual success.<br>我们可以乐观地认为最终会成功。</p><p>If we are wrong, the connection will close anyway due to the timeout.<br>如果我们错了，连接将由于超时而关闭。</p><p>In implementations of this kind (synchronous), there will still be some asynchronous signals, but these will deal with the connection itself, and not with specific segments or letters.<br>在这种（同步）的实现中，仍然会有一些异步信号，但这些信号将处理连接本身，而不是处理具体的段或信件。</p><p>NOTA BENE: In order for the process to distinguish among error or success indications for different SENDs, it might be appropriate for the buffer address to be returned along with the coded response to the SEND request.<br>注意：为了让进程区分不同 SEND 的错误或成功指示，缓冲区地址与对 SEND 请求的编码响应一起返回会更合适。</p><p>TCP-to-user signals are discussed below, indicating the information which should be returned to the calling process.<br>下面会讨论 TCP 到用户的信号，指出应该返回给调用进程的信息。</p><p><strong>Receive</strong><br><strong>接收</strong></p><p>Format: RECEIVE (local connection name, buffer address, byte count)<br>格式：RECEIVE（本地连接名称，缓冲区地址，字节数）</p><p>This command allocates a receiving buffer associated with the specified connection.<br>该命令分配一个与指定连接相关的接收缓冲区。</p><p>If no OPEN precedes this command or the calling process is not authorized to use this connection, an error is returned.<br>如果该命令之前没有 OPEN，或者调用进程没有被授权使用该连接，则返回错误。</p><p>In the simplest implementation, control would not return to the calling program until either the buffer was filled, or some error occurred, but this scheme is highly subject to deadlocks.<br>在最简单的实现中，在缓冲区被填满或发生错误之前，控制不会返回给调用程序，但这种方案很容易发生死锁。</p><p>A more sophisticated implementation would permit several RECEIVEs to be outstanding at once.<br>更复杂的实现将允许几个 RECEIVE 同时出现。</p><p>These would be filled as, segments arrive.<br>它们将在收到段时被填充。</p><p>This strategy permits increased throughput at the cost of a more elaborate scheme (possibly asynchronous) to notify the calling program that a letter has been received or a buffer filled.<br>这种策略可以增加吞吐量，但代价是需要一个更复杂的方案（可能是异步的）来通知调用程序已经收到了一封信件或填满了一个缓冲区。</p><p>If insufficient buffer space is given to reassemble a complete letter, the EOL flag will not be set in the response to the RECEIVE.<br>如果没有足够的缓冲区空间来重组一个完整的信件，则不会在对 RECEIVE 的响应中设置 EOL 标志。</p><p>The buffer will be filled with as much data as it can hold.
缓冲区将填充尽可能多的数据。</p><p>The last buffer required to hold the letter is returned with EOL signaled.<br>当返回保存信件所需的最后一个缓冲区时发出 EOL 信号。</p><p>The remaining parts of a partly delivered letter will be placed in buffers as they are made available via successive RECEIVEs.<br>部分送达信件的剩余部分将被放置在缓冲区，因为它们可以通过连续的 RECEIVEs 获得。</p><p>If a number of RECEIVEs are outstanding, they may be filled with parts of a single long letter or with at most one letter each.<br>如果有许多未完成的 RECEIVEs，它们可能会填满单个长信件的部分，或者每个 RECEIVE 最多填入一个信件。</p><p>The return codes associated with each RECEIVE will indicate what is contained in the buffer.<br>与每个 RECEIVE 关联的返回码将指示缓冲区中包含的内容。</p><p>If a buffer size was given in the OPEN call, then all buffers presented in RECEIVE calls must be of exactly that size, or an error indication will be returned.<br>如果在 OPEN 调用中给出了缓冲区的大小，那么在 RECEIVE 调用中呈现的所有缓冲区必须正好是这个大小，否则将返回错误。</p><p>The URGENT flag will be set only if the receiving user has previously been informed via a TCP-to-user signal, that urgent data is waiting.<br>只有当接收用户先前通过 TCP-to-user 信号被告知有紧急数据在等待时，才会设置 URGENT 标志。</p><p>The receiving user should thus be in &ldquo;read-fast&rdquo; mode.<br>因此，接收用户应处于 &ldquo;快速读取&rdquo; 模式。</p><p>If the URGENT flag is on, additional urgent data remains.<br>如果紧急标志打开，则保留额外的紧急数据。</p><p>If the URGENT flag is off, this call to RECEIVE has returned all the urgent data, and the user may now leave &ldquo;read-fast&rdquo; mode.<br>如果紧急标志关闭，则对 RECEIVE 的调用已返回所有紧急数据，用户现在可以离开 &ldquo;快速读取&rdquo; 模式。</p><p>To distinguish among several outstanding RECEIVEs and to take care of the case that a letter is smaller than the buffer supplied, the return code is accompanied by both a buffer pointer and a byte count indicating the actual length of the letter received.<br>为了区分几个未完成的 RECEIVE，并考虑到一个信件小于所提供的缓冲区的情况，返回代码伴随着一个缓冲区指针和一个字节数，表明收到的信件的实际长度。</p><p>Alternative implementations of RECEIVE might have the TCP allocate buffer storage, or the TCP might share a ring buffer with the user.<br>RECEIVE 的其他实现可能会让 TCP 分配缓冲区存储，或者 TCP 与用户共享一个环形缓冲区。</p><p>Variations of this kind will produce obvious variation in user interface to the TCP.<br>这种变化将在 TCP 的用户接口中产生明显的变化。</p><p>Close<br>关闭</p><p>Format: CLOSE(local connection name)<br>格式：CLOSE(本地连接名)</p><p>This command causes the connection specified to be closed.<br>该命令关闭指定的连接。</p><p>If the connection is not open or the calling process is not authorized to use this connection, an error is returned.<br>如果连接没有打开，或者调用进程没有被授权使用这个连接，将返回错误。</p><p>Closing connections is intended to be a graceful operation in the sense that outstanding SENDs will be transmitted (and retransmitted), as flow control permits, until all have been serviced.<br>关闭连接是一个优雅的操作，即在流量控制允许的情况下，未完成的 SEND 将被传输（和重传），直到所有的服务都完成。</p><p>Thus, it should be acceptable to make several SEND calls, followed by a CLOSE, and expect all the data to be sent to the destination.<br>因此，应该可以调用几次 SEND ，然后再调用 CLOSE，并期望所有的数据都被发送到目的地。</p><p>It should also be clear that users should continue to RECEIVE on CLOSING connections, since the other side may be trying to transmit the last of its data.<br>还应该明确的是，用户可以在关闭中的连接上继续接收，因为对方可能正试图传输其最后的数据。</p><p>Thus, CLOSE means &ldquo;I have no more to send&rdquo; but does not mean &ldquo;I will not receive any more.&rdquo;<br>因此，CLOSE 的意思是 &ldquo;我没有更多的东西可以发送&rdquo;，但并不意味着 &ldquo;我不会再收到任何东西&rdquo;。</p><p>It may happen (if the user level protocol is not well thought out) that the closing side is unable to get rid of all its data before timing out.<br>可能会发生这样的情况 (如果用户级协议考虑不周)，关闭端无法在超时之前发完其所有数据。</p><p>In this event, CLOSE turns into ABORT, and the closing TCP gives up.<br>在这种情况下，CLOSE 变成了 ABORT，而关闭端 TCP 则放弃了。</p><p>The user may CLOSE the connection at any time on his own initiative, or in response to various prompts from the TCP (e.g., remote close executed, transmission timeout exceeded, destination inaccessible).<br>用户可以随时主动关闭连接，或响应来自 TCP 的各种提示（例如，执行远程关闭、传输超时、目标不可访问）。</p><p>Because closing a connection requires communication with the foreign TCP, connections may remain in the closing state for a short time.<br>因为关闭连接需要与外部 TCP 通信，所以连接可能会在短时间内保持在关闭中状态。</p><p>Attempts to reopen the connection before the TCP replies to the CLOSE command will result in error responses.<br>试图在 TCP 回复 CLOSE 命令之前重新打开连接将导致错误响应。</p><p>Close also implies end of letter.<br>关闭也意味着信件的结束。</p><p>Status
状态</p><p>Format: STATUS(local connection name)<br>格式：STATUS(本地连接名)</p><p>This is an implementation dependent user command and could be excluded without adverse effect.<br>这是一个依赖于实现的用户命令，可以排除而不会产生不良影响。</p><p>Information returned would typically come from the TCB associated with the connection.<br>返回的信息通常来自与连接关联的 TCB。</p><p>This command returns a data block containing the following information:<br>该命令返回一个包含以下信息的数据块：</p><p> local socket,<br> 本地套接字,</p><p> foreign socket,<br> 外部套接字,</p><p> local connection name,<br> 本地连接名,</p><p> receive window,<br> 接收窗口,</p><p> send window,<br> 发送窗口,</p><p> connection state,<br> 连接状态,</p><p> number of buffers awaiting acknowledgment,<br> 等待确认的缓冲区数量,</p><p> number of buffers pending receipt (including partial ones),<br> 等待接收的缓冲区的数量（包括部分缓冲区）,</p><p> receive buffer size,<br> 接收缓冲区大小,</p><p> urgent state,<br> 紧急状态,</p><p> precedence,<br> 优先级,</p><p> security/compartment,<br> 安全/区段,</p><p> and default transmission timeout.<br> 以及默认的传输超时,</p><p>Depending on the state of the connection, or on the implementation itself, some of this information may not be available or meaningful.<br>根据连接状态或实现本身，某些信息可能不可用或没有意义。</p><p>If the calling process is not authorized to use this connection, an error is returned.<br>如果调用进程没有被授权使用这个连接，将返回错误。</p><p>This prevents unauthorized processes from gaining information about a connection.<br>这可以防止未经授权的进程获得有关连接的信息。</p><p>Abort<br>中止</p><p>Format: ABORT (local connection name)<br>格式：ABORT（本地连接名）</p><p>This command causes all pending SENDs and RECEIVES to be aborted, the TCB to be removed, and a special RESET message to be sent to the TCP on the other side of the connection.<br>该命令导致所有待定的发送和接收被终止，TCB 被删除，并向连接另一端的 TCP 发送一个特殊的 RESET 消息。</p><p>Depending on the implementation, users may receive abort indications for each outstanding SEND or RECEIVE, or may simply receive an ABORT-acknowledgment.<br>根据不同的实现，用户可能会收到每个未完成的 SEND 或 RECEIVE 的中止指示，或者只是收到一个 ABORT 确认。</p><p><strong>TCP-to-User Messages</strong>
<strong>TCP 到用户的消息</strong></p><p>It is assumed that the operating system environment provides a means for the TCP to asynchronously signal the user program.<br>假设操作系统环境为 TCP 提供了向用户程序发出异步信号的方法。</p><p>When the TCP does signal a user program, certain information is passed to the user.<br>当 TCP 确实向用户程序发出信号时，某些信息会传递给用户。</p><p>Often in the specification the information will be an error message.<br>通常在规范中，信息将是一条错误消息。</p><p>In other cases there will be information relating to the completion of processing a SEND or RECEIVE or other user call.<br>在其他情况下，会有与完成处理 SEND 或 RECEIVE 或其他用户调用有关的信息。</p><p>The following information is provided:<br>提供的信息如下：</p><pre tabindex=0><code>Local Connection Name                    Always
Response String                          Always
Buffer Address                           Send &amp; Receive
Byte count (counts bytes received)       Receive
End-of-Letter flag                       Receive
End-of-Urgent flag                       Receive
</code></pre><h4 id=tcp网络接口>TCP/网络接口
<a class=anchor href=#tcp%e7%bd%91%e7%bb%9c%e6%8e%a5%e5%8f%a3>#</a></h4><p><strong>TCP/Network Interface</strong></p><p>The TCP calls on a lower level protocol module to actually send and receive information over a network.<br>TCP 调用较低级别的协议模块，以通过网络实际发送和接收信息。</p><p>One case is that of the ARPA internetwork system where the lower level module is the Internet Protocol [2].<br>一种情况是 ARPA 网际网络系统，其中较低级别的模块是 IP 协议[2]。</p><p>In most cases the following simple interface would be adequate.<br>在大多数情况下，以下的简单接口就足够了。</p><p>The following two calls satisfy the requirements for the TCP to internet protocol module communication:<br>以下两个调用满足了 TCP 到 IP 协议模块通信的要求：</p><p>SEND (dest, TOS, TTL, BufPTR, len, Id, DF, options => result)</p><p>where:<br>其中：</p><p> dest = destination address<br> dest = 目标地址</p><p> TOS = type of service<br> TOS = 服务类型</p><p> TTL = time to live<br> TTL = 存活时间</p><p> BufPTR = buffer pointer<br> BufPTR = 缓存区指针</p><p> len = length of buffer<br> len = 缓冲区长度</p><p> Id = Identifier<br> Id = 标识符</p><p> DF = Don&rsquo;t Fragment<br> DF = 不要分段</p><p> options = internet option data<br> options = 网络选项数据</p><p> result = response<br> result = 回应</p><p> OK = datagram sent ok<br> OK = 数据报已发送完毕</p><p> Error = error in arguments or local network error<br> Error = 参数错误或本地网络错误</p><p>Note that the precedence is included in the TOS and the security/compartment is passed as an option.<br>请注意，优先级包含在 TOS 中，安全/隔间作为选项传递。</p><p>RECV (BufPTR => result, source, dest, prot, TOS, len)</p><p>where:<br>其中：</p><p> BufPTR = buffer pointer<br> BufPTR = 缓存区指针</p><p> result = response<br> result = 回应</p><p> OK = datagram received ok<br> OK = 数据报接收成功</p><p> Error = error in arguments<br> Error = 参数错误</p><p> source = source address<br> source = 源地址</p><p> dest = destination address<br> dest = 目标地址</p><p> prot = protocol<br> prot = 协议</p><p> TOS = type of service<br> TOS = 服务类型</p><p> options = internet option data<br> options = 网络选项数据</p><p> len = length of buffer<br> len = 缓冲区长度</p><p>Note that the precedence is in the TOS, and the security/compartment is an option.<br>请注意，优先级在 TOS 中，安全/隔间作为选项传递。</p><p>When the TCP sends a segment, it executes the SEND call supplying all the arguments.<br>当 TCP 发送一个段时，它执行 SEND 调用，提供所有参数。</p><p>The internet protocol module, on receiving this call, checks the arguments and prepares and sends the message.<br>IP 协议模块在收到这个调用后，检查参数并准备和发送消息。</p><p>If the arguments are good and the segment is accepted by the local network, the call returns successfully.<br>如果参数是没问题的，并且段被本地网络接受，则返回调用成功。</p><p>If either the arguments are bad, or the segment is not accepted by the local network, the call returns unsuccessfully.<br>如果参数有问题，或者段不被本地网络接受，则返回调用不成功。</p><p>On unsuccessful returns, a reasonable report should be made as to the cause of the problem, but the details of such reports are up to individual implementations.<br>对于不成功的返回，应该就问题的原因进行合理的报告，但此类报告的详细信息取决于具体的实现。</p><p>When a segment arrives at the internet protocol module from the local network, either there is a pending RECV call from TCP or there is not.<br>当一个 TCP 段从本地网络到达 IP 协议模块时，要么有一个来自 TCP 的挂起 RECV 调用，要么没有。</p><p>In the first case, the pending call is satisfied by passing the information from the segment to the TCP.<br>在第一种情况下，通过将段的信息传递给 TCP 来满足挂起的调用。</p><p>In the second case, the TCP is notified of a pending segment.<br>在第二种情况下，TCP 被通知有一个待处理的段。</p><p>The notification of a TCP may be via a pseudo interrupt or similar mechanism, as appropriate in the particular operating system environment of the implementation.<br>TCP 的通知可以通过伪中断或类似机制，视具体实现的操作系统环境而定。</p><p>A TCP&rsquo;s RECV call may then either be immediately satisfied by a pending segment, or the call may be pending until a segment arrives.<br>然后 TCP 的 RECV 调用可能会立即被挂起的段满足，或者调用可能会挂起直到段到达。</p><p>We note that the Internet Protocol provides arguments for a type of service and for a time to live. TCP uses the following settings for these parameters:<br>我们注意到 IP 协议提供了服务类型和生存时间参数。 TCP 对使用以下值设置这些参数：</p><p>Type of Service = Precedence: none, Package: stream, Reliability: higher, Preference: speed, Speed: higher; or 00011111.</p><p>Time to Live = one minute, or 00111100.</p><p>Note that the assumed maximum segment lifetime is two minutes.<br>请注意，假定 TCP 段的最大生命周期是两分钟。</p><p>Here we explicitly ask that a segment be destroyed if it cannot be delivered by the internet system within one minute.<br>在这里，我们明确要求，如果数据段不能在一分钟内由互联网系统送达，则将其销毁。</p><h3 id=事件处理>事件处理
<a class=anchor href=#%e4%ba%8b%e4%bb%b6%e5%a4%84%e7%90%86>#</a></h3><p><strong>3.9. Event Processing</strong></p><p>The activity of the TCP can be characterized as responding to events.<br>可以将 TCP 的活动描述为对事件的响应。</p><p>The events that occur can be cast into three categories: user calls, arriving segments, and timeouts.<br>发生的事件可以分为三类：用户调用、收到段和超时。</p><p>This section describes the processing the TCP does in response to each of the events.<br>本节描述了 TCP 对每个事件所做的处理。</p><p>In many cases the processing required depends on the state of the connection.<br>在很多情况下，需要根据连接状态做对应的处理。</p><p>Events that occur:<br>事件发生：</p><p>User Calls 用户调用<br> OPEN<br> SEND<br> RECEIVE<br> CLOSE<br> ABORT<br> STATUS</p><p>Arriving Segments 收到段<br> SEGMENT ARRIVES</p><p>Timeouts 超时<br> USER TIMEOUT<br> RETRANSMISSION TIMEOUT</p><p>The model of the TCP/user interface is that user commands receive an immediate return and possibly a delayed response via an event or pseudo interrupt.<br>TCP/用户接口的模型是用户命令通过事件或伪中断接收立即返回和可能的延迟响应。</p><p>In the following descriptions, the term &ldquo;signal&rdquo; means cause a delayed response.<br>在以下描述中，术语 &ldquo;signal&rdquo; 是指引起延迟响应。</p><p>Error responses are given as character strings.<br>错误响应是以字符串的形式给出的。</p><p>For example, user commands referencing connections that do not exist receive &ldquo;error: connection not open&rdquo;.<br>例如，引用不存在的连接的用户命令收到 &ldquo;error: connection not open&rdquo;。</p><p>Please note in the following that all arithmetic on sequence numbers, acknowledgment numbers, windows, et cetera, is modulo 2**32 the size of the sequence number space.<br>请注意，下面所有关于序列号、确认号、窗口等的算术都是以序列号空间大小的模 2**32。</p><p>Also note that &ldquo;=&lt;&rdquo; means less than or equal to.<br>还要注意，"=&lt;&rdquo; 表示小于或等于。</p><p>A natural way to think about processing incoming segments is to imagine that they are first tested for proper sequence number (i.e., that their contents lie in the range of the expected &ldquo;receive window&rdquo; in the sequence number space) and then that they are generally queued and processed in sequence number order.<br>考虑处理接收段的一种自然方式是想象它们首先被测试是否有正确的序列号(即，它们是位于序列号空间中预期的"接收窗口"的范围内)，然后它们通常按序列号顺序排队和再依次处理。</p><p>When a segment overlaps other already received segments we reconstruct the segment to contain just the new data, and adjust the header fields to be consistent.<br>当一个 TCP 段与其他已经收到的 TCP 段重叠时，我们会重建段，使其只包含新的数据，并调整头部字段以保持一致。</p><p><strong>OPEN Call</strong><br><strong>OPEN 调用</strong></p><p>CLOSED STATE (i.e., TCB does not exist)</p><p>Create a new transmission control block (TCB) to hold connection state information.<br>创建一个新的传输控制块（TCB）来保存连接状态信息。</p><p>Fill in local socket identifier, foreign socket, precedence, security/compartment, and user timeout information.<br>填入本地套接字标识、外部套接字、优先级、安全/分区和用户超时信息。</p><p>Verify the security and precedence requested are allowed for this user, if not return &ldquo;error: precedence not allowed&rdquo; or &ldquo;error: security/compartment not allowed.&rdquo;<br>验证此用户允许请求的安全性和优先权，如果不允许，则返回 &ldquo;error: precedence not allowed&rdquo; 或 &ldquo;error: security/compartment not allowed&rdquo;。</p><p>If active and the foreign socket is unspecified, return &ldquo;error: foreign socket unspecified&rdquo;; if active and the foreign socket is specified, issue a SYN segment.<br>如果是主动 OPEN 且外部套接字未指定，则返回 &ldquo;error: foreign socket unspecified&rdquo;； 如果是主动 OPEN 并且指定了外部套接字，则发出 SYN 段。</p><p>An initial send sequence number (ISS) is selected and the TCP receive buffer size is selected (if applicable).<br>选择初始发送序列号 (ISS) 并选择 TCP 接收缓冲区大小（如果适用）。</p><p>A SYN segment of the form &lt;SEQ=ISS>&lt;CTL=SYN> is sent (this may include the buffer size option if applicable).<br>发送格式为 &lt;SEQ=ISS>&lt;CTL=SYN> 的 SYN 段（如果适用，这可能包括缓冲区大小选项）。</p><p>Set SND.UNA to ISS, SND.NXT to ISS+1, SND.LBB to ISS+1, enter SYN-SENT state, and return.<br>设置 SND.UNA 为 ISS，SND.NXT 为 ISS+1，SND.LBB 为 ISS+1，进入 SYN-SENT 状态，并返回。</p><p>If the caller does not have access to the local socket specified, return &ldquo;error: connection illegal for this process&rdquo;.<br>如果调用者无权访问指定的本地套接字，返回 &ldquo;error: connection illegal for this process&rdquo;。</p><p>If there is no room to create a new connection, return &ldquo;error: insufficient resources&rdquo;.<br>如果没有空间创建新连接，则返回 &ldquo;error: insufficient resources&rdquo;。</p><p>LISTEN STATE<br>SYN-SENT STATE<br>SYN-RECEIVED STATE<br>ESTABLISHED STATE<br>FIN-WAIT-1 STATE
FIN-WAIT-2 STATE<br>TIME-WAIT STATE<br>CLOSE-WAIT STATE<br>CLOSING STATE</p><p>Return &ldquo;error: connection already exists&rdquo;.<br>返回 &ldquo;error: connection already exists&rdquo;.</p><p><strong>SEND Call</strong><br><strong>SEND 调用</strong></p><p>CLOSED STATE (i.e., TCB does not exist)</p><p>If the user should no have access to such a connection, then return &ldquo;error: connection illegal for this process&rdquo;.<br>如果调用者无权访问这个连接，则返回 &ldquo;error: connection illegal for this process&rdquo;。</p><p>Otherwise, return &ldquo;error: connection does not exist&rdquo;.<br>否则，返回 &ldquo;error: connection does not exist&rdquo;。</p><p>LISTEN STATE</p><p>If the foreign socket is specified, then change the connection from passive to active, select an ISS, and select the receive buffer size.<br>如果指定了外部套接字，则将连接从被动更改为主动，选择一个 ISS，然后选择接收缓冲区大小。</p><p>Send a SYN segment, set SND.UNA to ISS, SND.NXT to ISS+1 and SND.LBB to ISS+1.<br>发送一个 SYN 段，设置 SND.UNA 为 ISS，SND.NXT 为 ISS+1，SND.LBB 为 ISS+1。</p><p>Enter SYN-SENT state. Data associated with SEND may be sent with SYN segment or queued for transmission after entering ESTABLISHED state.<br>进入 SYN-SENT 状态。 在进入 ESTABLISHED 状态后，与 SEND 关联的数据可能与 SYN 段一起发送或排队等待传输。</p><p>The urgent bit if requested in the command should be sent with the first data segment sent as a result of this command.<br>如果在命令中有紧急标志，则应与该命令结果发送的第一个数据段一起发送。</p><p>If there is no room to queue the request, respond with &ldquo;error: insufficient resources&rdquo;.<br>如果没有空间入队请求，请返回 &ldquo;error: insufficient resources&rdquo;。</p><p>If Foreign socket was not specified, then return &ldquo;error: foreign socket unspecified&rdquo;.<br>如果未指定外部套接字，则返回 &ldquo;error: foreign socket unspecified&rdquo;。</p><p>SYN-SENT STATE</p><p>Queue for processing after the connection is ESTABLISHED.<br>在连接 ESTABLISHED 后排队处理。</p><p>Typically, nothing can be sent yet, anyway, because the send window has not yet been set by the other side.<br>通常情况下，无论如何都不能发送任何东西，因为对方还没有设置发送窗口。</p><p>If no space, return &ldquo;error: insufficient resources&rdquo;.<br>如果没有空间，则返回 &ldquo;error: insufficient resources&rdquo;。</p><p>SYN-RECEIVED STATE</p><p>Queue for later processing after entering ESTABLISHED state.<br>进入 ESTABLISHED 状态后排队等待后续处理。</p><p>If no space to queue, respond with &ldquo;error: insufficient resources&rdquo;.<br>如果没有空间入队，则返回 &ldquo;error: insufficient resources&rdquo;。</p><p>ESTABLISHED STATE</p><p>Segmentize the buffer, send or queue it for output, with a piggybacked acknowledgment (acknowledgment value = RCV.NXT) with the data.<br>将缓冲区分段，发送或排队等待发送，并附带数据确认（确认值 = RCV.NXT）。</p><p>If there is insufficient space to remember this buffer, simply return &ldquo;error: insufficient resources&rdquo;.<br>如果没有足够的空间来保存这个缓冲区，就返回"error: insufficient resources"。</p><p>If remote buffer size is not one octet, and, if this is the end of a letter, do the following end-of-letter/buffer-size adjustment processing:<br>如果远程缓冲区大小不是一个字节，并且如果这是一个信件的结尾，则进行以下 end-of-letter/buffer-size 调整处理：</p><p>if EOL = 0 then<br> SND.NXT &lt;- SEG.SEQ + SEG.LEN</p><p>if EOL = 1 then<br> While SND.LBB &lt; SEG.SEQ + SEG.LEN<br> Do SND.LBB &lt;- SND.LBB + SND.BS End<br> SND.NXT &lt;- SND.LBB</p><p>If the urgent flag is set, then SND.UP &lt;- SND.NXT-1 and set the urgent pointer in the outgoing segment.<br>如果设置了紧急标志，则 SND.UP &lt;- SND.NXT-1 并在传出段中设置紧急指针。</p><p>FIN-WAIT-1 STATE
FIN-WAIT-2 STATE
TIME-WAIT STATE</p><p>Return &ldquo;error: connection closing&rdquo; and do not service request.<br>返回 &ldquo;error: connection closing&rdquo;， 并且不处理请求。</p><p>CLOSE-WAIT STATE</p><p>Segmentize any text to be sent and queue for output.<br>对要发送的任何内容进行分段并排队等待输出。</p><p>If there is insufficient space to remember the SEND, return &ldquo;error: insufficient resources&rdquo;.<br>如果没有足够的空间来保存 SEND，返回 &ldquo;error: insufficient resources&rdquo;。</p><p>CLOSING STATE</p><p>Respond with &ldquo;error: connection closing&rdquo;<br>返回 &ldquo;error: connection closing&rdquo;</p><p><strong>RECEIVE Call</strong><br><strong>RECEIVE 调用</strong></p><p>CLOSED STATE (i.e., TCB does not exist)</p><p>If the user should no have access to such a connection, return &ldquo;error: connection illegal for this process&rdquo;.<br>如果调用者无权访问这个连接，返回 &ldquo;error: connection illegal for this process&rdquo;。</p><p>Otherwise return &ldquo;error: connection does not exist&rdquo;.<br>否则返回 &ldquo;error: connection does not exist&rdquo;。</p><p>LISTEN STATE
SYN-SENT STATE
SYN-RECEIVED STATE</p><p>Queue for processing after entering ESTABLISHED state.<br>进入 ESTABLISHED 状态后排队等待后续处理。</p><p>If there is no room to queue this request, respond with &ldquo;error: insufficient resources&rdquo;.<br>如果没有空间入队这个请求，则返回 &ldquo;error: insufficient resources&rdquo;。</p><p>ESTABLISHED STATE</p><p>If insufficient incoming segments are queued to satisfy the request, queue the request.<br>如果队列中没有足够的接收段，则将请求加入到队列。</p><p>If there is no queue space to remember the RECEIVE, respond with &ldquo;error: insufficient resources&rdquo;.<br>如果没有队列空间来保存 RECEIVE，则返回 &ldquo;error: insufficient resources&rdquo;。</p><p>Reassemble queued incoming segments into receive buffer and return to user.<br>将排队的接收段重新组合到接收缓冲区并返回给用户。</p><p>Mark &ldquo;end of letter&rdquo; (EOL) if this is the case.<br>如果是这种情况，标记 &ldquo;信件结尾&rdquo;(EOL)。</p><p>If RCV.UP is in advance of the data currently being passed to the user notify the user of the presence of urgent data.<br>如果 RCV.UP 在当前传递给用户的数据之前，则通知用户有紧急数据存在。</p><p>When the TCP takes responsibility for delivering data to the user that fact must be communicated to the sender via an acknowledgment.<br>当 TCP 向用户传递数据时，必须通过确认将这一情况传达给发送者。</p><p>The formation of such an acknowledgment is described below in the discussion of processing an incoming segment.<br>这种确认的形成会在下面处理接收段的讨论中描述。</p><p>FIN-WAIT-1 STATE
FIN-WAIT-2 STATE</p><p>Reassemble and return a letter, or as much as will fit, in the user buffer.<br>在用户缓冲区内重新组合并返回一个信件，或尽可能多的信件。</p><p>Queue the request if it cannot be serviced immediately.<br>如果无法立即处理请求，将其放入队列。</p><p>TIME-WAIT STATE
CLOSE-WAIT STATE</p><p>Since the remote side has already sent FIN, RECEIVEs must be satisfied by text already reassembled, but not yet delivered to the user.<br>由于远程端已经发送了 FIN，RECEIVE 必须返回已经重新组合但尚未交付给用户的内容。</p><p>If no reassembled segment text is awaiting delivery, the RECEIVE should get a &ldquo;error: connection closing&rdquo; response.<br>如果没有等待交付的重组段内容，则 RECEIVE 应该得到 &ldquo;error: connection closing&rdquo; 响应。</p><p>Otherwise, any remaining text can be used to satisfy the RECEIVE.<br>否则，可以使用任何剩余的内容来返回 RECEIVE。</p><p>CLOSING STATE</p><p>Return &ldquo;error: connection closing&rdquo;<br>返回 &ldquo;error: connection closing&rdquo;。</p><p><strong>CLOSE Call</strong><br><strong>CLOSE 调用</strong></p><p>CLOSED STATE (i.e., TCB does not exist)</p><p>If the user should no have access to such a connection, return &ldquo;error: connection illegal for this process&rdquo;.<br>如果调用者无权访问这个连接，返回 &ldquo;error: connection illegal for this process&rdquo;。</p><p>Otherwise, return &ldquo;error: connection does not exist&rdquo;.<br>否则返回 &ldquo;error: connection does not exist&rdquo;。</p><p>LISTEN STATE</p><p>Any outstanding RECEIVEs should be returned with &ldquo;error: closing&rdquo; responses. Delete TCB, return &ldquo;ok&rdquo;.<br>任何未完成的 RECEIVE 都应返回 &ldquo;error: closing&rdquo;。删除 TCB，返回 &ldquo;ok&rdquo;。</p><p>SYN-SENT STATE</p><p>Delete the TCB and return &ldquo;error: closing&rdquo; responses to any queued SENDs, or RECEIVEs.<br>删除 TCB 并向所有队列中的 SEND 或 RECEIVE 返回 &ldquo;error: closing&rdquo; 响应。</p><p>SYN-RECEIVED STATE</p><p>Queue for processing after entering ESTABLISHED state or segmentize and send FIN segment.<br>进入 ESTABLISHED 状态后排队等待处理或分段发送 FIN 段。</p><p>If the latter, enter FIN-WAIT-1 state.<br>如果是后者，进入 FIN-WAIT-1 状态。</p><p>ESTABLISHED STATE</p><p>Queue this until all preceding SENDs have been segmentized, then form a FIN segment and send it.<br>排队直到所有前面的 SEND 都被分段，然后形成一个 FIN 段并发送它。</p><p>In any case, enter FIN-WAIT-1 state.<br>无论什么情况下，进入 FIN-WAIT-1 状态。</p><p>FIN-WAIT-1 STATE
FIN-WAIT-2 STATE</p><p>Strictly speaking, this is an error and should receive a &ldquo;error: connection closing&rdquo; response.<br>严格来说，这是一个错误，应该收到 &ldquo;error: connection closing&rdquo; 响应。</p><p>An &ldquo;ok&rdquo; response would be acceptable, too, as long as a second FIN is not emitted (the first FIN may be retransmitted though).
只要不发出第二个 FIN（尽管可以重传第一个 FIN），返回 &ldquo;ok&rdquo; 也是可以接受的。</p><p>TIME-WAIT STATE</p><p>Strictly speaking, this is an error and should receive a &ldquo;error: connection closing&rdquo; response.<br>严格来说，这是一个错误，应该收到 &ldquo;error: connection closing&rdquo; 响应。</p><p>An &ldquo;ok&rdquo; response would be acceptable, too.
和上面一样，返回 &ldquo;ok&rdquo; 也是可以接受的。</p><p>However, since the FIN has been sent and acknowledged, nothing should be sent (or retransmitted).<br>但是，由于 FIN 已发送并得到确认，因此不应发送（或重传）任何内容。</p><p>CLOSE-WAIT STATE</p><p>Queue this request until all preceding SENDs have been segmentized; then send a FIN segment, enter CLOSING state.<br>排队直到所有前面的 SEND 都被分段，然后形成一个 FIN 段并发送它，进入 CLOSING 状态。</p><p>CLOSING STATE</p><p>Respond with &ldquo;error: connection closing&rdquo;<br>返回 &ldquo;error: connection closing&rdquo;</p><p><strong>ABORT Call</strong><br><strong>ABORT 调用</strong></p><p>CLOSED STATE (i.e., TCB does not exist)</p><p>If the user should no have access to such a connection, return &ldquo;error: connection illegal for this process&rdquo;.<br>如果调用者无权访问这个连接，返回 &ldquo;error: connection illegal for this process&rdquo;。</p><p>Otherwise return &ldquo;error: connection does not exist&rdquo;.<br>否则返回 &ldquo;error: connection does not exist&rdquo;。</p><p>LISTEN STATE</p><p>Any outstanding RECEIVEs should be returned with &ldquo;error: connection reset&rdquo; responses.<br>任何未完成的 RECEIVE 都应返回 &ldquo;error: connection reset&rdquo; 响应。</p><p>Delete TCB, return &ldquo;ok&rdquo;.<br>删除 TCB，返回 &ldquo;ok&rdquo;。</p><p>SYN-SENT STATE</p><p>Delete the TCB and return &ldquo;reset&rdquo; responses to any queued SENDs, or RECEIVEs.<br>删除 TCB 并向所有队列中的 SEND 或 RECEIVE 返回 &ldquo;reset&rdquo; 响应。</p><p>SYN-RECEIVED STATE</p><p>Send a RST of the form:<br>发送以下形式的 RST：</p><p>&lt;SEQ=SND.NXT>&lt;ACK=RCV.NXT>&lt;CTL=RST,ACK></p><p>and return any unprocessed SENDs, or RECEIVEs with &ldquo;reset&rdquo; code, delete the TCB.<br>使用 &ldquo;reset&rdquo; 返回所有未处理的 SEND 或 RECEIVE，删除 TCB。</p><p>ESTABLISHED STATE</p><p>Send a reset segment:<br>发送重置段：</p><p>&lt;SEQ=SND.NXT>&lt;ACK=RCV.NXT>&lt;CTL=RST,ACK></p><p>All queued SENDs and RECEIVEs should be given &ldquo;reset&rdquo; responses; all segments queued for transmission (except for the RST formed above) or retransmission should be flushed, delete the TCB.<br>所有队列中的 SEND 和 RECEIVE 都应该得到 &ldquo;reset&rdquo; 响应；清除所有排队等待传输（除了上面形成的 RST）或重传的段，删除 TCB。</p><p>FIN-WAIT-1 STATE
FIN-WAIT-2 STATE</p><p>A reset segment (RST) should be formed and sent:<br>应生成并发送重置段（RST）：</p><p>&lt;SEQ=SND.NXT>&lt;ACK=RCV.NXT>&lt;CTL=RST,ACK></p><p>Outstanding SENDs, RECEIVEs, CLOSEs, and/or segments queued for retransmission, or segmentizing, should be flushed, with &ldquo;connection reset&rdquo; notification to the user, delete the TCB.<br>清除未完成的 SENDs, RECEIVEs, CLOSEs 和/或排队重发或分段的段，并向用户发出 &ldquo;connection reset&rdquo; 通知，删除 TCB。</p><p>TIME-WAIT STATE</p><p>Respond with &ldquo;ok&rdquo; and delete the TCB.<br>返回 &ldquo;ok&rdquo; 并删除 TCB。</p><p>CLOSE-WAIT STATE</p><p>Flush any pending SENDs and RECEIVEs, returning &ldquo;connection reset&rdquo; responses for them.<br>清除所有待处理的 SEND 和 RECEIVE，给它们返回 &ldquo;connection reset&rdquo; 响应。</p><p>Form and send a RST segment:<br>应生成并发送重置段（RST）：</p><p>&lt;SEQ=SND.NXT>&lt;ACK=RCV.NXT>&lt;CTL=RST,ACK></p><p>Flush all segment queues and delete the TCB.<br>清除所有段队列并删除 TCB。</p><p>CLOSING STATE</p><p>Respond with &ldquo;ok&rdquo; and delete the TCB; flush any remaining segment queues.<br>返回 &ldquo;ok&rdquo; 并删除 TCB；清除所有剩余的段队列。</p><p>If a CLOSE command is still pending, respond &ldquo;error: connection reset&rdquo;.<br>如果 CLOSE 命令还没完成，则响应 &ldquo;error: connection reset&rdquo;。</p><p><strong>STATUS Call</strong><br><strong>STATUS 调用</strong></p><p>CLOSED STATE (i.e., TCB does not exist)</p><p>If the user should no have access to such a connection, return &ldquo;error: connection illegal for this process&rdquo;.<br>如果调用者无权访问这个连接，返回 &ldquo;error: connection illegal for this process&rdquo;。</p><p>Otherwise return &ldquo;error: connection does not exist&rdquo;.<br>否则返回 &ldquo;error: connection does not exist&rdquo;。</p><p>LISTEN STATE</p><p>Return &ldquo;state = LISTEN&rdquo;, and the TCB pointer.<br>返回 &ldquo;state = LISTEN&rdquo;，以及 TCB 指针。</p><p>SYN-SENT STATE</p><p>Return &ldquo;state = SYN-SENT&rdquo;, and the TCB pointer.<br>返回 &ldquo;state = SYN-SENT&rdquo;，以及 TCB 指针。</p><p>SYN-RECEIVED STATE</p><p>Return &ldquo;state = SYN-RECEIVED&rdquo;, and the TCB pointer.<br>返回 &ldquo;state = SYN-RECEIVED&rdquo;，以及 TCB 指针。</p><p>ESTABLISHED STATE</p><p>Return &ldquo;state = ESTABLISHED&rdquo;, and the TCB pointer.<br>返回 &ldquo;state = ESTABLISHED&rdquo;，以及 TCB 指针。</p><p>FIN-WAIT-1 STATE</p><p>Return &ldquo;state = FIN-WAIT-1&rdquo;, and the TCB pointer.<br>返回 &ldquo;state = FIN-WAIT-1&rdquo;，以及 TCB 指针。</p><p>FIN-WAIT-2 STATE</p><p>Return &ldquo;state = FIN-WAIT-2&rdquo;, and the TCB pointer.<br>返回 &ldquo;state = FIN-WAIT-2&rdquo;，以及 TCB 指针。</p><p>TIME-WAIT STATE</p><p>Return &ldquo;state = TIME-WAIT&rdquo; and the TCB pointer.<br>返回 &ldquo;state = TIME-WAIT&rdquo;，以及 TCB 指针。</p><p>CLOSE-WAIT STATE</p><p>Return &ldquo;state = CLOSE-WAIT&rdquo;, and the TCB pointer.<br>返回 &ldquo;state = CLOSE-WAIT&rdquo;，以及 TCB 指针。</p><p>CLOSING STATE</p><p>Return &ldquo;state = CLOSING&rdquo;, and the TCB pointer.<br>返回 &ldquo;state = CLOSING&rdquo;，以及 TCB 指针。</p><p><strong>SEGMENT ARRIVES</strong><br><strong>段到达</strong></p><p>If the state is CLOSED (i.e., TCB does not exist) then<br>如果状态为 CLOSED（即 TCB 不存在），则</p><p>all data in the incoming segment is discarded.<br>接收段中的所有数据都被丢弃。</p><p>An incoming segment containing a RST is discarded.<br>丢弃包含 RST 的接收段。</p><p>An incoming segment not containing a RST causes a RST to be sent in response.<br>如果接收段不包含 RST，则回复一个 RST。</p><p>The acknowledgment and sequence field values are selected to make the reset sequence acceptable to the TCP that sent the offending segment.<br>选择确认和序列字段值是为了使发送无效段的 TCP 可以有效的接收重置序列。</p><p>If the ACK bit is off, sequence number zero is used,<br>如果没有 ACK 标志位，则使用序列号零，</p><p>&lt;SEQ=0>&lt;ACK=SEG.SEQ+SEG.LEN>&lt;CTL=RST,ACK></p><p>If the ACK bit is on,<br>如果有 ACK 标志位，</p><p>&lt;SEQ=SEG.ACK>&lt;CTL=RST></p><p>Return.<br>返回。</p><p>If the state is LISTEN then<br>如果状态是 LISTEN，则</p><p>first check for an ACK<br>首先检查是否是 ACK</p><p>Any acknowledgment is bad if it arrives on a connection still in the LISTEN state.<br>如果连接仍处于 LISTEN 状态的连接，则任何 ACK（确认）都是无效的。</p><p>An acceptable reset segment should be formed for any arriving ACK-bearing segment, except another RST.<br>除了另一个 RST 之外，任何到达的带有 ACK 段都应该生成一个有效的重置段。</p><p>The RST should be formatted as follows:<br>RST 的格式应如下所示：</p><p>&lt;SEQ=SEG.ACK>&lt;CTL=RST></p><p>Return.<br>返回。</p><p>An incoming RST should be ignored. Return.<br>接收的 RST 应该被忽略。返回。</p><p>if there was no ACK then check for a SYN<br>如果不是 ACK，则检查是否是 SYN</p><p>If the SYN bit is set, check the security.<br>如果设置了 SYN 标志位，则检查安全性。</p><p>If the security/compartment on the incoming segment does not exactly match the security/compartment in the TCB then send a reset and return.<br>如果接收段上的安全/区段与 TCB 中的安全/区段不完全匹配，则发送重置段并返回。</p><p>If the SEG.PRC is less than the TCB.PRC then send a reset and return.<br>如果 SEG.PRC 小于 TCB.PRC，则发送重置段并返回。</p><p>If the SEG.PRC is greater than the TCB.PRC then set TCB.PRC &lt;- SEG.PRC.<br>如果 SEG.PRC 大于 TCB.PRC，则设置 TCB.PRC &lt;- SEG.PRC。</p><p>Now RCV.NXT and RCV.LBB are set to SEG.SEQ+1, IRS is set to SEG.SEQ and any other control or text should be queued for processing later.<br>现在 RCV.NXT 和 RCV.LBB 设置为 SEG.SEQ+1，IRS 设置为 SEG.SEQ，任何其他控制或内容都应入队等待稍后处理。</p><p>ISS should be selected and a SYN segment sent of the form:<br>应选择 ISS 并发送以下形式的 SYN 段：</p><p>&lt;SEQ=ISS>&lt;ACK=RCV.NXT>&lt;CTL=SYN,ACK></p><p>SND.NXT and SND.LBB are set to ISS+1 and SND.UNA to ISS.<br>SND.NXT 和 SND.LBB 设置为 ISS+1，SND.UNA 设置为 ISS。</p><p>The connection state should be changed to SYN-RECEIVED.<br>连接状态应更改为 SYN-RECEIVED。</p><p>Note that any other incoming control or data (combined with SYN) will be processed in the SYN-RECEIVED state, but processing of SYN and ACK should not be repeated.<br>注意，任何其它收到的控制或数据（与 SYN 关联）将在 SYN-RECEIVED 状态下处理，但 SYN 和 ACK 的处理不能重复。</p><p>If the listen was not fully specified (i.e., the foreign socket was not fully specified), then the unspecified fields should be filled in now.<br>如果没有完全指定监听（即没有完全指定外部套接字），那么现在应该填写未指定的字段。</p><p>if there was no SYN but there was other text or control<br>如果不是 SYN 但有其他内容或控制</p><p>Any other control or text-bearing segment (not containing SYN) must have an ACK and thus would be discarded by the ACK processing.<br>任何其他控制或带内容的段（不包含 SYN）都会回复一个 ACK，但是数据会在处理 ACK 时丢弃。</p><p>An incoming RST segment could not be valid, since it could not have been sent in response to anything sent by this incarnation of the connection.<br>接收的 RST 段不可能是有效的，因为它不可能是为了响应这个连接所发送的任何东西而发送的。</p><p>So you are unlikely to get here, but if you do, drop the segment, and return.<br>所以你不太可能会遇到这种情况，但如果你遇到了，就丢弃这个段，然后返回。</p><p>If the state is SYN-SENT then<br>如果状态是 SYN-SENT，则</p><p>first check for an ACK<br>首先检查是否是 ACK</p><p>If SEG.ACK =&lt; ISS, or SEG.ACK > SND.NXT, or the security/compartment in the segment does not exactly match the security/compartment in the TCB, or the precedence in the segment is less than the precedence in the TCB, send a reset<br>如果 SEG.ACK =&lt; ISS，或者 SEG.ACK > SND.NXT，或者段中的安全/区段与 TCB 中的安全/区段不完全匹配，或者段中的优先级小于 TCB 中的优先级，则发送一个复位段</p><p>&lt;SEQ=SEG.ACK>&lt;CTL=RST></p><p>and discard the segment. Return.<br>并丢弃该段。返回。</p><p>If SND.UNA =&lt; SEG.ACK =&lt; SND.NXT and the security/compartment and precedence are acceptable then the ACK is acceptable.<br>如果 SND.UNA =&lt; SEG.ACK =&lt; SND.NXT，并且安全/区段和优先级没有问题，那么 ACK 是有效的。</p><p>SND.UNA should be advanced to equal SEG.ACK, and any segments on the retransmission queue which are thereby acknowledged should be removed.<br>SND.UNA 应增加到等于 SEG.ACK，重传队列中任何因此被确认的片段应被删除。</p><p>if the ACK is ok (or there is no ACK), check the RST bit<br>如果 ACK 正常（或没有 ACK），检查 RST 位</p><p>If the RST bit is set then signal the user &ldquo;error: connection reset&rdquo;, enter CLOSED state, drop the segment, delete TCB, and return.<br>如果设置了 RST 标志位，则向用户发出 &ldquo;error: connection reset&rdquo; 的信号，进入关闭状态，丢弃该段，删除 TCB，然后返回。</p><p>if the ACK is ok (or there is no ACK) and it was not a RST, check the SYN bit.<br>如果 ACK 正常（或没有 ACK），并且不是 RST，检查 SYN 标志位。</p><p>If the SYN bit is on and the security/compartment and precedence are acceptable then, RCV.NXT and RCV.LBB are set to SEG.SEQ+1, IRS is set to SEG.SEQ.<br>如果设置了 SYN 标志位，并且安全/区段和优先级没有问题，那么，RCV.NXT 和 RCV.LBB 被设置为 SEG.SEQ+1，IRS 被设置为 SEG.SEQ。</p><p>If SND.UNA > ISS (our SYN has been ACKed), change the connection state to ESTABLISHED, otherwise enter SYN-RECEIVED.<br>如果 SND.UNA>ISS（我们的 SYN 已经被 ACK 了），将连接状态改为 ESTABLISHED，否则进入 SYN-RECEIVED。</p><p>In any case, form an ACK segment:<br>无论是哪种情况，生成一个 ACK 段。</p><p>&lt;SEQ=SND.NXT>&lt;ACK=RCV.NXT>&lt;CTL=ACK></p><p>and send it. Data or controls which were queued for transmission may be included.<br>并将其发送，数据中可能包括队列中等待发送的数据或控制。</p><p>If SEG.PRC is greater than TCB.PRC set TCB.PRC &lt;- SEG.PRC.<br>如果 SEG.PRC 大于 TCB.PRC，设置 TCB.PRC &lt;- SEG.PRC。</p><p>If there are other controls or text in the segment then continue processing at the fifth step below where the URG bit is checked, otherwise return.<br>如果段中还有其他控制或内容，则继续下面第五步检查 URG 位的处理，否则返回。</p><p>Otherwise,<br>否则，</p><p>first check sequence number<br>第一步，检查序列号</p><p>SYN-RECEIVED STATE<br>ESTABLISHED STATE<br>FIN-WAIT-1 STATE<br>FIN-WAIT-2 STATE<br>TIME-WAIT STATE<br>CLOSE-WAIT STATE<br>CLOSING STATE</p><p>Segments are processed in sequence.<br>按顺序处理段。</p><p>Initial tests on arrival are used to discard old duplicates, but further processing is done in SEG.SEQ order.<br>到达时的初始检测用于丢弃旧的重复项，但进一步处理按 SEG.SEQ 顺序完成。</p><p>If a segment&rsquo;s contents straddle the boundary between old and new, only the new parts should be processed.<br>如果一个段的内容即包括了新内容也包括了旧内容，那么应该只处理新的部分。</p><p>There are four cases for the acceptability test for an incoming segment:<br>检查接收段是否有效的情况有四种：</p><pre tabindex=0><code>  Segment Receive  Test
  Length  Window
  ------- -------  -------------------------------------------
      0       0     SEG.SEQ = RCV.NXT
      0      &gt;0     RCV.NXT =&lt; SEG.SEQ &lt; RCV.NXT+RCV.WND
     &gt;0       0     not acceptable
     &gt;0      &gt;0     RCV.NXT &lt; SEG.SEQ+SEG.LEN =&lt; RCV.NXT+RCV.WND
</code></pre><p>Note that the test above guarantees that the last sequence number used by the segment lies in the receive-window.<br>注意，上面的检查保证了该段使用的最后一个序列号位于接收窗口内。</p><p>If the RCV.WND is zero, no segments will be acceptable, but special allowance should be made to accept valid ACKs, URGs and RSTs.<br>如果 RCV.WND 为 0，则不接收任何段，但有效的 ACK、URG 和 RST 还是需要处理。</p><p>If an incoming segment is not acceptable, an acknowledgment should be sent in reply:<br>如果收到的段无效，则应发送确认段作为回复：</p><p>&lt;SEQ=SND.NXT>&lt;ACK=RCV.NXT>&lt;CTL=ACK></p><p>If the incoming segment is unacceptable, drop it and return.<br>如果收到的段无效，就丢弃它并返回。</p><p>second check security and precedence<br>第二步，检查安全性和优先级</p><p>If the security/compartment and precedence in the segment do not exactly match the security/compartment and precedence in the TCB then form a reset and return.<br>如果 TCP 段中的安全/区段和优先级与 TCB 中的安全/区段和优先级不完全匹配，则生成重置并返回。</p><p>Note this check is placed following the sequence check to prevent a segment from an old connection between these parts with a different security or precedence from causing an abort of the current connection.<br>注意，这个检查是放在序列号之后的，以防止在这些段之间存在一个来自旧连接具有不同安全性或优先级的段引起当前连接的中止。</p><p>third check the ACK field,<br>第三步，检查 ACK 字段，</p><p>SYN-RECEIVED STATE</p><p>If the RST bit is off and SND.UNA &lt; SEG.ACK =&lt; SND.NXT then set SND.UNA &lt;- SEG.ACK, remove any acknowledged segments from the retransmission queue, and enter ESTABLISHED state.<br>如果没有设置 RST 标识位，并且 SND.UNA &lt; SEG.ACK =&lt; SND.NXT，那么设置 SND.UNA &lt;- SEG.ACK，从重传队列中删除所有已确认的段，并进入 ESTABLISHED 状态。</p><p>If the segment acknowledgment is not acceptable, form a reset segment,<br>如果该段的 ACK（确认）无效，则生成一个重置段，</p><p>&lt;SEQ=SEG.ACK>&lt;CTL=RST></p><p>and send it, unless the incoming segment is an RST (or there is no ACK), in which case, it should be discarded, then return.<br>并发送它，除非收到的段是 RST（或者没有 ACK），在这种情况下，它应该被丢弃，然后返回。</p><p>ESTABLISHED STATE</p><p>If SND.UNA &lt; SEG.ACK =&lt; SND.NXT then, set SND.UNA &lt;- SEG.ACK.<br>如果 SND.UNA &lt; SEG.ACK =&lt; SND.NXT，那么，设置 SND.UNA &lt;- SEG.ACK。</p><p>Any segments on the retransmission queue which are thereby entirely acknowledged are removed.<br>移除重传队列上所有因此完全确认的段。</p><p>Users should receive positive acknowledgments for buffers which have been SENT and fully acknowledged (i.e., SEND buffer should be returned with &ldquo;ok&rdquo; response).<br>对于已经发送并完全确认的缓冲区，用户应该收到肯定的确认（即，SEND 缓冲区应该返回 &ldquo;ok &ldquo;响应）。</p><p>If the ACK is a duplicate, it can be ignored.<br>如果 ACK 是重复的，就可以忽略。</p><p>If the segment passes the sequence number and acknowledgment number tests, the send window should be updated.<br>如果该段通过了序列号和确认号检查，则更新发送窗口。</p><p>If SND.WL =&lt; SEG.SEQ, set SND.WND &lt;- SEG.WND and set SND.WL &lt;- SEG.SEQ.<br>如果 SND.WL =&lt; SEG.SEQ，设置 SND.WND &lt;- SEG.WND， SND.WL &lt;- SEG.SEQ。</p><p>If the remote buffer size is not one, then the end-of-letter/buffer-size adjustment to sequence numbers may have an effect on the next expected sequence number to be acknowledged.<br>如果远程缓冲区大小不是一个字节，那么对序列号的 end-of-letter/buffer-size 调整可能会对下一个预期被确认的序列号产生影响。</p><p>It is possible that the remote TCP will acknowledge with a SEG.ACK equal to a sequence number of an octet that was skipped over at the end of a letter.<br>远程 TCP 可能会使用等于在信件末尾跳过一个字节的序列号的 SEG.ACK 进行确认。</p><p>This a mild error on the remote TCPs part, but not cause for alarm.
这是远程 TCP 的轻微错误，不会引起警报。</p><p>FIN-WAIT-1 STATE
FIN-WAIT-2 STATE</p><p>In addition to the processing for the ESTABLISHED state, if the retransmission queue is empty, the user&rsquo;s CLOSE can be acknowledged (&ldquo;ok&rdquo;) but do not delete the TCB.<br>除了 ESTABLISHED 状态的处理外，如果重传队列是空的，用户的 CLOSE 可以被确认（&ldquo;ok&rdquo;），但不删除 TCB。</p><p>TIME-WAIT STATE</p><p>The only thing that can arrive in this state is a retransmission of the remote FIN. Acknowledge it, and restart the 2 MSL timeout.<br>在这种状态下，唯一能到达的是远程 FIN 的重传。确认它并重新启动 2MSL 超时。</p><p>CLOSE-WAIT STATE</p><p>Do the same processing as for the ESTABLISHED state.<br>进行与 ESTABLISHED 状态相同的处理。</p><p>CLOSING STATE</p><p>If the ACK acknowledges our FIN then delete the TCB (enter the CLOSED state), otherwise ignore the segment.<br>如果 ACK 确认了我们的 FIN，那么就删除 TCB（进入 CLOSED 状态），否则就忽略这个段。</p><p>fourth check the RST bit,<br>第四步，检查 RST 标识位，</p><p>SYN-RECEIVED STATE</p><p>If the RST bit is set then, if the segment has passed sequence and acknowledgment tests, it is valid.<br>如果设置了 RST 标识位且该段通过了序列号和确认号测试，它就是有效的。</p><p>If this connection was initiated with a passive OPEN (i.e., came from the LISTEN state), then return this connection to LISTEN state.<br>如果这个连接是以被动的 OPEN 启动的（即来自于 LISTEN 状态），那么就把这个连接返回到 LISTEN 状态。</p><p>The user need not be informed.<br>不需要通知用户。</p><p>If this connection was initiated with an active OPEN (i.e., came from SYN-SENT state) then the connection was refused, signal the user &ldquo;connection refused&rdquo;.<br>如果这个连接是以主动 OPEN 启动的（即来自 SYN-SENT 状态），然后这个连接被拒绝了，则向用户发出 &ldquo;connection refused&rdquo; 的信号。</p><p>In either case, all segments on the retransmission queue should be removed.<br>在这两种情况下，重传队列中的所有段都应被删除。</p><p>ESTABLISHED
FIN-WAIT-1
FIN-WAIT-2
CLOSE-WAIT
CLOSING STATE</p><p>If the RST bit is set then, any outstanding RECEIVEs and SEND should receive &ldquo;reset&rdquo; responses.<br>如果设置了 RST 标识位，那么任何未完成的 RECEIVE 和 SEND 都应该收到 &ldquo;reset&rdquo; 响应。</p><p>All segment queues should be flushed.<br>所有的段队列都应该被清除。</p><p>Users should also receive an unsolicited general &ldquo;connection reset&rdquo; signal.<br>用户还应收到未经请求通用的 &ldquo;connection reset&rdquo; 信号。</p><p>Enter the CLOSED state, delete the TCB, and return.<br>进入 CLOSED 状态，删除 TCB，并返回。</p><p>TIME-WAIT</p><p>Enter the CLOSED state, delete the TCB, and return.<br>进入 CLOSED 状态，删除 TCB，并返回。</p><p>fifth, check the SYN bit,<br>第五步，检查 SYN 标识位，</p><p>SYN-RECEIVED
ESTABLISHED STATE</p><p>If the SYN bit is set, check the segment sequence number against the receive window.<br>如果设置了 SYN 标识位，则根据接收窗口检查段序列号。</p><p>The segment sequence number must be in the receive window; if not, ignore the segment.<br>段序号必须在接收窗口内；如果不是，则忽略该段。</p><p>If the SYN is on and SEG.SEQ = IRS then everything is ok and no action is needed; but if they are not equal, there is an error and a reset must be sent.<br>如果有 SYN 标识位，并且 SEG.SEQ = IRS 那么一切正常，不需要任何操作；但如果它们不相等，就会出错，必须发送重置段。</p><p>If a reset must be sent it is formed as follows:<br>如果需要发送重置段，则其格式如下：</p><p>&lt;SEQ=SEG.ACK>&lt;CTL=RST></p><p>The connection must be aborted as if a RST had been received.<br>就像收到 RST 一样，终止连接。</p><p>FIN-WAIT STATE-1
FIN-WAIT STATE-2
TIME-WAIT STATE
CLOSE-WAIT STATE
CLOSING STATE</p><p>This case should not occur, since a duplicate of the SYN which started the current connection incarnation will have been filtered in the SEG.SEQ processing.<br>这种情况不应该发生，因为在 SEG.SEQ 处理中，启动当前连接的 SYN 的重复部分已经被过滤掉了。</p><p>Other SYN&rsquo;s will have been rejected by this test as well (see SYN processing for ESTABLISHED state).<br>其他 SYN 也会被这个检查拒绝（见 ESTABLISHED 状态的 SYN 处理）。</p><p>sixth, check the URG bit,<br>第六步，检查 URG 标识位，</p><p>ESTABLISHED STATE
FIN-WAIT-1 STATE
FIN-WAIT-2 STATE</p><p>If the URG bit is set, RCV.UP &lt;- max(RCV.UP,SEG.UP), and signal the user that the remote side has urgent data if the urgent pointer (RCV.UP) is in advance of the data consumed.<br>如果设置了 URG 标识位，RCV.UP &lt;- max(RCV.UP,SEG.UP)，如果紧急指针(RCV.UP)在所接收的数据之前，则向用户发出信号，表明远程端有紧急数据。</p><p>If the user has already been signaled (or is still in the &ldquo;urgent mode&rdquo;) for this continuous sequence of urgent data, do not signal the user again.<br>如果已经因为这个连续的紧急数据序列向用户发出了信号（或仍处于"紧急模式&rdquo;），就不要再次向用户发出信号。</p><p>TIME-WAIT STATE
CLOSE-WAIT STATE
CLOSING</p><p>This should not occur, since a FIN has been received from the remote side. Ignore the URG.<br>这不应该发生，因为已经收到了来自远程端的 FIN，忽略 URG。</p><p>seventh, process the segment text,<br>第七步，处理段内容，</p><p>ESTABLISHED STATE</p><p>Once in the ESTABLISHED state, it is possible to deliver segment text to user RECEIVE buffers.<br>一旦进入 ESTABLISHED 状态，就有可能向用户的 RECEIVE 缓冲区传送段内容。</p><p>Text from segments can be moved into buffers until either the buffer is full or the segment is empty.<br>将段中的内容移入缓冲区，直到缓冲区已满或段为空。</p><p>If the segment empties and carries an EOL flag, then the user is informed, when the buffer is returned, that an EOL has been received.<br>如果该段为空并带有 EOL 标志，则在返回缓冲区时通知用户已收到 EOL。</p><p>If buffer size is not one octet, then do the following end-of-letter/buffer-size adjustment processing:<br>如果缓冲区大小不是一个字节，则执行以下 end-of-letter/buffer-size 调整处理：</p><p>if EOL = 0 then</p><p>RCV.NXT &lt;- SEG.SEQ + SEG.LEN</p><p>if EOL = 1 then</p><p>While RCV.LBB &lt; SEG.SEQ+SEG.LEN<br>Do RCV.LBB &lt;- RCV.LBB + RCV.BS End<br>RCV.NXT &lt;- RCV.LBB</p><p>When the TCP takes responsibility for delivering the data to the user it must also acknowledge the receipt of the data.<br>当 TCP 负责将数据传送给用户时，它也必须确认数据的接收。</p><p>Send an acknowledgment of the form:<br>发送以下格式的确认段：</p><p>&lt;SEQ=SND.NXT>&lt;ACK=RCV.NXT>&lt;CTL=ACK></p><p>This acknowledgment should be piggybacked on a segment being transmitted if possible without incurring undue delay.<br>如果可能的话，该确认应加在正准备传输的段上，这样就不会导致不必要的延迟。</p><p>FIN-WAIT-1 STATE
FIN-WAIT-2 STATE</p><p>If there are outstanding RECEIVEs, they should be satisfied, if possible, with the text of this segment; remaining text should be queued for further processing.<br>如果有未完成的 RECEIVEs，如果可能的话，该段的内容可以完成它；其余的内容应该排队等待进一步处理。</p><p>If a RECEIVE is satisfied, the user should be notified, with &ldquo;end-of-letter&rdquo; (EOL) signal, if appropriate.<br>如果 RECEIVE 得到满足，则应通知用户，并在适当时发送 &ldquo;end-of-letter&rdquo; (EOL) 信号。</p><p>TIME-WAIT STATE
CLOSE-WAIT STATE</p><p>This should not occur, since a FIN has been received from the remote side. Ignore the segment text.<br>这不应该发生，因为已经收到了来自远程端的 FIN。忽略该段内容。</p><p>eighth, check the FIN bit,<br>第八步，检查 FIN 标识位，</p><p>Send an acknowledgment for the FIN.<br>为 FIN 发送确认。</p><p>Signal the user &ldquo;connection closing&rdquo;, and return any pending RECEIVEs with same message.<br>向用户发出 &ldquo;connection closing&rdquo; 信号，并使用相同的消息返回任何待处理的 RECEIVE。</p><p>Note that FIN implies EOL for any segment text not yet delivered to the user.<br>注意，对于还没有传给用户的任何段内容，FIN 意味着 EOL。</p><p>If the current state is ESTABLISHED, enter the CLOSE-WAIT state.<br>如果当前状态为 ESTABLISHED，则进入 CLOSE-WAIT 状态。</p><p>If the current state is FIN-WAIT-1, enter the CLOSING state.<br>如果当前状态为 FIN-WAIT-1，则进入 CLOSING 状态。</p><p>If the current state is FIN-WAIT-2, enter the TIME-WAIT state.<br>如果当前状态为 FIN-WAIT-2，则进入 TIME-WAIT 状态。</p><p>and return.<br>并返回。</p><p>USER TIMEOUT</p><p>For any state if the user timeout expires, flush all queues, signal the user &ldquo;error: connection aborted due to user timeout&rdquo; in general and for any outstanding calls, delete the TCB, and return.<br>对于任何状态，如果用户超时到期，清空所有队列，对于任何未完成的调用，向用户发出信号 &ldquo;error: connection aborted due to user timeout&rdquo;，删除 TCB 并返回。</p><p>RETRANSMISSION TIMEOUT</p><p>For any state if the retransmission timeout expires on a segment in the retransmission queue, send the segment at the front of the retransmission queue again, reinitialize the retransmission timer, and return.<br>对于任何状态，如果重传队列中的一个段的重传超时，再次发送重传队列前面的段，重新初始化重传定时器，然后返回。</p><h2 id=词汇表>词汇表
<a class=anchor href=#%e8%af%8d%e6%b1%87%e8%a1%a8>#</a></h2><p><strong>GLOSSARY</strong></p><p><strong>1822</strong><br>BBN Report 1822, &ldquo;The Specification of the Interconnection of a Host and an IMP&rdquo;.<br>BBN Report 1822，&ldquo;主机与 IMP 互连规范&rdquo;。</p><p>The specification of interface between a host and the ARPANET.<br>主机和 ARPANET 之间的接口规范。</p><p><strong>ACK</strong><br>A control bit (acknowledge) occupying no sequence space, which indicates that the acknowledgment field of this segment specifies the next sequence number the sender of this segment is expecting to receive, hence acknowledging receipt of all previous sequence numbers.<br>不占用序列空间的控制位（确认），它表明该段的确认字段表示该段的发送方期望接收的下一个序列号，并且确认收到所有先前的序列号。</p><p><strong>ARPANET message</strong><br>The unit of transmission between a host and an IMP in the ARPANET. The maximum size is about 1012 octets (8096 bits).<br>ARPANET 中主机和 IMP 之间的传输单位。最大值约为 1012 个 octets（8096 bit）。</p><p><strong>ARPANET packet</strong><br>A unit of transmission used internally in the ARPANET between IMPs. The maximum size is about 126 octets (1008 bits).<br>ARPANET 中 IMP 之间使用的一种传输单位。最大尺寸约为 126 个 octets（1008 bit）。</p><p><strong>buffer size</strong><br>An option (buffer size) used to state the receive data buffer size of the sender of this option. May only be sent in a segment that also carries a SYN.<br>选项（缓冲区大小），用于说明这个选项的发送者的接收数据缓冲区大小，只能在携带 SYN 的段中发送。</p><p><strong>connection</strong><br>A logical communication path identified by a pair of sockets.<br>由一对套接字标识的逻辑通信通道。</p><p><strong>datagram</strong><br>A message sent in a packet switched computer communications network.<br>在分组交换计算机通信网络中发送的消息。</p><p><strong>Destination Address</strong><br>The destination address, usually the network and host identifiers.<br>目标地址，通常是网络和主机标识符。</p><p><strong>EOL</strong><br>A control bit (End of Letter) occupying no sequence space, indicating that this segment ends a logical letter with the last data octet in the segment.<br>不占用序列空间的控制位（End of Letter），表示以段中最后一个数据字节结束一个逻辑信件。</p><p>If this end of letter causes a less than full buffer to be released to the user and the connection buffer size is not one octet then the end-of-letter/buffer-size adjustment to the receive sequence number must be made.<br>如果这个 EOL 导致向用户释放的缓冲区不全，并且连接缓冲区大小不是一个字节，那么必须对接收序列号进行 end-of-letter/buffer-size 的调整。</p><p><strong>FIN</strong><br>A control bit (finis) occupying one sequence number, which indicates that the sender will send no more data or control occupying sequence space.<br>占用一个序列号的控制位（finis），表示发送方将不再发送数据或占用序列空间的控制。</p><p><strong>fragment</strong><br>A portion of a logical unit of data, in particular an internet fragment is a portion of an internet datagram.<br>数据的逻辑单位的一部分，特别是网络片段是网络数据报的一部分。</p><p><strong>FTP</strong><br>A file transfer protocol.<br>文件传输协议。</p><p><strong>header</strong><br>Control information at the beginning of a message, segment, fragment, packet or block of data.<br>消息、段、分段、数据包或数据块开头的控制信息。</p><p><strong>host</strong><br>A computer. In particular a source or destination of messages from the point of view of the communication network.<br>一台计算机，特别是从通信网络的角度来看，是信息的来源或目的地。</p><p><strong>Identification</strong><br>An Internet Protocol field. This identifying value assigned by the sender aids in assembling the fragments of a datagram.<br>IP 协议字段，发送方分配的这个标识值有助于组装数据报的分段。</p><p><strong>IMP</strong><br>The Interface Message Processor, the packet switch of the ARPANET.<br>接口消息处理器，ARPANET 的分组交换机。</p><p><strong>internet address</strong><br>A source or destination address specific to the host level.<br>主机级别的源地址或目标地址。</p><p><strong>internet datagram</strong><br>The unit of data exchanged between an internet module and the higher level protocol together with the internet header.<br>在 Internet 模块和更高级别的协议之间交换的数据单元连同 Internet 报头。</p><p><strong>internet fragment</strong><br>A portion of the data of an internet datagram with an internet header.
带有 Internet 报头的 Internet 数据报的一部分数据。</p><p><strong>IP</strong><br>Internet Protocol.
网际互连/IP 协议。</p><p><strong>IRS</strong><br>The Initial Receive Sequence number. The first sequence number used by the sender on a connection.<br>初始接收序列号，发送方在连接上使用的第一个序列号。</p><p><strong>ISN</strong><br>The Initial Sequence Number. The first sequence number used on a connection, (either ISS or IRS). Selected on a clock based procedure.<br>初始序列号，连接上使用的第一个序列号（ISS 或 IRS），在基于时钟的程序中选择。</p><p><strong>ISS</strong><br>The Initial Send Sequence number. The first sequence number used by the sender on a connection.<br>初始发送序列号，发送方在连接上使用的第一个序列号。</p><p><strong>leader</strong><br>Control information at the beginning of a message or block of data. In particular, in the ARPANET, the control information on an ARPANET message at the host-IMP interface.<br>消息或数据块开头的控制信息， 特别是 ARPANET 中，在 主机-IMP 接口上的 ARPANET 消息上的控制信息。</p><p><strong>left sequence</strong><br>This is the next sequence number to be acknowledged by the data receiving TCP (or the lowest currently unacknowledged sequence number) and is sometimes referred to as the left edge of the send window.<br>这是数据接收 TCP 确认的下一个序列号（或当前未确认的最低序列号），有时称为发送窗口的左边缘。</p><p><strong>letter</strong><br>A logical unit of data, in particular the logical unit of data transmitted between processes via TCP.<br>数据逻辑单元，特别是通过 TCP 在进程之间传输的数据逻辑单元。</p><p><strong>local packet</strong><br>The unit of transmission within a local network.<br>本地网络中的传输单元。</p><p><strong>module</strong><br>An implementation, usually in software, of a protocol or other procedure.<br>协议或其他程序的实现，通常在软件中。</p><p><strong>MSL</strong><br>Maximum Segment Lifetime, the time a TCP segment can exist in the internetwork system. Arbitrarily defined to be 2 minutes.<br>最大段存活时间，TCP 段可以存在于网络中的时间，定义为 2 分钟。</p><p><strong>octet</strong><br>An eight bit byte.<br>一个八位字节。</p><p><strong>Options</strong><br>An Option field may contain several options, and each option may be several octets in length.<br>选项字段可能包含多个选项，每个选项的长度可能是几个字节。</p><p>The options are used primarily in testing situations; for example, to carry timestamps.<br>选项主要用于测试场景；例如，携带时间戳。</p><p>Both the Internet Protocol and TCP provide for options fields.<br>IP 协议和 TCP 协议都提供选项字段。</p><p><strong>packet</strong><br>A package of data with a header which may or may not be logically complete.<br>带有报头的数据包，在逻辑上可能完整也可能不完整。</p><p>More often a physical packaging than a logical packaging of data.<br>数据的物理打包比逻辑打包更常见。</p><p><strong>port</strong><br>The portion of a socket that specifies which logical input or output channel of a process is associated with the data.<br>套接字的一部分，它指定进程的哪个逻辑输入或输出通道与数据相关联。</p><p><strong>process</strong><br>A program in execution. A source or destination of data from the point of view of the TCP or other host-to-host protocol.<br>正在执行的程序，从 TCP 或其他主机到主机协议的角度来看，数据的来源或目的地。</p><p><strong>PSN</strong><br>A Packet Switched Network. For example, the ARPANET.<br>分组交换网络，例如，ARPANET。</p><p><strong>RCV.BS</strong><br>receive buffer size, the remote buffer size<br>接收缓冲区大小，远程缓冲区大小</p><p><strong>RCV.LBB</strong><br>receive last buffer beginning<br>接收最后一个缓冲区开始</p><p><strong>RCV.NXT</strong><br>receive next sequence number<br>接收下一个序列号</p><p><strong>RCV.UP</strong><br>receive urgent pointer<br>接收紧急指针</p><p><strong>RCV.WND</strong><br>receive window<br>接收窗口</p><p><strong>receive last buffer beginning</strong><br>This is the sequence number of the first octet of the most recent buffer.<br>这是最近缓冲区的第一个字节的序列号。</p><p>This value is use in calculating the next sequence number when a segment contains an end of letter indication.<br>当段包含信件结束指示（EOL）时，该值用于计算下一个序列号。</p><p><strong>receive next sequence number</strong><br>This is the next sequence number the local TCP is expecting to receive.<br>这是本地 TCP 期望接收的下一个序列号。</p><p><strong>receive window</strong><br>This represents the sequence numbers the local (receiving) TCP is willing to receive.<br>这表示本地（接收）TCP 可接收的序列号。</p><p>Thus, the local TCP considers that segments overlapping the range RCV.NXT to RCV.NXT + RCV.WND - 1 carry acceptable data or control.<br>因此，本地 TCP 认为与范围 RCV.NXT 到 RCV.NXT + RCV.WND - 1 重叠的段携带有效的数据或控制。</p><p>Segments containing sequence numbers entirely outside of this range are considered duplicates and discarded.<br>完全超出此范围的序列号的段被认为是重复的并被丢弃。</p><p><strong>RST</strong><br>A control bit (reset), occupying no sequence space, indicating that the receiver should delete the connection without further interaction.<br>控制位（重置），不占用序列空间，表示接收方应该删除连接而不需要进一步的交互。</p><p>The receiver can determine, based on the sequence number and acknowledgment fields of the incoming segment, whether it should honor the reset command or ignore it.<br>接收方可以根据传入段的序列号和确认字段来确定它是应该遵守重置命令还是忽略它。</p><p>In no case does receipt of a segment containing RST give rise to a RST in response.<br>在任何情况下，收到包含 RST 的段都不会产生 RST 作为响应。</p><p><strong>RTP</strong><br>Real Time Protocol: A host-to-host protocol for communication of time critical information.
实时协议，用于时间关键信息通信的主机到主机协议。</p><p><strong>Rubber EOL</strong><br>An end of letter (EOL) requiring a sequence number adjustment to align the beginning of the next letter on a buffer boundary.<br>一个信件的结束（EOL）需要调整序列号，以对准缓冲区边界上下一个信件的开始。</p><p><strong>SEG.ACK</strong><br>segment acknowledgment<br>段的确认</p><p><strong>SEG.LEN</strong><br>segment length<br>段的长度</p><p><strong>SEG.PRC</strong><br>segment precedence value<br>段的优先级</p><p><strong>SEG.SEQ</strong><br>segment sequence<br>段的序列号</p><p><strong>SEG.UP</strong><br>segment urgent pointer field<br>段的紧急指针</p><p><strong>SEG.WND</strong><br>segment window field<br>段的接收窗口</p><p><strong>segment</strong><br>A logical unit of data, in particular a TCP segment is the unit of data transfered between a pair of TCP modules.<br>逻辑数据单元，特别的是， TCP 段是在一对 TCP 模块之间传输的数据单元。</p><p><strong>segment acknowledgment</strong><br>The sequence number in the acknowledgment field of the arriving segment.<br>到达段的确认字段中的序号。</p><p><strong>segment length</strong><br>The amount of sequence number space occupied by a segment, including any controls which occupy sequence space.<br>段所占用的序列号空间的数量，包括任何占用序列空间的控制位。</p><p><strong>segment sequence</strong><br>The number in the sequence field of the arriving segment.<br>到达段的序列字段中的序列号。</p><p><strong>send last buffer beginning</strong><br>This is the sequence number of the first octet of the most recent buffer.
这是最近缓冲区的第一个字节的序列号。</p><p>This value is used in calculating the next sequence number when a segment contains an end of letter indication.
当段包含信件结束指示（EOL）时，该值用于计算下一个序列号。</p><p><strong>send sequence</strong><br>This is the next sequence number the local (sending) TCP will use on the connection.<br>这是本地（发送）TCP 将在连接上使用的下一个序列号。</p><p>It is initially selected from an initial sequence number curve (ISN) and is incremented for each octet of data or sequenced control transmitted.<br>它最初是从初始序列号曲线 (ISN) 中选择的，并针对传输的每个字节数据或顺序控制递增。</p><p><strong>send window</strong><br>This represents the sequence numbers which the remote (receiving) TCP is willing to receive.<br>这表示远程（接收）TCP 期望接收的序列号。</p><p>It is the value of the window field specified in segments from the remote (data receiving) TCP.<br>它是来自远程（数据接收）TCP 的段中指定的窗口字段的值。</p><p>The range of sequence numbers which may be emitted by a TCP lies between SND.NXT and SND.UNA + SND.WND - 1.<br>TCP 可能发出的序列号范围位于 SND.NXT 和 SND.UNA + SND.WND - 1 之间。</p><p><strong>SND.BS</strong><br>send buffer size, the local buffer size<br>发送缓冲区大小，本地缓冲区大小</p><p><strong>SND.LBB</strong><br>send last buffer beginning<br>发送最后一个缓冲区开始</p><p><strong>SND.NXT</strong><br>send sequence<br>发送序列</p><p><strong>SND.UNA</strong><br>left sequence<br>左边序列（未确认的序列）</p><p><strong>SND.UP</strong>
send urgent pointer<br>发送紧急指针</p><p><strong>SND.WL</strong><br>send sequence number at last window update<br>在最后一次窗口更新时的发送序列号</p><p><strong>SND.WND</strong><br>send window<br>发送窗口</p><p><strong>socket</strong><br>An address which specifically includes a port identifier, that is, the concatenation of an Internet Address with a TCP port.<br>包括具体端口标识符的地址，即网络地址与 TCP 端口的组合。</p><p><strong>Source Address</strong><br>The source address, usually the network and host identifiers.<br>源地址，通常是网络和主机标识符。</p><p><strong>SYN</strong><br>A control bit in the incoming segment, occupying one sequence number, used at the initiation of a connection, to indicate where the sequence numbering will start.<br>接收段中的控制位，占用一个序列号，在建立连接时使用，以指示序列号将从何处开始。</p><p><strong>TCB</strong><br>Transmission control block, the data structure that records the state of a connection.<br>传输控制块，记录连接状态的数据结构。</p><p><strong>TCB.PRC</strong><br>The precedence of the connection.<br>连接的优先级。</p><p><strong>TCP</strong><br>Transmission Control Protocol: A host-to-host protocol for reliable communication in internetwork environments.<br>传输控制协议：用于在互联网络环境中进行可靠通信的主机到主机协议。</p><p><strong>TOS</strong><br>Type of Service, an Internet Protocol field.<br>服务类型，IP 协议字段。</p><p><strong>Type of Service</strong><br>An Internet Protocol field which indicates the type of service for this internet fragment.<br>IP 协议字段，表示网络数据段的服务类型。</p><p><strong>URG</strong><br>A control bit (urgent), occupying no sequence space, used to indicate that the receiving user should be notified to do urgent processing as long as there is data to be consumed with sequence numbers less than the value indicated in the urgent pointer.<br>控制位（urgent），不占用序列空间，用于表示只要有序列号小于 urgent 指针指示值的数据需要消费，就通知接收用户做紧急处理。</p><p><strong>urgent pointer</strong><br>A control field meaningful only when the URG bit is on.<br>紧急指针，仅当 URG 标志位打开时才有意义的控制字段。</p><p>This field communicates the value of the urgent pointer which indicates the data octet associated with the sending user&rsquo;s urgent call.<br>这个字段是紧急指针的值，表示与发送用户的紧急调用相关的数据。</p><h2 id=参考文献>参考文献
<a class=anchor href=#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae>#</a></h2><p><strong>REFERENCES</strong></p><p>[1] Cerf, V., and R. Kahn, &ldquo;A Protocol for Packet Network Intercommunication,&rdquo; IEEE Transactions on Communications, Vol. COM-22, No. 5, pp 637-648, May 1974.</p><p>[2] Postel, J. (ed.), &ldquo;DOD Standard Internet Protocol,&rdquo; Defense Advanced Research Projects Agency, Information Processing Techniques Office, RFC 760, IEN 128, January 1980.</p><p>[3] Feinler, E. and J. Postel, ARPANET Protocol Handbook, Network Information Center, SRI International, Menlo Park, CA, January 1978.</p><p>[4] Dalal, Y. and C. Sunshine, &ldquo;Connection Management in Transport Protocols,&rdquo; Computer Networks, Vol. 2, No. 6, pp. 454-473, December 1978.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/zhixingxiaoke/zhixingxiaoke.github.io/commit/cba3dceb574ab64ea330a75a64db66fd328d4c11 title='Last modified by ZXEducation | March 11, 2023' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>March 11, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/zhixingxiaoke/zhixingxiaoke.github.io/edit/main/content/docs/translations/rfc761.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#封面>封面</a></li><li><a href=#目录>目录</a></li><li><a href=#前言>前言</a></li><li><a href=#介绍>介绍</a><ul><li><a href=#动机>动机</a></li><li><a href=#范围>范围</a></li><li><a href=#关于本文>关于本文</a></li><li><a href=#接口>接口</a></li><li><a href=#操作>操作</a></li></ul></li><li><a href=#基本原理>基本原理</a><ul><li><a href=#互联网系统的要素>互联网系统的要素</a></li><li><a href=#运作模式>运作模式</a></li><li><a href=#主机环境>主机环境</a></li><li><a href=#接口-1>接口</a></li><li><a href=#与其他协议的关系>与其他协议的关系</a></li><li><a href=#可靠的通信>可靠的通信</a></li><li><a href=#连接的建立和清除>连接的建立和清除</a></li><li><a href=#数据通信>数据通信</a></li><li><a href=#优先级和安全性>优先级和安全性</a></li><li><a href=#稳健性原则>稳健性原则</a></li></ul></li><li><a href=#功能规范>功能规范</a><ul><li><a href=#头部格式>头部格式</a></li><li><a href=#术语表>术语表</a></li><li><a href=#序列号>序列号</a></li><li><a href=#建立连接>建立连接</a></li><li><a href=#关闭连接>关闭连接</a></li><li><a href=#优先级和安全性-1>优先级和安全性</a></li><li><a href=#数据通信-1>数据通信</a></li><li><a href=#接口-2>接口</a></li><li><a href=#事件处理>事件处理</a></li></ul></li><li><a href=#词汇表>词汇表</a></li><li><a href=#参考文献>参考文献</a></li></ul></nav></div></aside></main></body></html>