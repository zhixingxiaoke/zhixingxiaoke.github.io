<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="RFC793 TCP 协议中文翻译 # 这是 RFC 上比较经典关于 TCP 协议标准的文档，它优化了 RFC761 提出的 TCP 规范，并在很长一段时间内作为 TCP 标准的参考文档，如果对 RFC761 感兴趣可以参考 RFC761 TCP 协议中文翻译。
原文： Transmission Control Protocol
封面 # TRANSMISSION CONTROL PROTOCOL
TCP 协议
DARPA INTERNET PROGRAM
DARPA 互联网项目
PROTOCOL SPECIFICATION
协议规范
September 1981
1981 年 9 月
prepared for
Defense Advanced Research Projects Agency
国防高级研究计划局
Information Processing Techniques Office
信息处理技术办公室
1400 Wilson Boulevard
威尔逊大道 1400 号 Arlington, Virginia 22209
弗吉尼亚州阿灵顿 22209"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="RFC793 TCP 协议"><meta property="og:description" content="RFC793 TCP 协议中文翻译 # 这是 RFC 上比较经典关于 TCP 协议标准的文档，它优化了 RFC761 提出的 TCP 规范，并在很长一段时间内作为 TCP 标准的参考文档，如果对 RFC761 感兴趣可以参考 RFC761 TCP 协议中文翻译。
原文： Transmission Control Protocol
封面 # TRANSMISSION CONTROL PROTOCOL
TCP 协议
DARPA INTERNET PROGRAM
DARPA 互联网项目
PROTOCOL SPECIFICATION
协议规范
September 1981
1981 年 9 月
prepared for
Defense Advanced Research Projects Agency
国防高级研究计划局
Information Processing Techniques Office
信息处理技术办公室
1400 Wilson Boulevard
威尔逊大道 1400 号 Arlington, Virginia 22209
弗吉尼亚州阿灵顿 22209"><meta property="og:type" content="article"><meta property="og:url" content="http://x.zhixing.io/docs/translations/rfc793/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-03-09T18:06:40+08:00"><title>RFC793 TCP 协议 | 知行小课</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.a82d7e77ceb134d151c4d7e381eeb30623fbd5a524d58c584d8716ecec0205bd.css integrity="sha256-qC1+d86xNNFRxNfjge6zBiP71aUk1YxYTYcW7OwCBb0=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.78166b9d46e23e0ea915cb6887a30b633e7bc4fad10c8b6b9f6fa532271c19ba.js integrity="sha256-eBZrnUbiPg6pFctoh6MLYz57xPrRDItrn2+lMiccGbo=" crossorigin=anonymous></script>
<script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><img src=/logo-128.png alt=Logo><span>知行小课</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><span>翻译</span><ul><li><a href=/docs/translations/rfc761/>RFC761 DoD standard TCP 协议</a></li><li><a href=/docs/translations/rfc793/ class=active>RFC793 TCP 协议</a></li></ul></li></ul><ul><li><a href=https://team.zhixing.co target=_blank rel=noopener>关于</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>RFC793 TCP 协议</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#封面>封面</a></li><li><a href=#目录>目录</a></li><li><a href=#前言>前言</a></li><li><a href=#介绍>介绍</a><ul><li><a href=#动机>动机</a></li><li><a href=#范围>范围</a></li><li><a href=#关于本文>关于本文</a></li><li><a href=#接口>接口</a></li><li><a href=#操作>操作</a></li></ul></li><li><a href=#基本原理>基本原理</a><ul><li><a href=#互联网系统的要素>互联网系统的要素</a></li><li><a href=#运作模式>运作模式</a></li><li><a href=#主机环境>主机环境</a></li><li><a href=#接口-1>接口</a></li><li><a href=#与其他协议的关系>与其他协议的关系</a></li><li><a href=#可靠的通信>可靠的通信</a></li><li><a href=#连接的建立和清除>连接的建立和清除</a></li></ul></li><li><a href=#数据通信>数据通信</a><ul><li><a href=#优先级和安全性>优先级和安全性</a></li><li><a href=#稳健性原则>稳健性原则</a></li></ul></li><li><a href=#功能规范>功能规范</a><ul><li><a href=#头部格式>头部格式</a></li><li><a href=#术语表>术语表</a></li><li><a href=#序列号>序列号</a></li><li><a href=#建立连接>建立连接</a></li><li><a href=#关闭连接>关闭连接</a></li><li><a href=#优先级和安全性-1>优先级和安全性</a></li><li><a href=#数据通信-1>数据通信</a></li><li><a href=#接口-2>接口</a></li><li><a href=#事件处理>事件处理</a></li></ul></li><li><a href=#词汇表>词汇表</a></li><li><a href=#参考文献>参考文献</a></li></ul></nav></aside></header><article class=markdown><h1 id=rfc793-tcp-协议中文翻译>RFC793 TCP 协议中文翻译
<a class=anchor href=#rfc793-tcp-%e5%8d%8f%e8%ae%ae%e4%b8%ad%e6%96%87%e7%bf%bb%e8%af%91>#</a></h1><p>这是 RFC 上比较经典关于 TCP 协议标准的文档，它优化了 RFC761 提出的 TCP 规范，并在很长一段时间内作为 TCP 标准的参考文档，如果对 RFC761 感兴趣可以参考
<a href=/docs/translations/rfc761/>RFC761 TCP 协议中文翻译</a>。</p><p>原文：
<a href=https://datatracker.ietf.org/doc/rfc793/>Transmission Control Protocol</a></p><h2 id=封面>封面
<a class=anchor href=#%e5%b0%81%e9%9d%a2>#</a></h2><div class=text-center><p>TRANSMISSION CONTROL PROTOCOL<br>TCP 协议</p><p>DARPA INTERNET PROGRAM<br>DARPA 互联网项目</p><p>PROTOCOL SPECIFICATION<br>协议规范</p><p>September 1981<br>1981 年 9 月</p><p>prepared for</p><p>Defense Advanced Research Projects Agency<br>国防高级研究计划局<br>Information Processing Techniques Office<br>信息处理技术办公室<br>1400 Wilson Boulevard<br>威尔逊大道 1400 号
Arlington, Virginia 22209<br>弗吉尼亚州阿灵顿 22209</p><p>by</p><p>Information Sciences Institute<br>信息科学研究所<br>University of Southern California<br>南加州大学<br>4676 Admiralty Way<br>4676 金钟路<br>Marina del Rey, California 90291<br>加利福尼亚州玛丽安德尔湾 90291</p></div><h2 id=目录>目录
<a class=anchor href=#%e7%9b%ae%e5%bd%95>#</a></h2><div class=text-center>TABLE OF CONTENTS</div><p>PREFACE 前言</p><p>1.INTRODUCTION 介绍<br> 1.1 Motivation 动机<br> 1.2 Scope 范围<br> 1.3 About This Document 关于本文<br> 1.4 Interfaces 接口<br> 1.5 Operation 操作</p><p>2.PHILOSOPHY 基本原理<br> 2.1 Elements of the Internetwork System 互联网系统的要素<br> 2.2 Model of Operation 运作模式<br> 2.3 The Host Environment 主机环境<br> 2.4 Interfaces 接口<br> 2.5 Relation to Other Protocols 与其他协议的关系<br> 2.6 Reliable Communication 可靠的通信<br> 2.7 Connection Establishment and Clearing 连接的建立和清除<br> 2.8 Data Communication 数据通信<br> 2.9 Precedence and Security 优先级和安全性<br> 2.10 Robustness Principle 稳健性原则</p><p>3.FUNCTIONAL SPECIFICATION 功能规范<br> 3.1 Header Format 头部格式<br> 3.2 Terminology 术语表<br> 3.3 Sequence Numbers 序列号<br> 3.4 Establishing a connection 建立连接<br> 3.5 Closing a Connection 关闭连接<br> 3.6 Precedence and Security 优先级和安全性<br> 3.7 Data Communication 数据通信<br> 3.8 Interfaces 接口<br> 3.9 Event Processing 事件处理</p><p>GLOSSARY 词汇表</p><p>REFERENCES 参考文献</p><h2 id=前言>前言
<a class=anchor href=#%e5%89%8d%e8%a8%80>#</a></h2><p><strong>PREFACE</strong></p><p>This document describes the DoD Standard Transmission Control Protocol
(TCP).<br>本文描述了美国国防部标准传输控制协议（TCP 协议）。</p><p>There have been eight earlier editions of the ARPA TCP specification on which this standard is based, and the present text draws heavily from them.<br>ARPA TCP 规范已经有 9 个早期版本，本文中的 TCP 标准是基于它们，并且很多内容都是借鉴它们的。</p><p>There have been many contributors to this work both in terms of concepts and in terms of text.<br>在概念和编纂方面，都有很多人对这项工作做出贡献。</p><p>This edition clarifies several details and removes the end-of-letter buffer-size adjustments, and redescribes the letter mechanism as a push function.<br>此版本澄清了几个细节并删除了 end-of-letter 和 buffer-size adjustments，因为 Push 功能重新描述了信件机制。</p><div class=text-right><p>Jon Postel</p><p>Editor</p></div><h2 id=介绍>介绍
<a class=anchor href=#%e4%bb%8b%e7%bb%8d>#</a></h2><p><strong>1.INTRODUCTION</strong></p><p>The Transmission Control Protocol (TCP) is intended for use as a highly reliable host-to-host protocol between hosts in packet-switched computer communication networks, and especially in interconnected systems of such networks.<br>传输控制协议（TCP）旨在作为分组交换计算机通信网络中主机之间的高度可靠的主机到主机协议使用，特别是在这种网络的互连系统中。</p><p>This document describes the functions to be performed by the Transmission Control Protocol, the program that implements it, and its interface to programs or users that require its services.<br>本文描述了传输控制协议（TCP）所要执行的功能、实现它的程序以及它与需要其服务的程序或用户的接口。</p><h3 id=动机>动机
<a class=anchor href=#%e5%8a%a8%e6%9c%ba>#</a></h3><p><strong>1.1. Motivation</strong></p><p>Computer communication systems are playing an increasingly important role in military, government, and civilian environments.<br>计算机通信系统在军事、政府和民用环境中发挥越来越重要的作用。</p><p>This document primarily focuses its attention on military computer communication requirements, especially robustness in the presence of communication unreliability and availability in the presence of congestion, but many of these problems are found in the civilian and government sector as well.<br>本文着重关注军用计算机通信系统的要求，尤其是通信不可靠时的健壮性和通讯拥堵时的可用性，但是这些问题大多也存在于民用和政府部门的计算机通讯系统中。</p><p>As strategic and tactical computer communication networks are developed and deployed, it is essential to provide means of interconnecting them and to provide standard interprocess communication protocols which can support a broad range of applications.<br>随着战略和战术计算机通信网络的开发和部署，使它们互联并提供标准的进程间通信协议变得很有必要，这样才能够让它们能够得到广泛的应用。</p><p>In anticipation of the need for such standards, the Deputy Undersecretary of Defense for Research and Engineering has declared the Transmission Control Protocol (TCP) described herein to be a basis for DoD-wide inter-process communication protocol standardization.<br>鉴于对此类标准的需求，负责研究和工程的国防部副部长宣布本文所述的传输控制协议（TCP）为美国国防部范围内进程间通信协议标准化的基础。</p><p>TCP is a connection-oriented, end-to-end reliable protocol designed to fit into a layered hierarchy of protocols which support multi-network applications.<br>TCP 是一个面向连接的、端到端的可靠协议，旨在适应支持多网络应用的协议分层结构。</p><p>The TCP provides for reliable inter-process communication between pairs of processes in host computers attached to distinct but interconnected computer communication networks.<br>TCP 协议为处于同一网络中，但是处于不同计算机中的两个进程提供可靠的进程间通信。</p><p>Very few assumptions are made as to the reliability of the communication protocols below the TCP layer.<br>TCP 层以下的通信协议被认为是不可靠的。</p><p>TCP assumes it can obtain a simple, potentially unreliable datagram service from the lower level protocols.<br>TCP 假设它可以从更低的协议中获取简单但可能是不可靠的数据包服务。</p><p>In principle, the TCP should be able to operate above a wide spectrum of communication systems ranging from hard-wired connections to packet-switched or circuit-switched networks.<br>原则上，TCP 协议应该可以在从硬线连接到分组交换或电路交换网络的广泛通信系统中运行。</p><p>TCP is based on concepts first described by Cerf and Kahn in [1].<br>TCP 协议基于 Cerf 和 Kahn 最先提出的概念。</p><p>The TCP fits into a layered protocol architecture just above a basic Internet Protocol [2] which provides a way for the TCP to send and receive variable-length segments of information enclosed in internet datagram &ldquo;envelopes&rdquo;.<br>TCP 协议是适用于一个分层协议结构，它在 IP 协议之上，IP 协议为 TCP 层提供了一种发送和接收可变长度的信息段的网络数据包的方式。</p><p>The internet datagram provides a means for addressing source and destination TCPs in different networks.<br>网络数据包提供了一种在不同网络中寻找 TCP 源地址和目的地址的方法。</p><p>The internet protocol also deals with any fragmentation or reassembly of the TCP segments required to achieve transport and delivery through multiple networks and interconnecting gateways.<br>IP 协议也处理通过多个网络和网关实现传输和交付所需的 TCP 段的任何分段或重组。</p><p>The internet protocol also carries information on the precedence, security classification and compartmentation of the TCP segments, so this information can be communicated end-to-end across multiple networks.<br>IP 协议还携带关于 TCP 段的优先级、安全分类和区段的信息，因此这些信息可以在多个网络中被端到端的进行传递。</p><div class=text-center><p>Protocol Layering<br>协议分层</p><pre tabindex=0><code>+---------------------+
|     higher-level    |
+---------------------+
|        TCP          |
+---------------------+
|  internet protocol  |
+---------------------+
|communication network|
+---------------------+
</code></pre><p>Figure 1</p></div><p>Much of this document is written in the context of TCP implementations which are co-resident with higher level protocols in the host computer.<br>本文的大部分内容是在 TCP 实现的背景下编写的，这些实现与主机中更高级别的协议共存。</p><p>Some computer systems will be connected to networks via front-end computers which house the TCP and internet protocol layers, as well as network specific software.
有些计算机系统将会通过包含 TCP 和 IP 协议层以及网络软件的前置机连接到网络。</p><p>The TCP specification describes an interface to the higher level protocols which appears to be implementable even for the front-end case, as long as a suitable host-to-front end protocol is implemented.<br>TCP 规范描述了一个到更高层协议的接口，只要实现了合适的主机到前端的协议，即使对于前端情况，该接口似乎也是可实现的。</p><h3 id=范围>范围
<a class=anchor href=#%e8%8c%83%e5%9b%b4>#</a></h3><p><strong>1.2. Scope</strong></p><p>The TCP is intended to provide a reliable process-to-process communication service in a multinetwork environment.<br>TCP 旨在在多网络环境中提供可靠的进程到进程通信服务。</p><p>The TCP is intended to be a host-to-host protocol in common use in multiple networks.<br>TCP 旨在成为多网络环境中常用的主机到主机协议。</p><h3 id=关于本文>关于本文
<a class=anchor href=#%e5%85%b3%e4%ba%8e%e6%9c%ac%e6%96%87>#</a></h3><p><strong>1.3. About this Document</strong></p><p>This document represents a specification of the behavior required of any TCP implementation, both in its interactions with higher level protocols and in its interactions with other TCPs.<br>本文描述了所有 TCP 实现所需的行为规范，无论是与其它更高级的协议交互还是与其它 TCP 的交互。</p><p>The rest of this section offers a very brief view of the protocol interfaces and operation.<br>本节的其余部分非常简要地介绍了协议接口和操作。</p><p>Section 2 summarizes the philosophical basis for the TCP design.<br>第 2 节概述了 TCP 设计的哲学基础。</p><p>Section 3 offers both a detailed description of the actions required of TCP when various events occur (arrival of new segments, user calls, errors, etc.) and the details of the formats of TCP segments.<br>第 3 节详细描述了当各种事件发生时（新段的到来、用户呼叫、错误等）TCP 所需的行动，以及 TCP 段格式的细节。</p><h3 id=接口>接口
<a class=anchor href=#%e6%8e%a5%e5%8f%a3>#</a></h3><p><strong>1.4. Interfaces</strong></p><p>The TCP interfaces on one side to user or application processes and on the other side to a lower level protocol such as Internet Protocol.<br>TCP 一端连接到用户或应用程序进程，另一端连接到较低级别的协议，比如 IP 协议。</p><p>The interface between an application process and the TCP is illustrated in reasonable detail.<br>相当详细地说明了应用程序进程和 TCP 之间的接口。</p><p>This interface consists of a set of calls much like the calls an operating system provides to an application process for manipulating files.<br>这个接口由一组调用组成，很像操作系统为操作文件的应用进程提供的调用。</p><p>For example, there are calls to open and close connections and to send and receive letters on established connections.<br>例如，有调用打开和关闭连接，以及在已建立的连接上发送和接收数据。</p><p>It is also expected that the TCP can asynchronously communicate with application programs.<br>还期望 TCP 能够与应用程序进行异步通信。</p><p>Although considerable freedom is permitted to TCP implementors to design interfaces which are appropriate to a particular operating system environment, a minimum functionality is required at the TCP/user interface for any valid implementation.<br>尽管允许 TCP 实现者有相当大的自由来设计适合特定操作系统环境的接口，但对于任何有效的实现，TCP/user 接口都需要最少的功能。</p><p>The interface between TCP and lower level protocol is essentially unspecified except that it is assumed there is a mechanism whereby the two levels can asynchronously pass information to each other.<br>除了假设两个级别可以相互异步传递信息的机制之外，基本上没有指定 TCP 和较低级别协议之间的接口。</p><p>Typically, one expects the lower level protocol to specify this interface.<br>通常情况下，是由低级别的协议指定这个接口。</p><p>TCP is designed to work in a very general environment of interconnected networks.<br>TCP 被设计为可以在互连网络的非常普遍的环境中工作。</p><p>The lower level protocol which is assumed throughout this document is the Internet Protocol [2].<br>本文中假定的较低级别协议是 IP 协议。</p><h3 id=操作>操作
<a class=anchor href=#%e6%93%8d%e4%bd%9c>#</a></h3><p><strong>1.5. Operation</strong></p><p>As noted above, the primary purpose of the TCP is to provide reliable, securable logical circuit or connection service between pairs of processes.<br>如上所述，TCP 的主要目的是在进程对之间提供可靠、安全的逻辑线路或连接服务。</p><p>To provide this service on top of a less reliable internet communication system requires facilities in the following areas:<br>要在不太可靠的互联网通信系统之上提供这种服务，需要在以下方面的设施：</p><ul><li>Basic Data Transfer 基础数据传输</li><li>Reliability 可靠性</li><li>Flow Control 流量控制</li><li>Multiplexing 多路复用</li><li>Connections 连接</li><li>Precedence and Security 优先级和安全性</li></ul><p>The basic operation of the TCP in each of these areas is described in the following paragraphs.<br>以下段落描述了 TCP 在每个方面的基本操作。</p><p><strong>Basic Data Transfer:</strong><br><strong>基础数据传输</strong></p><p>The TCP is able to transfer a continuous stream of octets in each direction between its users by packaging some number of octets into segments for transmission through the internet system.<br>TCP 能够在其用户之间的每个方向传输连续的字节流，将一些字节数据打包成段，通过互联网传输。</p><p>In general, the TCPs decide when to block and forward data at their own convenience.<br>一般情况下，TCP 根据自己的情况来决定阻止和转发数据。</p><p>Sometimes users need to be sure that all the data they have submitted to the TCP has been transmitted.<br>有时，用户需要确定他们提交给 TCP 的所有数据都已传输。</p><p>For this purpose a push function is defined.<br>为此，定义了推送功能。</p><p>To assure that data submitted to a TCP is actually transmitted the sending user indicates that it should be pushed through to the receiving user.<br>为了确保提交给 TCP 的数据确实被传输，发送用户表明应该将其推送到接收用户。</p><p>A push causes the TCPs to promptly forward and deliver data up to that point to the receiver.<br>推送会使 TCP 迅速转发并将该点之前的数据传递给接收方。</p><p>The exact push point might not be visible to the receiving user and the push function does not supply a record boundary marker.<br>确切的推送点对接收用户来说可能不可见，而且推送功能也不提供记录的边界标记。</p><p><strong>Reliability:</strong><br><strong>可靠性</strong></p><p>The TCP must recover from data that is damaged, lost, duplicated, or delivered out of order by the internet communication system.<br>TCP 必须从因特网通信系统损坏、丢失、复制或乱序传送的数据中恢复。</p><p>This is achieved by assigning a sequence number to each octet transmitted, and requiring a positive acknowledgment (ACK) from the
receiving TCP.<br>这是通过给传输的每个字节分配一个序列号，并要求接收的 TCP 回复一个确认（ACK）来实现的。</p><p>If the ACK is not received within a timeout interval, the data is retransmitted.<br>如果在规定的时间隔内没有收到 ACK，则重传数据。</p><p>At the receiver, the sequence numbers are used to correctly order segments that may be received out of order and to eliminate duplicates.<br>在接收方，序列号用来按顺序排列可能接收到的乱序的片段，并消除重复的片段。</p><p>Damage is handled by adding a checksum to each segment transmitted, checking it at the receiver, and discarding damaged segments.<br>通过在传输的每个片段上添加一个校验和，在接收方进行检查，并丢弃损坏的片段。</p><p>As long as the TCPs continue to function properly and the internet system does not become completely partitioned, no transmission errors will affect the users.<br>只要 TCP 各端继续正常运行，网络系统也没有断开，传输错误就不会影响到用户。</p><p>TCP recovers from internet communication system errors.<br>TCP 从互联网通信错误中恢复。</p><p><strong>Flow Control:</strong><br><strong>流量控制</strong></p><p>TCP provides a means for the receiver to govern the amount of data sent by the sender.<br>TCP 为接收方提供了一种方法来管理发送方发送的数据量。</p><p>This is achieved by returning a &ldquo;window&rdquo; with every ACK indicating a range of acceptable sequence numbers beyond the last segment successfully received.<br>这是通过在每个 ACK 中返回一个 &ldquo;窗口&rdquo; 来实现的，窗口表示在成功接收的最后一个片段之外的可接受的序列号范围。</p><p>The window indicates an allowed number of octets that the sender may transmit before receiving further permission.<br>该窗口表示发送方在收到进一步确认之前可以传输的字节数量。</p><p><strong>Multiplexing:</strong><br><strong>多路复用</strong></p><p>To allow for many processes within a single Host to use TCP communication facilities simultaneously, the TCP provides a set of addresses or ports within each host.<br>为了允许单个主机内的多个进程同时使用 TCP 进行通信，TCP 在每个主机内提供了一组地址或端口。</p><p>Concatenated with the network and host addresses from the internet communication layer, this forms a socket.<br>从互联网通信层连接网络和主机地址，形成一个套接字。</p><p>A pair of sockets uniquely identifies each connection.<br>一对套接字唯一标识每个连接。</p><p>That is, a socket may be simultaneously used in multiple connections.<br>也就是说，一个套接字可以同时在多个连接中使用。</p><p>The binding of ports to processes is handled independently by each Host.<br>每个主机单独处理端口与进程的绑定。</p><p>However, it proves useful to attach frequently used processes (e.g., a &ldquo;logger&rdquo; or timesharing service) to fixed sockets which are made known to the public.<br>然而，事实证明，将常用的进程（例如，&ldquo;logger"或 timesharing 服务）附加到固定的套接字上会很有用。</p><p>These services can then be accessed through the known addresses. Establishing and learning the port addresses of other processes may involve more dynamic mechanisms.<br>通过已知地址就可以访问这些服务，建立和学习其他进程的端口地址可能涉及更多的动态机制。</p><p>Connections:<br>连接</p><p>The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream.<br>上述的可靠性和流量控制机制要求 TCP 初始化和维护每个数据流的某些状态信息。</p><p>The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.<br>这些信息（包括套接字、序列号和窗口大小）的组合称为连接。</p><p>Each connection is uniquely specified by a pair of sockets identifying its two sides.<br>每个连接都由标识其两端的一对套接字唯一指定。</p><p>When two processes wish to communicate, their TCP&rsquo;s must first establish a connection (initialize the status information on each side).<br>当两个进程想要进行通信时，它们必须先建立 TCP 连接（初始化每一端的状态信息）。</p><p>When their communication is complete, the connection is terminated or closed to free the resources for other uses.<br>当他们的通信完成后，连接被终止或关闭，以释放资源用于其他用途。</p><p>Since connections must be established between unreliable hosts and over the unreliable internet communication system, a handshake mechanism with clock-based sequence numbers is used to avoid erroneous initialization of connections.<br>由于必须在不可靠的主机之间和通过不可靠的互联网通信系统建立连接，因此使用了基于时钟序列号的握手机制，以避免连接的错误初始化。</p><p><strong>Precedence and Security:</strong><br><strong>优先级和安全性</strong></p><p>The users of TCP may indicate the security and precedence of their communication.<br>TCP 的用户可以指定其通信的安全性和优先级。</p><p>Provision is made for default values to be used when these features are not needed.<br>规定在不需要这些功能时，会使用默认值。</p><h2 id=基本原理>基本原理
<a class=anchor href=#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86>#</a></h2><p><strong>2.PHILOSOPHY</strong></p><h3 id=互联网系统的要素>互联网系统的要素
<a class=anchor href=#%e4%ba%92%e8%81%94%e7%bd%91%e7%b3%bb%e7%bb%9f%e7%9a%84%e8%a6%81%e7%b4%a0>#</a></h3><p><strong>2.1. Elements of the Internetwork System</strong></p><p>The internetwork environment consists of hosts connected to networks which are in turn interconnected via gateways.<br>互联网络环境由连接到网络的主机组成，这些网络又通过网关互连。</p><p>It is assumed here that the networks may be either local networks (e.g., the ETHERNET) or large networks (e.g., the ARPANET), but in any case are based on packet switching technology.<br>这里假设网络可以是本地网络（如 ETHERNET）或大型网络（如 ARPANET），但在任何情况下都是基于分组交换技术。</p><p>The active agents that produce and consume messages are processes.<br>进程是产生和消费消息的活跃元素。</p><p>Various levels of protocols in the networks, the gateways, and the hosts support an interprocess communication system that provides two-way data flow on logical connections between process ports.<br>网络、网关和主机中的各种级别的协议支持进程间通信系统，该系统在进程端口之间的逻辑连接上提供双向数据流。</p><p>The term packet is used generically here to mean the data of one transaction between a host and a packet switch.<br>术语 &ldquo;数据包&rdquo; 在这里泛指主机和数据包交换机之间的一次事务处理数据。</p><p>The format of data blocks exchanged between the packet switches in a network will generally not be of concern to us.<br>我们通常不会关心网络中分组交换机之间交换的数据块的格式。</p><p>Hosts are computers attached to a network, and from the communication network&rsquo;s point of view, are the sources and destinations of packets.<br>主机是连接到网络的计算机，从通信网络的角度来看，主机是数据包的来源和目的地。</p><p>Processes are viewed as the active elements in host computers (in accordance with the fairly common definition of a process as a program in execution).<br>进程被看作是主机中的活跃元素（根据相当普遍的定义，进程是一个正在执行的程序）。</p><p>Even terminals and files or other I/O devices are viewed as communicating with each other through the use of processes.<br>甚至终端和文件或其他 I/O 设备也被看作是通过使用进程来相互通信的。</p><p>Thus, all communication is viewed as inter-process communication.<br>因此，所有的通信都被看作是进程间的通信。</p><p>Since a process may need to distinguish among several communication streams between itself and another process (or processes), we imagine that each process may have a number of ports through which it communicates with the ports of other processes.<br>因为一个进程可能需要区分它和另一个进程(或多个进程)之间的几个通信流，所以我们假设每个进程可能有许多端口，它通过这些端口与其他进程的端口进行通信。</p><h3 id=运作模式>运作模式
<a class=anchor href=#%e8%bf%90%e4%bd%9c%e6%a8%a1%e5%bc%8f>#</a></h3><p><strong>2.2. Model of Operation</strong></p><p>Processes transmit data by calling on the TCP and passing buffers of data as arguments.<br>进程通过调用 TCP 并将数据缓冲区作为参数来传输数据。</p><p>The TCP packages the data from these buffers into segments and calls on the internet module to transmit each segment to the destination TCP.<br>TCP 将这些缓冲区中的数据打包成 TCP 段，并调用网络模块将每个 TCP 段传输到目的主机的 TCP。</p><p>The receiving TCP places the data from a segment into the receiving user&rsquo;s buffer and notifies the receiving user.<br>接收 TCP 将 TCP 段中的数据放入接收用户的缓冲区，并通知接收用户。</p><p>The TCPs include control information in the segments which they use to ensure reliable ordered data transmission.<br>TCP 把控制信息放在 TCP 段中，它们用于确保可靠有序的数据传输。</p><p>The model of internet communication is that there is an internet protocol module associated with each TCP which provides an interface to the local network.<br>互联网通信的模型是有一个互联网协议模块与每个 TCP 相关联，它提供到本地网络的接口。</p><p>This internet module packages TCP segments inside internet datagrams and routes these datagrams to a destination internet module or intermediate gateway.<br>这个互联网模块将 TCP 段封装在网络数据报中，并将这些数据报路由到目标互联网模块或中间网关。</p><p>To transmit the datagram through the local network, it is embedded in a local network packet.<br>为了通过本地网络传输数据报，它被嵌入到本地网络数据包中。</p><p>The packet switches may perform further packaging, fragmentation, or other operations to achieve the delivery of the local packet to the destination internet module.<br>分组交换机可以执行进一步的打包、分段或其他操作，以实现将本地数据包发送到目的地互联网模块。</p><p>At a gateway between networks, the internet datagram is &ldquo;unwrapped&rdquo; from its local packet and examined to determine through which network the internet datagram should travel next.<br>在网关时，网络数据报从其本地数据包中 &ldquo;解包&rdquo; 并进行检查并决定该网络数据报接下来应通过哪个网络传输。</p><p>The internet datagram is then &ldquo;wrapped&rdquo; in a local packet suitable to the next network and routed to the next gateway, or to the final destination.<br>然后，网络数据报在适合于下一个网络的本地数据包中被 &ldquo;包装&rdquo; ，并被路由到下一个网关或最终目的地。</p><p>A gateway is permitted to break up an internet datagram into smaller internet datagram fragments if this is necessary for transmission through the next network.<br>如果有必要的话，允许网关将网络数据报分解成更小的网络数据报片段，再传输到下一个网络。</p><p>To do this, the gateway produces a set of internet datagrams; each carrying a fragment.<br>为此，网关生成一组网络数据报；每个数据包携带一个片段。</p><p>Fragments may be broken into smaller ones at intermediate gateways.<br>数据包片段可以在中间网关处分解成更小的片段。</p><p>The internet datagram fragment format is designed so that the destination internet module can reassemble fragments into internet datagrams.<br>网络数据报片段格式的设计使得目的地的互联网模块可以将片段重组为网络数据报。</p><p>A destination internet module unwraps the segment from the datagram (after reassembling the datagram, if necessary) and passes it to the destination TCP.<br>目的地互联网模块从数据报中解开 TCP 段(如果需要，在重组数据报之后)，并将其传递给 TCP。</p><p>This simple model of the operation glosses over many details.<br>这个简单的运作模式掩盖了许多细节。</p><p>One important feature is the type of service.<br>一个重要的特征是服务的类型。</p><p>This provides information to the gateway (or internet module) to guide it in selecting the service parameters to be used in traversing the next network.<br>这为网关（或互联网模块）提供了信息，指导它选择遍历下一个网络时使用的服务参数。</p><p>Included in the type of service information is the precedence of the datagram.<br>服务类型信息中包括数据报的优先级。</p><p>Datagrams may also carry security information to permit host and gateways that operate in multilevel secure environments to properly segregate datagrams for security considerations.<br>数据报还可以携带安全信息，使得在多级安全环境中操作的主机和网关出于安全考虑可以适当地分离数据报。</p><h3 id=主机环境>主机环境
<a class=anchor href=#%e4%b8%bb%e6%9c%ba%e7%8e%af%e5%a2%83>#</a></h3><p><strong>2.3. The Host Environment</strong></p><p>The TCP is assumed to be a module in a time sharing operating system.<br>假定 TCP 是分时操作系统中的一个模块。</p><p>The users access the TCP much like they would access the file system.<br>用户访问 TCP 就像他们访问文件系统一样。</p><p>The TCP may call on other operating system functions, for example, to manage data structures.<br>TCP 可以调用其他操作系统的功能，例如，管理数据结构。</p><p>The actual interface to the network is assumed to be controlled by a device driver module.<br>假设到网络的实际接口由设备驱动模块控制。</p><p>The TCP does not call on the network device driver directly, but rather calls on the internet datagram protocol module which may in turn call on the device driver.<br>TCP 不直接调用网络设备驱动程序，而是调用网络数据报协议模块，而后者又可能调用设备驱动程序。</p><p>The mechanisms of TCP do not preclude implementation of the TCP in a front-end processor.<br>TCP 的机制并不排除在前端处理器中实现 TCP。</p><p>However, in such an implementation, a host-to-front-end protocol must provide the functionality to support the type of TCP-user interface described in this document.
然而，在这样的实现中，主机到前端协议必须提供支持本文描述的 TCP-用户接口类型的功能。</p><h3 id=接口-1>接口
<a class=anchor href=#%e6%8e%a5%e5%8f%a3-1>#</a></h3><p><strong>2.4. Interfaces</strong></p><p>The TCP/user interface provides for calls made by the user on the TCP to OPEN or CLOSE a connection, to SEND or RECEIVE data, or to obtain STATUS about a connection.<br>TCP/用户接口提供了用户控制 TCP 的调用，用来打开或关闭连接、发送或接收数据或获取有关连接的状态。</p><p>These calls are like other calls from user programs on the operating system, for example, the calls to open, read from, and close a file.<br>这些调用类似于操作系统上用户程序的其他调用，例如打开、读取和关闭文件的调用。</p><p>The TCP/internet interface provides calls to send and receive datagrams addressed to TCP modules in hosts anywhere in the internet system.<br>TCP/互联网接口提供了调用，用来发送和接收寻址到互联网系统中任何地方的主机中的 TCP 模块的数据报。</p><p>These calls have parameters for passing the address, type of service, precedence, security, and other control information.<br>这些调用有参数用于传递地址、服务类型、优先级、安全性和其他控制信息。</p><h3 id=与其他协议的关系>与其他协议的关系
<a class=anchor href=#%e4%b8%8e%e5%85%b6%e4%bb%96%e5%8d%8f%e8%ae%ae%e7%9a%84%e5%85%b3%e7%b3%bb>#</a></h3><p><strong>2.5. Relation to Other Protocols</strong></p><p>The following diagram illustrates the place of the TCP in the protocol hierarchy:<br>下图说明了 TCP 在协议层次结构中的位置</p><pre tabindex=0><code>       +------+ +-----+ +-----+       +-----+
       |Telnet| | FTP | |Voice|  ...  |     |  Application Level
       +------+ +-----+ +-----+       +-----+
             |   |         |             |
            +-----+     +-----+       +-----+
            | TCP |     | RTP |  ...  |     |  Host Level
            +-----+     +-----+       +-----+
               |           |             |
            +-------------------------------+
            |    Internet Protocol &amp; ICMP   |  Gateway Level
            +-------------------------------+
                           |
              +---------------------------+
              |   Local Network Protocol  |    Network Level
              +---------------------------+
</code></pre><div class=text-center><p>Protocol Relationships<br>协议关系</p><p>Figure 2</p></div><p>It is expected that the TCP will be able to support higher level protocols efficiently.<br>预计 TCP 将能够有效地支持更高级别的协议。</p><p>It should be easy to interface higher level protocols like the ARPANET Telnet [3] or AUTODIN II THP to the TCP.<br>应该很容易将更高层次的协议如 ARPANET Telnet[3]或 AUTODIN II THP 连接到 TCP。</p><h3 id=可靠的通信>可靠的通信
<a class=anchor href=#%e5%8f%af%e9%9d%a0%e7%9a%84%e9%80%9a%e4%bf%a1>#</a></h3><p><strong>2.6. Reliable Communication</strong></p><p>A stream of data sent on a TCP connection is delivered reliably and in order at the destination.<br>通过 TCP 连接上发送的数据流在目的地可靠且有序地传送。</p><p>Transmission is made reliable via the use of sequence numbers and acknowledgments.<br>通过使用序列号和确认机制，使得传输变得可靠。</p><p>Conceptually, each octet of data is assigned a sequence number.<br>从概念上讲，每个字节的数据都分配有一个序列号。</p><p>The sequence number of the first octet of data in a segment is the sequence number transmitted with that segment and is called the segment sequence number.<br>TCP 段中数据的第一个字节的序号是与该 TCP 段一起传输的序列号，称为 segment sequence number。</p><p>Segments also carry an acknowledgment number which is the sequence number of the next expected data octet of transmissions in the reverse direction.<br>TCP 段还携带一个确认号码，这是期望对方传输的下一个字节数据包的序列号。</p><p>When the TCP transmits a segment, it puts a copy on a retransmission queue and starts a timer; when the acknowledgment for that data is received, the segment is deleted from the queue.<br>当 TCP 传输一个 TCP 段时，它会将 TCP 段的一个副本放在重传队列中，并启动一个计时器；当收到该数据的确认时，则将该 TCP 段将从重传队列中删除。</p><p>If the acknowledgment is not received before the timer runs out, the segment is retransmitted.<br>如果在定时器结束之前没有收到确认，则重传该 TCP 段。</p><p>An acknowledgment by TCP does not guarantee that the data has been delivered to the end user, but only that the receiving TCP has taken the responsibility to do so.<br>TCP 的确认并不保证数据已经交付给最终用户，而只是表明接收的 TCP 已经接收了这份数据。</p><p>To govern the flow of data into a TCP, a flow control mechanism is employed.<br>为了管理进入 TCP 的数据流，采用了流量控制机制。</p><p>The the data receiving TCP reports a &ldquo;window&rdquo; to the sending TCP.<br>数据接收 TCP 向发送 TCP 报告一个窗口。</p><p>This window specifies the number of octets, starting with the acknowledgment number that the data receiving TCP is currently prepared to receive.<br>该窗口指定字节的数量，从数据接收的 TCP 目前准备接收的确认号码开始。</p><h3 id=连接的建立和清除>连接的建立和清除
<a class=anchor href=#%e8%bf%9e%e6%8e%a5%e7%9a%84%e5%bb%ba%e7%ab%8b%e5%92%8c%e6%b8%85%e9%99%a4>#</a></h3><p><strong>2.7. Connection Establishment and Clearing</strong></p><p>To identify the separate data streams that a TCP may handle, the TCP provides a port identifier.<br>为了识别 TCP 可以处理的单独数据流，TCP 提供了端口标识符。</p><p>Since port identifiers are selected independently by each operating system, TCP, or user, they might not be unique.<br>由于端口标识符是由每个操作系统、TCP 或用户独立选择的，它们可能不是唯一的。</p><p>To provide for unique addresses at each TCP, we concatenate an internet address identifying the TCP with a port identifier to create a socket which will be unique throughout all networks connected together.<br>为了给每个 TCP 提供唯一的地址，我们将识别 TCP 的网络地址与端口标识符连接起来，以创建一个套接字，该套接字在所有连接在一起的网络中是唯一的。</p><p>A connection is fully specified by the pair of sockets at the ends.<br>一个连接完全由两端的一对套接字指定。</p><p>A local socket may participate in many connections to different foreign sockets.<br>一个本地套接字可以参与许多与不同的外部套接字的连接。</p><p>A connection can be used to carry data in both directions, that is, it is &ldquo;full duplex&rdquo;.<br>一个连接可以用来双向传输数据，也就是说，它是 &ldquo;全双工&rdquo;。</p><p>TCPs are free to associate ports with processes however they choose.<br>TCP 可以自由地将端口与进程联系起来，不管他们如何选择。</p><p>However, several basic concepts seem necessary in any implementation.<br>然而，在任何实现中，有几个基本概念几乎都是必须的。</p><p>There must be well-known sockets which the TCP associates only with the &ldquo;appropriate&rdquo; processes by some means.<br>有一些有名的套接字，TCP 通过某种方式将其与 &ldquo;适当&rdquo; 的进程联系起来。</p><p>We envision that processes may &ldquo;own&rdquo; ports, and that processes can only initiate connections on the ports they own.<br>我们设想进程可以 &ldquo;拥有&rdquo; 端口，而且这些进程只能在它们拥有的端口上发起连接。</p><p>(Means for implementing ownership is a local issue, but we envision a Request Port user command, or a method of uniquely allocating a group of ports to a given process, e.g., by associating the high order bits of a port name with a given process.)<br>实现所有权的方法是一个局部问题，但是我们设想了一个请求端口的用户命令，或者一个将一组端口唯一地分配给一个给定进程的方法，例如，通过将端口名称的高位 bit 与一个给定进程联系起来。</p><p>A connection is specified in the OPEN call by the local port and foreign socket arguments.<br>在 OPEN 调用中，通过本地端口和外部套接字参数指定一个连接。</p><p>In return, the TCP supplies a (short) local connection name by which the user refers to the connection in subsequent calls.<br>TCP 提供了一个（简短的）本地连接名称作为返回，用户在后续的调用中用这个名称来指代连接。</p><p>There are several things that must be remembered about a connection.<br>关于连接，必须记住几件事。</p><p>To store this information we imagine that there is a data structure called a Transmission Control Block (TCB).<br>为了存储这些信息，我们设想有一个叫做传输控制块（TCB）的数据结构。</p><p>One implementation strategy would have the local connection name be a pointer to the TCB for this connection.<br>一种实现策略是将本地连接名称作为指向该连接的 TCB 的指针。</p><p>The OPEN call also specifies whether the connection establishment is to be actively pursued, or to be passively waited for.<br>OPEN 调用还指定是主动连接建立，还是被动等待建立连接。</p><p>A passive OPEN request means that the process wants to accept incoming connection requests rather than attempting to initiate a connection.<br>被动 OPEN 请求意味着进程想要接受进来的连接请求，而不是尝试启动连接。</p><p>Often the process requesting a passive OPEN will accept a connection request from any caller.<br>被动 OPEN 的进程通常会接受来自任何调用者的连接请求。</p><p>In this case a foreign socket of all zeros is used to denote an unspecified socket.<br>在这种情况下，使用全 0 的外部套接字来表示未指定的套接字。</p><p>Unspecified foreign sockets are allowed only on passive OPENs.<br>未指定的外部套接字只允许在被动 OPEN 中使用。</p><p>A service process that wished to provide services for unknown other processes could issue a passive OPEN request with an unspecified foreign socket.<br>想要为未知的其他进程提供服务的服务进程可以使用未指定的外部套接字发起被动 OPEN 请求。</p><p>Then a connection could be made with any process that requested a connection to this local socket.<br>然后就可以与请求连接到此本地套接字的任何进程建立连接。</p><p>It would help if this local socket were known to be associated with this service.<br>如果已知这个本地套接字与此服务相关联，将会非常有用。</p><p>Well-known sockets are a convenient mechanism for a priori associating a socket address with a standard service.<br>well-known sockets 是一种便利的机制，可以先验地将套接字地址与标准服务联系起来。</p><p>For instance, the &ldquo;Telnet-Server&rdquo; process might be permanently assigned to a particular socket, and other sockets might be reserved for File Transfer, Remote Job Entry, Text Generator, Echoer, and Sink processes (the last three being for test purposes).<br>例如，&ldquo;Telnet-Server&rdquo; 进程可能被永久分配给一个特定的套接字，而其他套接字可能被保留用于文件传输、远程作业输入、文本生成器、回声器和接收器进程（最后三个用于测试目的）。</p><p>A socket address might be reserved for access to a &ldquo;Look-Up&rdquo; service which would return the specific socket at which a newly created service would be provided.<br>可以为访问 &ldquo;查找&rdquo; 服务保留套接字地址，该服务可以返回新创建服务的特定套接字。</p><p>The concept of a well-known socket is part of the TCP specification, but the assignment of sockets to services is outside this specification. (See [4].)
well-known socket 的概念是 TCP 规范的一部分，但将套接字分配给服务超出了该规范。(查看[4]。)</p><p>Processes can issue passive OPENs and wait for matching calls from other processes and be informed by the TCP when connections have been established.<br>进程可以发起被动的 OPEN，等待来自其他进程的相应调用，并在连接建立后由 TCP 通知。</p><p>Two processes which issue calls to each other at the same time are correctly connected.<br>两个在同一时间相互发出调用的进程可以正确建立连接。</p><p>This flexibility is critical for the support of distributed computing in which components act asynchronously with respect to each other.<br>这种灵活性对于支持分布式计算至关重要，在分布式计算中，组件彼此异步地工作。</p><p>There are two principal cases for matching the sockets in the local passive OPENs and an foreign active OPENs.<br>匹配本地被动 OPEN 和外部主动 OPEN 中的套接字有两种主要情况。</p><p>In the first case, the local passive OPENs has fully specified the foreign socket.<br>在第一种情况下，本地被动 OPEN 已经明确指定了外部套接字。</p><p>In this case, the match must be exact.<br>在这种情况下，匹配是精确的。</p><p>In the second case, the local passive OPENs has left the foreign socket unspecified.<br>在第二种情况下，本地被动 OPEN 未指定外部套接字。</p><p>In this case, any foreign socket is acceptable as long as the local sockets match.<br>在这种情况下，只要本地套接字匹配，任何外来套接字都是可以接受的。</p><p>Other possibilities include partially restricted matches.<br>其他可能包括部分受限匹配。</p><p>If there are several pending passive OPENs (recorded in TCBs) with the same local socket, an foreign active OPEN will be matched to a TCB with the specific foreign socket in the foreign active OPEN, if such a TCB exists, before selecting a TCB with an unspecified foreign socket.<br>如果有多个等待中的被动 OPEN（记录在 TCB 中）具有相同的本地套接字，则在选择具有未指定的外部套接字的 TCB 之前，外部活动 OPEN 将与拥有其特定外部套接字的 TCB 匹配（如果存在这样的 TCB）。</p><p>The procedures to establish connections utilize the synchronize (SYN) control flag and involves an exchange of three messages.<br>建立连接的过程使用同步 (SYN) 控制标志并涉及三个消息的交换。</p><p>This exchange has been termed a three-way hand shake [3].<br>这种交换被称为三次握手。</p><p>A connection is initiated by the rendezvous of an arriving segment containing a SYN and a waiting TCB entry created by a user OPEN command.<br>通过包含 SYN 的到达段和一个由用户 OPEN 命令创建的等待的 TCB 条目的会合而发起连接。</p><p>The matching of local and foreign sockets determines when a connection has been initiated.<br>本地套接字和外部套接字的匹配决定了连接何时开始。</p><p>The connection becomes &ldquo;established&rdquo; when sequence numbers have been synchronized in both directions.<br>当序列号在连接双向同步时，连接就建立了。</p><p>The clearing of a connection also involves the exchange of segments, in this case carrying the FIN control flag.<br>连接的清除也涉及到段的交换，在这种情况下，带有 FIN 控制标志。</p><h2 id=数据通信>数据通信
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e9%80%9a%e4%bf%a1>#</a></h2><p><strong>2.8. Data Communication</strong></p><p>The data that flows on a connection may be thought of as a stream of octets.<br>在一个连接上流动的数据可以被认为是一个字节流。</p><p>The sending user indicates in each SEND call whether the data in that call (and any preceeding calls) should be immediately pushed through to the receiving user by the setting of the PUSH flag.<br>发送用户在每个 SEND 调用中指示是否应通过设置 PUSH 标志立即将该调用（以及任何先前的调用）中的数据推送给接收用户。</p><p>A sending TCP is allowed to collect data from the sending user and to send that data in segments at its own convenience, until the push function is signaled, then it must send all unsent data.
发送 TCP 可以从发送用户那里收集数据，并在自己合适的时候分片发送这些数据，在发出 PUSH 的信号时，它必须发送所有未发送的数据。</p><p>When a receiving TCP sees the PUSH flag, it must not wait for more data from the sending TCP before passing the data to the receiving process.<br>当接收 TCP 看到 PUSH 标志时，在将数据传递给接收进程之前，它不能等待来自发送 TCP 的更多数据。</p><p>There is no necessary relationship between push functions and segment boundaries.<br>推送功能和段边界之间没有必然联系。</p><p>The data in any particular segment may be the result of a single SEND call, in whole or part, or of multiple SEND calls.<br>任何特定段中的数据可能是单个 SEND 调用（全部或部分）或多个 SEND 调用的结果。</p><p>The purpose of push function and the PUSH flag is to push data through from the sending user to the receiving user.<br>推送功能和 PUSH 标志的目的是将数据从发送用户推送到接收用户。</p><p>It does not provide a record service.<br>它不提供记录服务。</p><p>There is a coupling between the push function and the use of buffers of data that cross the TCP/user interface.<br>推送功能与跨 TCP/用户接口的数据缓冲区的使用之间存在耦合。</p><p>Each time a PUSH flag is associated with data placed into the receiving user&rsquo;s buffer, the buffer is returned to the user for processing even if the buffer is not filled.<br>每次 PUSH 标志与放入接收用户缓冲区的数据相关联时，即使缓冲区没有被填满，也会返回给用户进行处理。</p><p>If data arrives that fills the user&rsquo;s buffer before a PUSH is seen, the data is passed to the user in buffer size units.<br>如果在收到 PUSH 之前到达的数据填满了用户的缓冲区，则数据将以缓冲区大小为单位传递给用户。</p><p>TCP also provides a means to communicate to the receiver of data that at some point further along in the data stream than the receiver is currently reading there is urgent data.<br>TCP 还提供了一种方法来向数据的接收者传达，在数据流更远的地方中有比目前读取更紧急数据。</p><p>TCP does not attempt to define what the user specifically does upon being notified of pending urgent data, but the general notion is that the receiving process should take action to read through the end urgent data quickly.<br>TCP 并不试图定义用户在收到待处理紧急数据的通知后具体做什么，但一般的情况是，接收进程应该采取行动，尽快读完最后的紧急数据。</p><h3 id=优先级和安全性>优先级和安全性
<a class=anchor href=#%e4%bc%98%e5%85%88%e7%ba%a7%e5%92%8c%e5%ae%89%e5%85%a8%e6%80%a7>#</a></h3><p><strong>2.9. Precedence and Security</strong></p><p>The TCP makes use of the internet protocol type of service field and security option to provide precedence and security on a per connection basis to TCP users.
TCP 利用 IP 协议的服务类型字段和安全选项，在每个连接的基础上向 TCP 用户提供优先权和安全性。</p><p>Not all TCP modules will necessarily function in a multilevel secure environment, some may be limited to unclassified use only, and others may operate at only one security level and compartment.<br>并非所有 TCP 模块都必须在多级安全环境中运行，有些模块可能仅限于公开使用，而其他模块可能仅在一个安全级别和区段中运行。</p><p>Consequently, some TCP implementations and services to users may be limited to a subset of the multilevel secure case.<br>因此，某些 TCP 实现和对用户的服务可能仅限于多级安全情况的一个子集。</p><p>TCP modules which operate in a multilevel secure environment should properly mark outgoing segments with the security, compartment, and precedence.<br>在多级安全环境中运行的 TCP 模块应正确标记传出 TCP 段的安全性、分区和优先级。</p><p>Such TCP modules should also provide to their users or higher level protocols such as Telnet or THP an interface to allow them to specify the desired security level, compartment, and precedence of connections.<br>这样的 TCP 模块还应该为它们的用户或者更高层次的协议，例如 Telnet 或者 THP 提供一个接口，以便让它们指定所需的连接的安全级别、区段和优先级。</p><h3 id=稳健性原则>稳健性原则
<a class=anchor href=#%e7%a8%b3%e5%81%a5%e6%80%a7%e5%8e%9f%e5%88%99>#</a></h3><p><strong>2.10. Robustness Principle</strong></p><p>TCP implementations should follow a general principle of robustness: be conservative in what you do, be liberal in what you accept from others.<br>TCP 实现应该遵循一个一般的稳健性原则：在你做的事情上要保守，在你接受别人的事情上要自由。</p><h2 id=功能规范>功能规范
<a class=anchor href=#%e5%8a%9f%e8%83%bd%e8%a7%84%e8%8c%83>#</a></h2><p><strong>3.FUNCTIONAL SPECIFICATION</strong></p><h3 id=头部格式>头部格式
<a class=anchor href=#%e5%a4%b4%e9%83%a8%e6%a0%bc%e5%bc%8f>#</a></h3><p><strong>3.1. Header Format</strong></p><p>TCP segments are sent as internet datagrams. The Internet Protocol header carries several information fields, including the source and destination host addresses [2].<br>TCP 段以互联网数据报的形式发送。IP 协议报头携带多个信息字段，包括源主机地址和目的主机地址。</p><p>A TCP header follows the internet header, supplying information specific to the TCP protocol. This ivision allows for the existence of host level protocols other than TCP.<br>TCP 头部 在 IP 协议头部后面，提供 TCP 协议特定的信息。这种划分允许存在除 TCP 以外的主机级协议。</p><div class=text-center><p>TCP Header Format<br>TCP 头部格式</p><pre tabindex=0><code>0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |          Source Port          |       Destination Port        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        Sequence Number                        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                    Acknowledgment Number                      |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |  Data |           |U|A|P|R|S|F|                               |
  | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
  |       |           |G|K|H|T|N|N|                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |           Checksum            |         Urgent Pointer        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                    Options                    |    Padding    |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                             data                              |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><p>Note that one tick mark represents one bit position.<br>注意：一个刻度线代表一个比特位。</p><p>Figure 3.</p></div><p><strong>Source Port</strong>: 16 bits<br> The source port number.<br> 源端口号</p><p><strong>Destination Port</strong>: 16 bits<br> The destination port number.<br> 目标端口号</p><p><strong>Sequence Number</strong>: 32 bits<br> The sequence number of the first data octet in this segment (except when SYN is present).<br> 该段数据中第一个字节的序列号（有 SYN 标志除外）。<br> If SYN is present the sequence number is the initial sequence number (ISN) and the first data octet is ISN+1.<br> 如果存在 SYN，则序列号是初始序列号 (ISN)，第一个字节数据是 ISN+1。</p><p><strong>Acknowledgment Number</strong>: 32 bits<br> If the ACK control bit is set this field contains the value of the next sequence number the sender of the segment is expecting to receive. Once a connection is established this is always sent.<br> 如果有 ACK 标志，这个字段表示发送者期望收到的下一个序列号的值。一旦建立了连接，一直会发送这个字段。</p><p><strong>Data Offset</strong>: 4 bits<br> The number of 32 bit words in the TCP Header. This indicates where the data begins. The TCP header (even one including options) is an integral number of 32 bits long.<br> 这个数表示 TCP 头部的长度有多少个 32 bit，表示真正数据开始的位置。TCP 头部（即使包括选项部分）的长度是 32 bit 的整数倍。</p><p><strong>Reserved</strong>: 6 bits<br> Reserved for future use. Must be zero.<br> 保留将来使用，全部为 0。</p><p><strong>Control Bits</strong>: 8 bits (from left to right):<br> URG: Urgent Pointer field significant 紧急标志<br> ACK: Acknowledgment field significant 确认标志<br> PSH: Push Function 推送标志<br> RST: Reset the connection 重置标志<br> SYN: Synchronize sequence numbers 同步标志<br> FIN: No more data from sender 断开连接标志</p><p><strong>Window</strong>: 16 bits<br> The number of data octets beginning with the one indicated in the acknowledgment field which the sender of this segment is willing to accept.<br> 从确认序号开始，发送方可以接收的字节数。</p><p><strong>Checksum</strong>: 16 bits<br> The checksum field is the 16 bit one&rsquo;s complement of the one&rsquo;s complement sum of all 16 bit words in the header and text.<br> 检验和是头部和数据部分所有分割成 16 bit 数的经过二进制反码求和得到的数。<br> If a segment contains an odd number of header and text octets to be checksummed, the last octet is padded on the right with zeros to form a 16 bit word for checksum purposes.<br> 如果 TCP 段头部和数据部分是奇数个字节要进行校验，则在最后一个字节右边填充零，以形成一个 16 bit，用于校验。<br> The pad is not transmitted as part of the segment.<br> 填充不会作为 TCP 段的一部分进行传输。<br> While computing the checksum, the checksum field itself is replaced with zeros.<br> 在计算校验和时，校验和字段本身用零替换。</p><p> The checksum also covers a 96 bit pseudo header conceptually prefixed to the TCP header.<br> 在校验和时还包括一个 96 bit 的伪头部，加在 TCP 头部前面。<br> This pseudo header contains the Source Address, the Destination Address, the Protocol, and TCP length.<br> 这个伪头部包含源地址、目标地址、协议和 TCP 长度。<br> This gives the TCP protection against misrouted segments.<br> 这为 TCP 提供了防止错误路由 TCP 段的保护。<br> This information is carried in the Internet Protocol and is transferred across the TCP/Network interface in the arguments or results of calls by the TCP on the IP.<br> 这些信息在 IP 协议中携带，并在 TCP/网络接口上通过 TCP 对 IP 的调用的参数或结果进行传输。</p><div class=text-center><pre tabindex=0><code>+--------------------------+
|      Source Address      |
+--------------------------+
|    Destination Address   |
+--------------------------+
| zero | PTCL | TCP Length |
+--------------------------+
</code></pre></div><p> The TCP Length is the TCP header plus the data length in octets (this is not an explicitly transmitted quantity, but is computed from the total length, and the header length), and it does not count the 12 octets of the pseudo header.<br> TCP 长度是 TCP 报头加上数据部分的长度，单位是字节（这不是一个明确的传输量，而是从总长度和头部长度计算出来的），并且不包括 12 字节的伪头部。</p><p><strong>Urgent Pointer</strong>: 16 bits<br> This field communicates the current value of the urgent pointer as a positive offset from the sequence number in this segment.<br> 这个字段表示当前紧急指针距离本段中序列号的正偏移。<br> The urgent pointer points to the sequence number of the octet following the urgent data.<br> 紧急指针指向紧急数据后的字节的序列号。<br> This field should only be interpreted in segments with the URG control bit set.<br> 这个字段只应在设置了 URG 标志的 TCP 段中使用。</p><p><strong>Options</strong>: variable<br> Options may occupy space at the end of the TCP header and are a multiple of 8 bits in length.<br> 可选部分可能占用 TCP 头的末尾的空间，长度为 8bit 的倍数。<br> All options are included in the checksum.<br> 可选部分也包括在检验和的计算中。<br> An option may begin on any octet boundary.<br> 可选部分可以从任何字节边界上开始。<br> There are two cases for the format of an option:<br> 选项的格式有两种情况：</p><ul><li>Case 1: A single octet of option-kind.<br>情况 1: 一个字节的选项类型。</li><li>Case 2: An octet of option-kind, an octet of option-length, and the actual option-data octets.<br>情况 2: 一个字节的选项类型、一个字节的选项长度和真正选项数据。</li></ul><p> The option-length counts the two octets of option-kind and option-length as well as the option-data octets.<br> 选项长度包括选项种类和选项长度的两个字节，以及选项数据的字节数。</p><p> Note that the list of options may be shorter than the data offset field might imply.<br> 注意：选项列表可能比数据偏移字段要短。<br> The content of the header beyond the End-of-Option option should be header padding (i.e., zero).<br> 头部中在选项之外的内容是填充（即，0）。</p><p> A TCP must implement all options.<br> TCP 必须实现所有选项。</p><p> Currently defined options include (kind indicated in octal):<br> 目前定义的选项包括（种类以八进制表示）：</p><pre tabindex=0><code>Kind     Length    Meaning
----     ------    -------
 0         -       End of option list.
 1         -       No-Operation.
100        -       Reserved.
105        4       Buffer Size.
</code></pre><p> Specific Option Definitions<br> 具体选项定义</p><p> End of Option List</p><pre tabindex=0><code>+--------+
|00000000|
+--------+
Kind=0
</code></pre><p> This option code indicates the end of the option list.<br> 该选项代码表示选项列表的结束。<br> This might not coincide with the end of the TCP header according to the Data Offset field.<br> 根据数据偏移字段，这可能与 TCP 头的结尾不一致。<br> This is used at the end of all options, not the end of each option, and need only be used if the end of the options would not otherwise coincide with the end of the TCP header.<br> 这用于所有选项的末尾，而不是每个选项的末尾，并且仅在选项末尾与 TCP 头末尾不一致时才需要使用。</p><p> No-Operation</p><pre tabindex=0><code>+--------+
|00000001|
+--------+
Kind=1
</code></pre><p> This option code may be used between options, for example, to align the beginning of a subsequent option on a word boundary.<br> 该选项代码可以在选项之间使用，例如，在一个字的边界上对准后续选项的开头。<br> There is no guarantee that senders will use this option, so receivers must be prepared to process options even if they do not begin on a word boundary.<br> 不能保证发送者会使用这个选项，所以接收者必须准备好处理选项，即使它们不以字的边界开始。</p><p> Buffer Size</p><pre tabindex=0><code>+--------+--------+---------+--------+
|01000101|00000100|    buffer size   |
+--------+--------+---------+--------+
Kind=105 Length=4
</code></pre><p> Buffer Size Option Data: 16 bits</p><p> If this option is present, then it communicates the receive buffer size at the TCP which sends this segment.<br> 如果该选项存在，那么它在发送该段的 TCP 上传达接收缓冲区的大小。<br> This field should only be sent in the initial connection request (i.e., in segments with the SYN control bit set).<br> 该字段应该只在初始连接请求中发送（即在设置了 SYN 标志的段中）。<br> If this option is not used, the default buffer size of one octet is assumed.<br> 如果不使用这个选项，则假定默认的缓冲区大小为一个字节。</p><p> Padding: variable</p><p> The TCP header padding is used to ensure that the TCP header ends and data begins on a 32 bit boundary. The padding is composed of zeros.<br> TCP 头的填充用于确保 TCP 头的结束和数据的开始都在 32 bit 边界上。填充是由零组成的。</p><h3 id=术语表>术语表
<a class=anchor href=#%e6%9c%af%e8%af%ad%e8%a1%a8>#</a></h3><p><strong>3.2. Terminology</strong></p><p>Before we can discuss very much about the operation of the TCP we need to introduce some detailed terminology.<br>在我们非常深入地讨论 TCP 的运作之前，我们需要介绍一些复杂的术语。</p><p>The maintenance of a TCP connection requires the remembering of several variables.<br>维护一个 TCP 连接需要记住几个变量。</p><p>We conceive of these variables being stored in a connection record called a Transmission Control Block or TCB.<br>我们设想这些变量被存储在一个叫做传输控制块或 TCB 的连接记录中。</p><p>Among the variables stored in the TCB are the local and remote socket numbers, the security and precedence of the connection, pointers to the user&rsquo;s send and receive buffers, pointers to the retransmit queue and to the current segment.<br>TCB 中存储的变量包括本地和远程套接字编号、连接的安全性和优先级、指向用户的发送和接收缓冲区的指针、指向重传队列和当前段的指针。</p><p>In addition several variables relating to the send and receive sequence numbers are stored in the TCB.<br>此外，与发送和接收序列号相关的几个变量存储在 TCB 中。</p><p>Send Sequence Variables<br>发送序列变量</p><pre tabindex=0><code>SND.UNA - send unacknowledged
SND.NXT - send next
SND.WND - send window
SND.UP  - send urgent pointer
SND.WL1 - segment sequence number used for last window update
SND.WL2 - segment acknowledgment number used for last window update
ISS     - initial send sequence number
</code></pre><p>Receive Sequence Variables<br>接收序列变量</p><pre tabindex=0><code>RCV.NXT - receive next
RCV.WND - receive window
RCV.UP  - receive urgent pointer
IRS     - initial receive sequence number
</code></pre><p>The following diagrams may help to relate some of these variables to the sequence space.<br>下图可能有助于将其中一些变量与序列空间联系起来。<div class=text-center><pre tabindex=0><code>    1         2          3          4
----------|----------|----------|----------
SND.UNA    SND.NXT    SND.UNA
                     +SND.WND

1 - old sequence numbers which have been acknowledged
2 - sequence numbers of unacknowledged data
3 - sequence numbers allowed for new data transmission
4 - future sequence numbers which are not yet allowed
</code></pre><p>Send Sequence Space</p><p>Figure 4.</p></div></p><p>The send window is the portion of the sequence space labeled 3 in figure 4.<br>发送窗口是图 4 中标记为 3 的序列空间的一部分。</p><div class=text-center><pre tabindex=0><code>  1          2          3
----------|----------|----------
RCV.NXT    RCV.NXT
          +RCV.WND

1 - old sequence numbers which have been acknowledged
2 - sequence numbers allowed for new reception
3 - future sequence numbers which are not yet allowed
</code></pre><p>Receive Sequence Space</p><p>Figure 5.</p></div><p>The receive window is the portion of the sequence space labeled 2 in figure 5.<br>接收窗口是图 5 中标记为 2 的序列空间的一部分。</p><p>There are also some variables used frequently in the discussion that take their values from the fields of the current segment.<br>还有一些在讨论中经常使用的变量，它们的值来自当前段的字段。</p><p>Current Segment Variables
当前段变量</p><pre tabindex=0><code>SEG.SEQ - segment sequence number
SEG.ACK - segment acknowledgment number
SEG.LEN - segment length
SEG.WND - segment window
SEG.UP  - segment urgent pointer
SEG.PRC - segment precedence value
</code></pre><p>A connection progresses through a series of states during its lifetime.<br>一个连接在其生命周期中会经历一系列的状态。</p><p>The states are: LISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT and the fictional state CLOSED.<br>这些状态是：LISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT 以及虚构的状态 CLOSED。</p><p>CLOSED is fictional because it represents the state when there is no TCB, and therefore, no connection.<br>CLOSED 是虚构的，因为它代表了没有 TCB 的状态，也就是没有连接。</p><p>Briefly the meanings of the states are:<br>简而言之，这些状态的含义是：</p><p><strong>LISTEN</strong> - represents waiting for a connection request from any remote TCP and port.<br><strong>LISTEN</strong> - 表示等待来自任何远程 TCP 和端口的连接请求。</p><p><strong>SYN-SENT</strong> - represents waiting for a matching connection request after having sent a connection request.<br><strong>SYN-SENT</strong> - 表示在发送了一个连接请求后等待一个匹配的连接请求。</p><p><strong>SYN-RECEIVED</strong> - represents waiting for a confirming connection request acknowledgment after having both received and sent a connection request.<br><strong>SYN-RECEIVED</strong> - 表示在收到和发送连接请求后，等待确认连接请求的确认。</p><p><strong>ESTABLISHED</strong> - represents an open connection, data received can be delivered to the user. The normal state for the data transfer phase of the connection.<br><strong>ESTABLISHED</strong> - 代表一个已建立的连接，收到的数据可以传递给用户，是连接数据传输阶段的正常状态。</p><p><strong>FIN-WAIT-1</strong> - represents waiting for a connection termination request from the remote TCP, or an acknowledgment of the connection termination request previously sent.<br><strong>FIN-WAIT-1</strong> - 表示等待来自远程 TCP 的连接终止请求，或等待之前发送的终止连接请求的确认。</p><p><strong>FIN-WAIT-2</strong> - represents waiting for a connection termination request from the remote TCP.<br><strong>FIN-WAIT-2</strong> - 表示等待来自远程 TCP 的连接终止请求。</p><p><strong>CLOSE-WAIT</strong> - represents waiting for a connection termination request from the local user.<br><strong>CLOSE-WAIT</strong> - 表示等待本端用户的连接终止请求。</p><p><strong>CLOSING</strong> - represents waiting for a connection termination request acknowledgment from the remote TCP.<br><strong>CLOSING</strong> - 表示等待来自远程 TCP 的连接终止请求确认。</p><p><strong>LAST-ACK</strong> - represents waiting for an acknowledgment of the connection termination request previously sent to the remote TCP (which includes an acknowledgment of its connection termination request).
<strong>LAST-ACK</strong> - 表示等待对先前发送到远程 TCP 的连接终止请求的确认（其中包括对其连接终止请求的确认）。</p><p><strong>TIME-WAIT</strong> - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.<br><strong>TIME-WAIT</strong> - 表示等待足够的时间来确保远程 TCP 收到其连接终止请求的确认。</p><p><strong>CLOSED</strong> - represents no connection state at all.<br><strong>CLOSED</strong> - 表示没有连接的状态。</p><p>A TCP connection progresses from one state to another in response to events.<br>TCP 连接根据事件从一个状态转换到另一个状态。</p><p>The events are the user calls, OPEN, SEND, RECEIVE, CLOSE, ABORT, and STATUS; the incoming segments, particularly those containing the SYN and FIN flags; and timeouts.<br>这些事件是用户调用 OPEN、SEND、RECEIVE、CLOSE、ABORT 和 STATUS；收到 TCP 段，特别是包含 SYN 和 FIN 标志的段；以及超时。</p><p>The state diagram in figure 6 only illustrates state changes, together with the causing events and resulting actions, but addresses neither error conditions nor actions which are not connected with state changes.<br>图 6 中的状态图只说明了状态的变化，以及引起的事件和触发的行为，但既没有涉及错误条件，也没有涉及与状态变化无关的行为。</p><p>In a later section, more detail is offered with respect to the reaction of the TCP to events.<br>在后面的章节中，将提供关于 TCP 对事件反应的更多细节。</p><p>NOTE BENE: this diagram is only a summary and must not be taken as the total specification.<br>注意：此图只是一个摘要，不能作为全部规范。</p><pre tabindex=0><code>                              +---------+ ---------\      active OPEN
                              |  CLOSED |            \    -----------
                              +---------+&lt;---------\   \   create TCB
                                |     ^              \   \  snd SYN
                   passive OPEN |     |   CLOSE        \   \
                   ------------ |     | ----------       \   \
                    create TCB  |     | delete TCB         \   \
                                V     |                      \   \
                              +---------+            CLOSE    |    \
                              |  LISTEN |          ---------- |     |
                              +---------+          delete TCB |     |
                   rcv SYN      |     |     SEND              |     |
                  -----------   |     |    -------            |     V
 +---------+      snd SYN,ACK  /       \   snd SYN          +---------+
 |         |&lt;-----------------           ------------------&gt;|         |
 |   SYN   |                    rcv SYN                     |   SYN   |
 |   RCVD  |&lt;-----------------------------------------------|   SENT  |
 |         |                    snd ACK                     |         |
 |         |------------------           -------------------|         |
 +---------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +---------+
   |           --------------   |     |   -----------
   |                  x         |     |     snd ACK
   |                            V     V
   |  CLOSE                   +---------+
   | -------                  |  ESTAB  |
   | snd FIN                  +---------+
   |                   CLOSE    |     |    rcv FIN
   V                  -------   |     |    -------
 +---------+          snd FIN  /       \   snd ACK          +---------+
 |  FIN    |&lt;-----------------           ------------------&gt;|  CLOSE  |
 | WAIT-1  |------------------                              |   WAIT  |
 +---------+          rcv FIN  \                            +---------+
   | rcv ACK of FIN   -------   |                            CLOSE  |
   | --------------   snd ACK   |                           ------- |
   V        x                   V                           snd FIN V
 +---------+                  +---------+                   +---------+
 |FINWAIT-2|                  | CLOSING |                   | LAST-ACK|
 +---------+                  +---------+                   +---------+
   |                rcv ACK of FIN |                 rcv ACK of FIN |
   |  rcv FIN       -------------- |    Timeout=2MSL -------------- |
   |  -------              x       V    ------------        x       V
    \ snd ACK                 +---------+delete TCB         +---------+
     ------------------------&gt;|TIME WAIT|------------------&gt;| CLOSED  |
                              +---------+                   +---------+
</code></pre><div class=text-center><p>TCP Connection State Diagram<br>TCP 连接状态图</p><p>Figure 6.</p></div><h3 id=序列号>序列号
<a class=anchor href=#%e5%ba%8f%e5%88%97%e5%8f%b7>#</a></h3><p><strong>3.3. Sequence Numbers</strong></p><p>A fundamental notion in the design is that every octet of data sent over a TCP connection has a sequence number.<br>TCP 设计中的一个基本概念是，通过 TCP 连接发送的每个字节的数据都有一个序列号。</p><p>Since every octet is sequenced, each of them can be acknowledged.<br>由于每个字节都是有顺序的，所以每个字节都可以被确认。</p><p>The acknowledgment mechanism employed is cumulative so that an acknowledgment of sequence number X indicates that all octets up to but not including X have been received.<br>TCP 所采用的确认机制是累积性的，因此序列号为 X 的确认表示已经收到了之前但不包括 X 的所有字节。</p><p>This mechanism allows for straight-forward duplicate detection in the presence of retransmission.<br>这种机制使得在存在重传的情况下可以直接进行重复检测。</p><p>Numbering of octets within a segment is that the first data octet immediately following the header is the lowest numbered, and the following octets are numbered consecutively.<br>TCP 段内字节的编号是，TCP 头后的第一个字节数据是最小的编号，后面字节的编号是连续递增。</p><p>It is essential to remember that the actual sequence number space is finite, though very large.<br>需要记住，实际的序列号范围是有限的，尽管非常大。</p><p>This space ranges from 0 to 2**32 - 1.<br>这个范围是从 0 到 2**32-1 。</p><p>Since the space is finite, all arithmetic dealing with sequence numbers must be performed modulo 2**32.<br>由于范围是有限的，所有处理序列号的运算都必须模 2**32。</p><p>This unsigned arithmetic preserves the relationship of sequence numbers as they cycle from 2**32 - 1 to 0 again.<br>这种无符号算术保留了序列号之间的关系，因为它们从 2**32-1 再重新到 0。</p><p>There are some subtleties to computer modulo arithmetic, so great care should be taken in programming the comparison of such values.<br>计算机模运算有一些细微的差异，所以在编程比较这些值时应该非常小心。</p><p>The symbol &ldquo;=&lt;&rdquo; means &ldquo;less than or equal&rdquo; (modulo 2**32).<br>符号 &ldquo;=&lt;&rdquo; 表示 &ldquo;小于或等于&rdquo; (模 2**32)。</p><p>The typical kinds of sequence number comparisons which the TCP must perform include:<br>TCP 中需要操作的典型的序列号比较包括：</p><p>(a) Determining that an acknowledgment refers to some sequence number sent but not yet acknowledged.<br>(a) 确定一个确认是对应某个已发送但尚未确认的序列号。</p><p>(b) Determining that all sequence numbers occupied by a segment have been acknowledged (e.g., to remove the segment from a retransmission queue).<br>(b) 确定 TCP 段所占用的所有序列号都已被确认（例如，从重传队列中删除该 TCP 段）。</p><p>(c) Determining that an incoming segment contains sequence numbers which are expected (i.e., that the segment &ldquo;overlaps&rdquo; the receive window).<br>(c) 确定一个收到的 TCP 段包含预期的序列号（即该 TCP 段与接收窗口"重叠&rdquo;）。</p><p>In response to sending data the TCP will receive acknowledgments.<br>TCP 将收到确认作为对发送数据的响应。</p><p>The following comparisons are needed to process the acknowledgments.<br>在处理确认时需要进行以下比较。</p><p>SND.UNA = oldest unacknowledged sequence number<br>SND.UNA = 最早的未确认的序列号</p><p>SND.NXT = next sequence number to be sent<br>SND.NXT = 下一个要发送的序列号</p><p>SEG.ACK = acknowledgment from the receiving TCP (next sequence number expected by the receiving TCP)<br>SEG.ACK = 来自接收 TCP 的确认（接收 TCP 所期望的下一个序列号）。</p><p>SEG.SEQ = first sequence number of a segment<br>SEG.SEQ = TCP 段的第一个序列号</p><p>SEG.LEN = the number of octets occupied by the data in the segment (counting SYN and FIN)<br>SEG.LEN = 段落中的数据所占的字节数 (包括 SYN 和 FIN)</p><p>SEG.SEQ+SEG.LEN-1 = last sequence number of a segment<br>SEG.SEQ+SEG.LEN-1 = TCP 段的最后一个序列号</p><p>A new acknowledgment (called an &ldquo;acceptable ack&rdquo;), is one for which the inequality below holds:<br>一个新的确认（即 &ldquo;可接受的确认&rdquo;），会满足以下不等式。<br>SND.UNA &lt; SEG.ACK =&lt; SND.NXT</p><p>A segment on the retransmission queue is fully acknowledged if the sum of its sequence number and length is less than the acknowledgment value in the incoming segment.<br>如果重传队列中的一个 TCP 段的序列号和长度之和小于收到段的确认值，则该段被完全确认。</p><p>When data is received the following comparisons are needed:<br>当收到数据时，需要进行以下比较：</p><p>RCV.NXT = next sequence number expected on an incoming segments, and is the left or lower edge of the receive window<br>RCV.NXT = 下一个预期收到 TCP 段的序列号，也是接收窗口的左边界或下限。</p><p>RCV.NXT+RCV.WND-1 = last sequence number expected on an incoming segment, and is the right or upper edge of the receive window<br>RCV.NXT+RCV.WND-1 = 最后一个预期收到 TCP 段的序列号，也是接收窗口的右边界或上限。</p><p>SEG.SEQ = first sequence number occupied by the incoming segment<br>SEG.SEQ = 收到 TCP 段的第一个序列号</p><p>SEG.SEQ+SEG.LEN-1 = last sequence number occupied by the incoming segment<br>SEG.SEQ+SEG.LEN-1 = 收到 TCP 段的最后一个序列号</p><p>A segment is judged to occupy a portion of valid receive sequence space if<br>在下列情况下，一个 TCP 段被判断为占据了有效接收序列范围的一部分</p><p>RCV.NXT =&lt; SEG.SEQ &lt; RCV.NXT+RCV.WND</p><p>or<br>或</p><p>RCV.NXT =&lt; SEG.SEQ+SEG.LEN-1 &lt; RCV.NXT+RCV.WND</p><p>The first part of this test checks to see if the beginning of the segment falls in the window, the second part of the test checks to see if the end of the segment falls in the window; if the segment passes either part of the test it contains data in the window.<br>该测试的第一部分检查段的开头是否落在窗口中，测试的第二部分检查段的结尾是否落在窗口中；如果该段通过了测试的任何一部分，则它在窗口中包含数据。</p><p>Actually, it is a little more complicated than this. Due to zero windows and zero length segments, we have four cases for the acceptability of an incoming segment:<br>实际上，情况比这更复杂一些。由于零窗口和零长度的 TCP 段，我们有四种情况来判断一个收到的 TCP 段是否可接受：</p><pre tabindex=0><code>Segment Receive  Test
Length  Window
------- -------  -------------------------------------------
    0       0     SEG.SEQ = RCV.NXT
    0      &gt;0     RCV.NXT =&lt; SEG.SEQ &lt; RCV.NXT+RCV.WND
   &gt;0       0     not acceptable
   &gt;0      &gt;0     RCV.NXT =&lt; SEG.SEQ &lt; RCV.NXT+RCV.WND or
                  RCV.NXT =&lt; SEG.SEQ+SEG.LEN-1 &lt; RCV.NXT+RCV.WND
</code></pre><p>Note that when the receive window is zero no segments should be acceptable except ACK segments.<br>请注意，当接收窗口为零时，除了 ACK 段外，不应接受其他 TCP 段。</p><p>Thus, it should be possible for a TCP to maintain a zero receive window while transmitting data and receiving ACKs.<br>因此，TCP 应该有可能在传输数据和接收 ACK 的同时保持一个零接收窗口。</p><p>However, even when the receive window is zero, a TCP must process the RST and URG fields of all incoming segments.<br>然而，即使接收窗口为零，TCP 也必须处理所有接收段的 RST 和 URG 字段。</p><p>We have taken advantage of the numbering scheme to protect certain control information as well.
我们还利用了编号方案来保护某些控制信息。</p><p>This is achieved by implicitly including some control flags in the sequence space so they can be retransmitted and acknowledged without confusion (i.e., one and only one copy of the control will be acted upon).<br>这是通过在序列空间中隐含地包括一些控制标志来实现的，使得它们可以被重发和确认而不会产生混淆(即，将对控制的一个且仅一个副本进行操作)。</p><p>Control information is not physically carried in the segment data space.<br>控制信息不实际在 TCP 段数据空间中携带。</p><p>Consequently, we must adopt rules for implicitly assigning sequence numbers to control.
因此，我们必须采用隐式分配序列号的规则来控制。</p><p>The SYN and FIN are the only controls requiring this protection, and these controls are used only at connection opening and closing.<br>SYN 和 FIN 是唯一需要这种保护的控制，而且这些控制只在连接打开和关闭时使用。</p><p>For sequence number purposes, the SYN is considered to occur before the first actual data octet of the segment in which it occurs, while the FIN is considered to occur after the last actual data octet in a segment in which it occurs.<br>就序列号而言，SYN 被认为发生在其所在 TCP 段的实际数据第一个字节之前，而 FIN 被认为发生在其所在段的实际数据的最后一个字节之后。</p><p>The segment length includes both data and sequence space occupying controls.<br>TCP 段的长度包括数据和占用序列空间的控制信息。</p><p>When a SYN is present then SEG.SEQ is the sequence number of the SYN.<br>当存在 SYN 时，SEG.SEQ 是 SYN 的序列号。</p><p><strong>Initial Sequence Number Selection</strong><br><strong>初始序列号的选择</strong></p><p>The protocol places no restriction on a particular connection being used over and over again.<br>该协议不限制反复使用特定连接。</p><p>A connection is defined by a pair of sockets.<br>一个连接是由一对套接字确定的。</p><p>New instances of a connection will be referred to as incarnations of the connection.<br>连接的新实例会用来表示连接。</p><p>The problem that arises owing to this is &ndash; &ldquo;how does the TCP identify duplicate segments from previous incarnations of the connection?&rdquo;<br>由此产生的问题是 &ndash; &ldquo;TCP 如何识别来自以前连接中的重复段？&rdquo;</p><p>This problem becomes apparent if the connection is being opened and closed in quick succession, or if the connection breaks with loss of memory and is then reestablished.<br>如果快速连续地打开和关闭连接，或者如果连接因内存丢失而断开，然后重新建立，则此问题会变得明显。</p><p>To avoid confusion we must prevent segments from one incarnation of a connection from being used while the same sequence numbers may still be present in the network from an earlier incarnation.<br>为了防止出现混乱，我们必须防止使用来自先前连接中有相同序列号的数据段。</p><p>We want to assure this, even if a TCP crashes and loses all knowledge of the sequence numbers it has been using.<br>我们要保证这一点，即使 TCP 崩溃并失去了它使用的序列号的所有信息。</p><p>When new connections are created, an initial sequence number (ISN) generator is employed which selects a new 32 bit ISN.<br>当创建新连接时，使用初始序列号(ISN)生成器选择新的 32 位 ISN。</p><p>The generator is bound to a (possibly fictitious) 32 bit clock whose low order bit is incremented roughly every 4 microseconds.<br>发生器跟一个（可能是虚拟的）32 位时钟绑定，其低位大约每 4 微秒递增一次。</p><p>Thus, the ISN cycles approximately every 4.55 hours.<br>因此，ISN 大约每 4.55 小时循环一次。</p><p>Since we assume that segments will stay in the network no more than tens of seconds or minutes, at worst, we can reasonably assume that ISN&rsquo;s will be unique.<br>由于我们假设 TCP 段在网络中的停留时间不超过几十秒或几分钟，即使在最坏的情况下，我们仍然可以地假设 ISN 将是唯一的。</p><p>For each connection there is a send sequence number and a receive sequence number.<br>对于每个连接，都有一个发送序列号和一个接收序列号。</p><p>The initial send sequence number (ISS) is chosen by the data sending TCP, and the initial receive sequence number (IRS) is learned during the connection establishing procedure.<br>初始发送序列号（ISS）由发送方的 TCP 选择，初始接收序列号（IRS）在连接建立过程中得到。</p><p>For a connection to be established or initialized, the two TCPs must synchronize on each other&rsquo;s initial sequence numbers.<br>如果要建立或初始化的连接，两个 TCP 必须同步对方的初始序列号。</p><p>This is done in an exchange of connection establishing messages carrying a control bit called &ldquo;SYN&rdquo; (for synchronize) and the initial sequence numbers.<br>这是通过交换建立连接的信息来完成的，这些信息带有一个称为 &ldquo;SYN&rdquo;（用于同步）的控制位和初始序列号。</p><p>As a shorthand, messages carrying the SYN bit are also called &ldquo;SYNs&rdquo;.<br>简而言之，携带 SYN 位的消息也称为 &ldquo;SYNs&rdquo;。</p><p>Hence, the solution requires a suitable mechanism for picking an initial sequence number and a slightly involved handshake to exchange the ISN&rsquo;s.<br>因此，该解决方案需要一个合适的机制来挑选初始序列号，并需要一个稍微复杂的握手来交换 ISN。</p><p>The synchronization requires each side to send it&rsquo;s own initial sequence number and to receive a confirmation of it in acknowledgment from the other side.<br>同步需要每一方发送自己的初始序列号，并从另一方的 ACK 中得到确认。</p><p>Each side must also receive the other side&rsquo;s initial sequence number and send a confirming acknowledgment.<br>每一方还必须收到另一方的初始序列号，并发送确认的 ACK。</p><p>(1) A &ndash;> B SYN my sequence number is X<br>(1) A &ndash;> B 同步自己的序列号 X</p><p>(2) A &lt;&ndash; B ACK your sequence number is X<br>(2) A &lt;&ndash; B 确认你的序列号是 X</p><p>(3) A &lt;&ndash; B SYN my sequence number is Y<br>(3) A &lt;&ndash; B 同步自己的序列号 Y</p><p>(4) A &ndash;> B ACK your sequence number is Y<br>(4) A &ndash;> B 确认你的序列号是 Y</p><p>Because steps 2 and 3 can be combined in a single message this is called the three way (or three message) handshake.<br>由于第 2 和第 3 步可以结合在一个消息中，这被称为三次（或三次信息）握手。</p><p>A &ldquo;three way handshake&rdquo; is necessary because sequence numbers are not tied to a global clock in the network, and TCPs may have different mechanisms for picking the ISN&rsquo;s.
&ldquo;三次握手&rdquo; 是必要的，因为序列号没有绑定到网络中的全局时钟，并且 TCP 可能有不同的机制来挑选 ISN。</p><p>The receiver of the first SYN has no way of knowing whether the segment was an old delayed one or not, unless it remembers the last sequence number used on the connection (which is not always possible), and so it must ask the sender to verify this SYN.
第一个 SYN 的接收者没有办法知道这个 TCP 段是否是一个旧的延迟段，除非它记得连接上使用的最后一个序列号（这并不总是可能的），所以它必须要求发送者验证这个 SYN。</p><p>The &ldquo;three way handshake&rdquo; and the advantages of a &ldquo;clock-driven&rdquo; scheme are discussed in [3].<br>在[3]中讨论了 &ldquo;三次握手 &ldquo;和 &ldquo;时钟驱动&rdquo; 方案的优势。</p><p><strong>Knowing When to Keep Quiet</strong><br><strong>知道什么时候该保持静默</strong></p><p>To be sure that a TCP does not create a segment that carries a sequence number which may be duplicated by an old segment remaining in the network, the TCP must keep quiet for a maximum segment lifetime (MSL) before assigning any sequence numbers upon starting up or recovering from a crash in which memory of sequence numbers in use was lost.<br>为了确保 TCP 不会创建一个携带与网络中旧 TCP 段中序列号重复的 TCP 段，TCP 在启动时或从丢失当前使用序列号内存的崩溃中恢复时，在分配任何序列号之前保持最大段存活时间（MSL）的静默时间。</p><p>For this specification the MSL is taken to be 2 minutes.<br>在本规范中，MSL 是 2 分钟。</p><p>This is an engineering choice, and may be changed if experience indicates it is desirable to do so.<br>这是一个工程选择，它可能会根据经验改变。</p><p>Note that if a TCP is reinitialized in some sense, yet retains its memory of sequence numbers in use, then it need not wait at all; it must only be sure to use sequence numbers larger than those recently used.<br>请注意，如果一个 TCP 在某种情况被重新初始化，但保留了其正在使用的序列号的内存，那么它不需要等待；它只需要确保使用比最近使用的序列号大的序列号。</p><p><strong>The TCP Quiet Time Concept</strong><br><strong>TCP 静默时间的概念</strong></p><p>This specification provides that hosts which &ldquo;crash&rdquo; without retaining any knowledge of the last sequence numbers transmitted on each active (i.e., not closed) connection shall delay emitting any TCP segments for at least the agreed Maximum Segment Lifetime (MSL) in the internet system of which the host is a part.<br>本规范规定，如果主机 &ldquo;崩溃&rdquo;, 没有保留在每个活动（即未关闭）连接上传输的最后一个序列号的任何信息，则应至少延迟商定的最大段生命周期（MSL）后，再发送任何 TCP 段到主机所处的 internet 系统中。</p><p>In the paragraphs below, an explanation for this specification is given.<br>在下面的段落中，给出了对该规范的解释。</p><p>TCP implementors may violate the &ldquo;quiet time&rdquo; restriction, but only at the risk of causing some old data to be accepted as new or new data rejected as old duplicated by some receivers in the internet system.<br>TCP 实现者可以会违反 &ldquo;quiet time&rdquo; 限制，但是可能存在导致某些旧数据被接受为新数据或新数据被 internet 系统中的某些接收方认为是旧的重复数据而拒收的风险。</p><p>TCPs consume sequence number space each time a segment is formed and entered into the network output queue at a source host.<br>每次生成段并加入到源主机的网络输出队列时，TCP 都会消耗序列号空间。</p><p>The duplicate detection and sequencing algorithm in the TCP protocol relies on the unique binding of segment data to sequence space to the extent that sequence numbers will not cycle through all 2**32 values before the segment data bound to those sequence numbers has been delivered and acknowledged by the receiver and all duplicate copies of the segments have &ldquo;drained&rdquo; from the internet.<br>TCP 协议中的重复检测和排序算法依赖于段数据与序列空间的唯一绑定，因此与这些序列号绑定的段数据被送达并被接收方确认以及段的所有副本从互联网上 &ldquo;耗尽&rdquo; 之前，序列号不会在所有 2**32 值中循环。</p><p>Without such an assumption, two distinct TCP segments could conceivably be assigned the same or overlapping sequence numbers, causing confusion at the receiver as to which data is new and which is old.<br>如果没有这样的假设，两个不同的 TCP 段可能会被分配相同或重叠的序列号，从而导致接收方无法区分哪些数据是新数据，哪些是旧数据。</p><p>Remember that each segment is bound to as many consecutive sequence numbers as there are octets of data in the segment.<br>记住，每个段都绑定到与段中数据的字节一样多的连续序列号。</p><p>Under normal conditions, TCPs keep track of the next sequence number to emit and the oldest awaiting acknowledgment so as to avoid mistakenly using a sequence number over before its first use has been acknowledged.<br>在正常情况下，TCP 会跟踪下一个要发出的序列号和最旧的等待确认的序列号，以避免在第一次使用得到确认之前错误地使用该序列号。</p><p>This alone does not guarantee that old duplicate data is drained from the net, so the sequence space has been made very large to reduce the probability that a wandering duplicate will cause trouble upon arrival.<br>仅仅这样并不能保证旧的重复数据从网络中消失，所以序列空间被做得非常大，以减少漫游的重复数据到达后造成麻烦的可能性。</p><p>At 2 megabits/sec. it takes 4.5 hours to use up 2**32 octets of sequence space.<br>在 2 兆比特/秒的情况下，需要 4.5 小时才能用完 2**32 个字节的序列空间。</p><p>Since the maximum segment lifetime in the net is not likely to exceed a few tens of seconds, this is deemed ample protection for foreseeable nets, even if data rates escalate to l0&rsquo;s of megabits/sec.<br>由于网络中的段的最大存活时间不太可能超过几十秒，这被认为是对可预见网络的充分保护，即使数据速率升级到 10 兆比特/秒。</p><p>At 100 megabits/sec, the cycle time is 5.4 minutes which may be a little short, but still within reason.<br>在 100 兆比特/秒时，循环时间为 5.4 分钟，这可能有点短，但仍在合理范围内。</p><p>The basic duplicate detection and sequencing algorithm in TCP can be defeated, however, if a source TCP does not have any memory of the sequence numbers it last used on a given connection.<br>然而，如果源 TCP 没有任何关于它在给定连接上最后使用的序列号的内存，则 TCP 中的基础重复检测和排序算法可能会失效。</p><p>For example, if the TCP were to start all connections with sequence number 0, then upon crashing and restarting, a TCP might re-form an earlier connection (possibly after half-open connection resolution) and emit packets with sequence numbers identical to or overlapping with packets still in the network which were emitted on an earlier incarnation of the same connection.<br>例如，如果 TCP 以序列号 0 开始所有连接，那么在崩溃和重新启动时，TCP 可能会重新建立较早的连接（可能在半开连接解析之后）并发出序列号与网络中的数据包相同或重叠的数据包，这些数据包是在同一连接的早期实例下发出的。</p><p>In the absence of knowledge about the sequence numbers used on a particular connection, the TCP specification recommends that the source delay for MSL seconds before emitting segments on the connection, to allow time for segments from the earlier connection incarnation to drain from the system.<br>在不知道特定连接上使用的序列号的情况下，TCP 规范建议源 TCP 在连接上发送段之前延迟 MSL 秒，以便让来自早期连接实例的段有时间从系统中消失。</p><p>Even hosts which can remember the time of day and used it to select initial sequence number values are not immune from this problem (i.e., even if time of day is used to select an initial sequence number for each new connection incarnation).<br>即使是可以记住一天中的时间并使用它来选择初始序列号值的主机也不能避免这个问题（即，即使一天中的时间用于为每个新连接化身选择一个初始序列号）。</p><p>Suppose, for example, that a connection is opened starting with sequence number S.<br>例如，假设一个连接以序列号 S 开始打开。</p><p>Suppose that this connection is not used much and that eventually the initial sequence number function (ISN(t)) takes on a value equal to the sequence number, say S1, of the last segment sent by this TCP on a particular connection.<br>假设这个连接使用不多，最终初始序列号函数（ISN(t)）的值等于这个 TCP 在特定连接上发送的最后一个段的序列号，例如 S1。</p><p>Now suppose, at this instant, the host crashes, recovers, and establishes a new incarnation of the connection.<br>现在，假设在这个时刻，主机崩溃了，然后恢复，并建立了一个新的连接的实例。</p><p>The initial sequence number chosen is S1 = ISN(t) &ndash; last used sequence number on old incarnation of connection!<br>选择的初始序列号是 S1 = ISN(t) &ndash; 旧的连接的最后使用的序列号!</p><p>If the recovery occurs quickly enough, any old duplicates in the net bearing sequence numbers in the neighborhood of S1 may arrive and be treated as new packets by the receiver of the new incarnation of the connection.<br>如果恢复发生得足够快，网络中任何带有 S1 附近序列号的旧重复数据都可能到达，并被新的连接实例的接收者视为新的数据包。</p><p>The problem is that the recovering host may not know for how long it crashed nor does it know whether there are still old duplicates in the system from earlier connection incarnations.<br>问题是正在恢复的主机可能不知道它崩溃了多长时间，也不知道系统中是否仍然存在来自早期连接实例的旧的重复数据。</p><p>One way to deal with this problem is to deliberately delay emitting segments for one MSL after recovery from a crash- this is the &ldquo;quiet time&rdquo; specification.<br>解决这个问题的一种方法是在从崩溃中恢复后故意延迟一个 MSL 再发送段，这是 &ldquo;静默时间&rdquo; 规范。</p><p>Hosts which prefer to avoid waiting are willing to risk possible confusion of old and new packets at a given destination may choose not to wait for the &ldquo;quie t time&rdquo;.<br>喜欢避免等待的主机，愿意冒着在目的地可能出现新旧数据包混淆的风险，可以选择不等待 &ldquo;静默时间&rdquo;。</p><p>Implementors may provide TCP users with the ability to select on a connection by connection basis whether to wait after a crash, or may informally implement the &ldquo;quiet time&rdquo; for all connections.<br>实现者可以为 TCP 用户提供在连接基础上选择是否在崩溃后等待的能力，或者可以非正式地为所有连接实现 &ldquo;静默时间&rdquo;。</p><p>Obviously, even where a user selects to &ldquo;wait,&rdquo; this is not necessary after the host has been &ldquo;up&rdquo; for at least MSL seconds.<br>很明显，即使用户选择了 &ldquo;等待&rdquo;，在主机至少 &ldquo;启动&rdquo; 了 MSL 秒之后，也没有必要这样做。</p><p>To summarize: every segment emitted occupies one or more sequence numbers in the sequence space, the numbers occupied by a segment are &ldquo;busy&rdquo; or &ldquo;in use&rdquo; until MSL seconds have passed, upon crashing a block of space-time is occupied by the octets of the last emitted segment, if a new connection is started too soon and uses any of the sequence numbers in the space-time footprint of the last segment of the previous connection incarnation, there is a potential sequence number overlap area which could cause confusion at the receiver.</p><p>总结一下：每个发出的段在序列空间中占据一个或多个序列号，段所占据的序列号是 &ldquo;忙&rdquo; 或 &ldquo;使用中&rdquo;，直到 MSL 秒过去，崩溃时，一个时空块被最后发射的段的数据占据，如果新连接启动得太早，并且使用了前一个连接实例的最后一段时空足迹中的任何序列号，则存在潜在的序列号重叠区域，这可能会导致接收方混淆。</p><h3 id=建立连接>建立连接
<a class=anchor href=#%e5%bb%ba%e7%ab%8b%e8%bf%9e%e6%8e%a5>#</a></h3><p><strong>3.4. Establishing a connection</strong></p><p>The &ldquo;three-way handshake&rdquo; is the procedure used to establish a connection.<br>&ldquo;三次握手"是用于建立连接的过程。</p><p>This procedure normally is initiated by one TCP and responded to by another TCP.<br>这个过程通常由一个 TCP 发起，由另一个 TCP 响应。</p><p>The procedure also works if two TCP simultaneously initiate the procedure.<br>如果两个 TCP 同时发起连接，该过程也应正常工作。</p><p>When simultaneous attempt occurs, the TCP receives a &ldquo;SYN&rdquo; segment which carries no acknowledgment after it has sent a &ldquo;SYN&rdquo;.<br>当同时尝试建立连接时，TCP 在发送 &ldquo;SYN&rdquo; 后，收到没有携带确认的 &ldquo;SYN&rdquo; 段。</p><p>Of course, the arrival of an old duplicate &ldquo;SYN&rdquo; segment can potentially make it appear, to the recipient, that a simultaneous connection initiation is in progress.<br>当然，当接收者收到一个旧的重复的 &ldquo;SYN&rdquo; 段时，有可能会认为是同时建立连接。</p><p>Proper use of &ldquo;reset&rdquo; segments can disambiguate these cases.<br>适当使用 &ldquo;reset&rdquo; 段可以消除这些情况。</p><p>Several examples of connection initiation follow.<br>下面是几个建立连接的例子。</p><p>Although these examples do not show connection synchronization using data-carrying segments, this is perfectly legitimate, so long as the receiving TCP doesn&rsquo;t deliver the data to the user until it is clear the data is valid (i.e., the data must be buffered at the receiver until the connection reaches the ESTABLISHED state).<br>虽然这些例子中连接同步没有显示携带数据，这是完全可以的，在接收 TCP 明确数据有效之前，它不向用户传递数据（即这些数据必须先放在接收者的缓存中，直到连接达到 ESTABLISHED 状态）。</p><p>The three-way handshake reduces the possibility of false connections.<br>三次握手降低了错误连接的可能性。</p><p>It is the implementation of a trade-off between memory and messages to provide information for this checking.<br>它是内存和消息之间的权衡的实现，为该检查提供信息。</p><p>The simplest three-way handshake is shown in figure 7 below.<br>最简单的三次握手如下面的图 7 所示。</p><p>The figures should be interpreted in the following way.<br>这些符号应作如下解释。</p><p>Each line is numbered for reference purposes.<br>每行都有编号，以便参考。</p><p>Right arrows (&ndash;>) indicate departure of a TCP segment from TCP A to TCP B, or arrival of a segment at B from A.<br>右箭头 (&ndash;>) 表示从 TCP A 发送到 TCP B 的 TCP 段，或 B 接收到 A 的 TCP 段。</p><p>Left arrows (&lt;&ndash;), indicate the reverse.<br>左箭头 (&lt;&ndash;) 表示相反方向。</p><p>Ellipsis (&mldr;) indicates a segment which is still in the network (delayed).<br>省略号 (&mldr;) 表示仍在网络中的 TCP 段(延迟了)。</p><p>An &ldquo;XXX&rdquo; indicates a segment which is lost or rejected.<br>&ldquo;XXX&rdquo; 表示丢失或被拒绝的 TCP 段。</p><p>Comments appear in parentheses.<br>括号中的是注释。</p><p>TCP states represent the state AFTER the departure or arrival of the segment (whose contents are shown in the center of each line).<br>TCP 状态表示数据段发送或到达后的状态(其内容显示在每行的中间)。</p><p>Segment contents are shown in abbreviated form, with sequence number, control flags, and ACK field.<br>TCP 段的内容以缩写的形式显示，包括序列号、控制标志和 ACK 字段。</p><p>Other fields such as window, addresses, lengths, and text have been left out in the interest of clarity.<br>为清楚起见，省略了其他字段，如窗口、地址、长度和文本。</p><pre tabindex=0><code>      TCP A                                                 TCP B
  1.  CLOSED                                                LISTEN
  2.  SYN-SENT    --&gt; &lt;SEQ=100&gt;&lt;CTL=SYN&gt;                --&gt; SYN-RECEIVED
  3.  ESTABLISHED &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt;   &lt;-- SYN-RECEIVED
  4.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;       --&gt; ESTABLISHED
  5.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;&lt;DATA&gt; --&gt; ESTABLISHED
</code></pre><div class=text-center><p>Basic 3-Way Handshake for Connection Synchronization<br>用于连接同步的基础三次握手协议</p><p>Figure 7.</p></div><p>n line 2 of figure 7, TCP A begins by sending a SYN segment indicating that it will use sequence numbers starting with sequence number 100.<br>在图 9 的第 2 行，TCP A 开始发送一个 SYN 段，表明它将使用从序列号 100 开始的序列号。</p><p>In line 3, TCP B sends a SYN and acknowledges the SYN it received from TCP A.<br>在第 3 行，TCP B 发送了一个 SYN，并确认了它从 TCP A 收到的 SYN。</p><p>Note that the acknowledgment field indicates TCP B is now expecting to hear sequence 101, acknowledging the SYN which occupied sequence 100.<br>注意，确认字段表明 TCP B 现在期望收到到序列 101，确认收到序列 100 的 SYN。</p><p>At line 4, TCP A responds with an empty segment containing an ACK for TCP B&rsquo;s SYN; and in line 5, TCP A sends some data.<br>在第 4 行，TCP A 发送一个包含 ACK 的空段回应 TCP B 的 SYN；在第 5 行，TCP A 发送了一些数据。</p><p>Note that the sequence number of the segment in line 5 is the same as in line 4 because the ACK does not occupy sequence number space (if it did, we would wind up ACKing ACK&rsquo;s!).<br>请注意，第 5 行的 TCP 段的序列号与第 4 行相同，因为 ACK 不占用序列号空间（如果它占用了，我们就会变成 ACK 的 ACK！）。</p><p>Simultaneous initiation is only slightly more complex, as is shown in figure 10.<br>同时建立连接只是稍微复杂一些，如图 8 所示。</p><p>Each TCP cycles from CLOSED to SYN-SENT to SYN-RECEIVED to ESTABLISHED.<br>每个 TCP 从 CLOSED 到 SYN-SENT 到 SYN-RECEIVED 到 ESTABLISHED 循环。</p><pre tabindex=0><code>      TCP A                                        TCP B
  1.  CLOSED                                           CLOSED
  2.  SYN-SENT     --&gt; &lt;SEQ=100&gt;&lt;CTL=SYN&gt;              ...
  3.  SYN-RECEIVED &lt;-- &lt;SEQ=300&gt;&lt;CTL=SYN&gt;              &lt;-- SYN-SENT
  4.               ... &lt;SEQ=100&gt;&lt;CTL=SYN&gt;              --&gt; SYN-RECEIVED
  5.  SYN-RECEIVED --&gt; &lt;SEQ=100&gt;&lt;ACK=301&gt;&lt;CTL=SYN,ACK&gt; ...
  6.  ESTABLISHED  &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt; &lt;-- SYN-RECEIVED
  7.               ... &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;     --&gt; ESTABLISHED
</code></pre><div class=text-center><p>Simultaneous Connection Synchronization<br>同时连接同步</p><p>Figure 8.</p></div><p>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.<br>三次握手的主要原因是为了防止旧的重复连接启动造成混乱。</p><p>To deal with this, a special control message, reset, has been devised.<br>为了解决这个问题，我们设计了一个特殊的控制消息&ndash;reset。</p><p>If the receiving TCP is in a non-synchronized state (i.e., SYN-SENT, SYN-RECEIVED), it returns to LISTEN on receiving an acceptable reset.<br>如果接收的 TCP 处于非同步状态（即 SYN-SENT，SYN-RECEIVED），它在收到有效的 reset 时返回到 LISTEN。</p><p>If the TCP is in one of the synchronized states (ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT), it aborts the connection and informs its user.<br>如果 TCP 处于同步状态之一（ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT），它将中止连接并通知其用户。</p><p>We discuss this latter case under &ldquo;half-open&rdquo; connections below.<br>我们将在下面的 &ldquo;half-open&rdquo; 连接下讨论后面一种情况。</p><pre tabindex=0><code>      TCP A                                                TCP B
  1.  CLOSED                                               LISTEN
  2.  SYN-SENT    --&gt; &lt;SEQ=100&gt;&lt;CTL=SYN&gt;               ...
  3.  (duplicate) ... &lt;SEQ=90&gt;&lt;CTL=SYN&gt;                --&gt; SYN-RECEIVED
  4.  SYN-SENT    &lt;-- &lt;SEQ=300&gt;&lt;ACK=91&gt;&lt;CTL=SYN,ACK&gt;   &lt;-- SYN-RECEIVED
  5.  SYN-SENT    --&gt; &lt;SEQ=91&gt;&lt;CTL=RST&gt;                --&gt; LISTEN
  6.              ... &lt;SEQ=100&gt;&lt;CTL=SYN&gt;               --&gt; SYN-RECEIVED
  7.  SYN-SENT    &lt;-- &lt;SEQ=400&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt;  &lt;-- SYN-RECEIVED
  8.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=401&gt;&lt;CTL=ACK&gt;      --&gt; ESTABLISHED
</code></pre><div class=text-center><p>Recovery from Old Duplicate SYN<br>从之前重复 SYN 中恢复</p><p>Figure 9.</p></div><p>As a simple example of recovery from old duplicates, consider figure 9.<br>从之前重复 SYN 中恢复的简单示例，请参见图 9。</p><p>At line 3, an old duplicate SYN arrives at TCP B.<br>在第 3 行，一个之前重复 SYN 到达了 TCP B。</p><p>TCP B cannot tell that this is an old duplicate, so it responds normally (line 4).<br>TCP B 无法断定这是之前的 SYN，所以它正常响应（第 4 行）。</p><p>TCP A detects that the ACK field is incorrect and returns a RST (reset) with its SEQ field selected to make the segment believable.<br>TCP A 检测到 ACK 字段不正确，然后返回一个 RST（重置），同时选择 SEQ 字段以使该 TCP 段可信。</p><p>TCP B, on receiving the RST, returns to the LISTEN state.<br>TCP B 收到 RST 后，返回到 LISTEN 状态。</p><p>When the original SYN (pun intended) finally arrives at line 6, the synchronization proceeds normally.<br>在第 6 行，当真正的 SYN（双关语）最终到达时，同步正常进行。</p><p>If the SYN at line 6 had arrived before the RST, a more complex exchange might have occurred with RST&rsquo;s sent in both directions.<br>如果第 6 行的 SYN 在 RST 之前到达，则可能会发生更复杂的交换，双方都会发送 RST。</p><p><strong>Half-Open Connections and Other Anomalies</strong><br><strong>半开放连接和其他异常情况</strong></p><p>An established connection is said to be &ldquo;half-open&rdquo; if one of the TCPs has closed or aborted the connection at its end without the knowledge of the other, or if the two ends of the connection have become desynchronized owing to a crash that resulted in loss of memory.<br>如果其中一个 TCP 在另一个不知道的情况下关闭或中止了连接，或者连接的两端由于崩溃导致内存丢失而变得不同步，则已建立的连接被称为 &ldquo;半开放&rdquo;。</p><p>Such connections will automatically become reset if an attempt is made to send data in either direction.<br>如果尝试向任一方向发送数据，这种连接将自动重置。</p><p>However, half-open connections are expected to be unusual, and the recovery procedure is mildly involved.<br>然而，半开放连接被认为是不正常的，恢复过程也涉及到一些问题。</p><p>If at site A the connection no longer exists, then an attempt by the user at site B to send any data on it will result in the site B TCP receiving a reset control message.<br>如果站点 A 的连接不再存在，那么站点 B 的用户试图在其上发送任何数据将导致站点 B 的 TCP 收到重置控制消息。</p><p>Such a message should indicate to the site B TCP that something is wrong, and it is expected to abort the connection.<br>这种消息表明 B 的 TCP 有问题，并希望它能中止连接。</p><p>Assume that two user processes A and B are communicating with one another when a crash occurs causing loss of memory to A&rsquo;s TCP.<br>假设两个用户进程 A 和 B 正在相互通信，当发生崩溃导致 A 的 TCP 丢失内存时。</p><p>Depending on the operating system supporting A&rsquo;s TCP, it is likely that some error recovery mechanism exists.<br>可能会存在一些错误恢复机制，这取决于 TCP A 所运行的操作系统。</p><p>When the TCP is up again, A is likely to start again from the beginning or from a recovery point.<br>当 TCP 再次启动时，A 可能会从头或从某个恢复点重新启动。</p><p>As a result, A will probably try to OPEN the connection again or try to SEND on the connection it believes open.<br>因此，A 可能会尝试再次打开连接或尝试在它认为已经打开的连接上发送。</p><p>In the latter case, it receives the error message &ldquo;connection not open&rdquo; from the local (A&rsquo;s) TCP.<br>在后面一种情况下，它会收到来自本地(A) TCP 的错误消息 &ldquo;Connection Not Open&rdquo;。</p><p>In an attempt to establish the connection, A&rsquo;s TCP will send a segment containing SYN.<br>在尝试建立连接时，A 的 TCP 将发送包含 SYN 的 TCP 段。</p><p>This scenario leads to the example shown in figure 10.<br>这种情况的示例如图 10 所示。</p><p>After TCP A crashes, the user attempts to re-open the connection.<br>在 TCP A 崩溃后，用户试图重新打开连接。</p><p>TCP B, in the meantime, thinks the connection is open.<br>在此期间，TCP B 认为连接是打开的。</p><pre tabindex=0><code>      TCP A                                           TCP B
  1.  (CRASH)                               (send 300,receive 100)
  2.  CLOSED                                           ESTABLISHED
  3.  SYN-SENT --&gt; &lt;SEQ=400&gt;&lt;CTL=SYN&gt;              --&gt; (??)
  4.  (!!)     &lt;-- &lt;SEQ=300&gt;&lt;ACK=100&gt;&lt;CTL=ACK&gt;     &lt;-- ESTABLISHED
  5.  SYN-SENT --&gt; &lt;SEQ=100&gt;&lt;CTL=RST&gt;              --&gt; (Abort!!)
  6.  SYN-SENT                                         CLOSED
  7.  SYN-SENT --&gt; &lt;SEQ=400&gt;&lt;CTL=SYN&gt;              --&gt;
</code></pre><div class=text-center><p>Half-Open Connection Discovery<br>半开放连接发现</p><p>Figure 10.</p></div><p>When the SYN arrives at line 3, TCP B, being in a synchronized state, and the incoming segment outside the window, responds with an acknowledgment indicating what sequence it next expects to hear (ACK 100).<br>在第 3 行，当 SYN 到达时，TCP B 处于同步状态，而接收段在接收窗口之外，返回一个确认，ACK=100，表示它期望收到的下一个序列号。</p><p>TCP A sees that this segment does not acknowledge anything it sent and, being unsynchronized, sends a reset (RST) because it has detected a half-open connection.<br>TCP A 看到这个 TCP 段没有确认它所发送的任何东西，并且由于不同步，发送了一个重置（RST），因为它检测到一个半开放的连接。</p><p>TCP B aborts at line 5.<br>在第 5 行，TCP B 终止。</p><p>TCP A will continue to try to establish the connection; the problem is now reduced to the basic 3-way handshake of figure 9.<br>TCP A 会继续尝试建立连接；问题现在简化为图 7 中基础的三次握手。</p><p>An interesting alternative case occurs when TCP A crashes and TCP B tries to send data on what it thinks is a synchronized connection.<br>另一种有趣的情况是，当 TCP A 崩溃，而 TCP B 尝试在它认为是同步的连接上发送数据时。</p><p>This is illustrated in figure 13.<br>图 13 说明了这种情况。</p><p>In this case, the data arriving at TCP A from TCP B (line 2) is unacceptable because no such connection exists, so TCP A sends a RST.<br>在这种情况下，从 TCP B 到达 TCP A 的数据（第 2 行）是无效的，因为不存在这样的连接，所以 TCP A 发送了一个 RST。</p><p>The RST is acceptable so TCP B processes it and aborts the connection.<br>RST 是有效的，所以 TCP B 处理它并终止连接。</p><pre tabindex=0><code>      TCP A                                           TCP B
  1.  (CRASH)                                   (send 300,receive 100)
  2.  (??)    &lt;-- &lt;SEQ=300&gt;&lt;ACK=100&gt;&lt;DATA=10&gt;&lt;CTL=ACK&gt; &lt;-- ESTABLISHED
  3.          --&gt; &lt;SEQ=100&gt;&lt;CTL=RST&gt;                   --&gt; (ABORT!!)
</code></pre><div class=text-center><p>Active Side Causes Half-Open Connection Discovery<br>活跃端导致半开放连接的发现</p><p>Figure 13.</p></div><p>In figure 12, we find the two TCPs A and B with passive connections waiting for SYN.<br>在图 12 中，我们发现两个 TCPs A 和 B 是被动连接等待 SYN。</p><p>An old duplicate arriving at TCP B (line 2) stirs B into action.<br>一个以前重复的 SYN 到达 TCP B（第 2 行），导致 B 做出回应。</p><p>A SYN-ACK is returned (line 3) and causes TCP A to generate a RST (the ACK in line 3 is not acceptable).<br>一个 SYN-ACK 被返回（第 3 行），并导致 TCP A 产生一个 RST（第 3 行的 ACK 是无效的）。</p><p>TCP B accepts the reset and returns to its passive LISTEN state.<br>TCP B 接受重置，并返回到其被动的 LISTEN 状态。</p><pre tabindex=0><code>      TCP A                                         TCP B
  1.  LISTEN                                        LISTEN
  2.       ... &lt;SEQ=Z&gt;&lt;CTL=SYN&gt;                --&gt;  SYN-RECEIVED
  3.  (??) &lt;-- &lt;SEQ=X&gt;&lt;ACK=Z+1&gt;&lt;CTL=SYN,ACK&gt;   &lt;--  SYN-RECEIVED
  4.       --&gt; &lt;SEQ=Z+1&gt;&lt;CTL=RST&gt;              --&gt;  (return to LISTEN!)
  5.  LISTEN                                        LISTEN
</code></pre><div class=text-center><p>Old Duplicate SYN Initiates a Reset on two Passive Sockets<br>以前重复 SYN 在两个被动套接字上启动重置</p><p>Figure 12.</p></div><p>A variety of other cases are possible, all of which are accounted for by the following rules for RST generation and processing.<br>可能存在多种其他情况，所有这些情况都可以通过以下 RST 生成和处理规则解释。</p><p><strong>Reset Generation</strong><br><strong>重置生成</strong></p><p>As a general rule, reset (RST) should be sent whenever a segment arrives which apparently is not intended for the current or a future incarnation of the connection.<br>作为一般规则，当一个 TCP 段到达时，如果显然不是为当前或未来的连接准备的，就应该发送复位（RST）。</p><p>A reset should not be sent if it is not clear that this is the case.<br>如果不清楚是这种情况，就不应该发送重置段。</p><p>There are three groups of states:<br>有三组状态：</p><p>1.If the connection does not exist (CLOSED) then a reset is sent in response to any incoming segment except another reset.<br>1.如果连接不存在（CLOSED），那么除了收到的是一个重置段之外，对其它任何收到的段都会回复一个重置段。</p><p>In particular, SYNs addressed to a non-existent connection are rejected by this means.<br>特别是，通过这种方式拒绝向不存在的连接发送的 SYN。</p><p>If the incoming segment has an ACK field, the reset takes its sequence number from the ACK field of the segment, otherwise the reset has sequence number zero and the ACK field is set to the sum of the sequence number and segment length of the incoming segment.<br>如果接收的段有 ACK 字段，重置从该段的 ACK 字段中获取其序列号，否则重置的序列号为 0，ACK 字段设置为接收段的序列号和段长之和。</p><p>The connection remains in the CLOSED state.<br>连接保持关闭状态。</p><p>2.If the connection is in any non-synchronized state (LISTEN, SYN-SENT, SYN-RECEIVED), and the incoming segment acknowledges something not yet sent (the segment carries an unacceptable ACK), or if an incoming segment has a security level or compartment which does not exactly match the level and compartment requested for the connection, a reset is sent.<br>2.如果连接处于任何非同步状态（LISTEN、SYN-SENT、SYN-RECEIVED），并且接收段确认没有发送的内容（该段携带无效的 ACK），或者如果接收段具有安全等级或区段与连接请求的层级和区段不完全匹配，则会发送重置。</p><p>If our SYN has not been acknowledged and the precedence level of the incoming segment is higher than the precedence level requested then either raise the local precedence level (if allowed by the user and the system) or send a reset; or if the precedence level of the incoming segment is lower than the precedence level requested then continue as if the precedence matched exactly (if the remote TCP cannot raise the precedence level to match ours this will be detected in the next segment it sends, and the connection will be terminated then).<br>如果我们的 SYN 未被确认并且接收段的优先级高于请求的优先级，则提高本地优先级（如果用户和系统允许）或发送重置； 或者，如果接收段的优先级低于请求的优先级，则继续，就好像优先级完全匹配一样（如果远程 TCP 无法提高优先级以匹配我们的优先级，这将在它发送的下一个段中检测到，并且连接将被终止）。</p><p>If our SYN has been acknowledged (perhaps in this incoming segment) the precedence level of the incoming segment must match the local precedence level exactly, if it does not a reset must be sent.<br>如果我们的 SYN 已被确认（可能在这个接收段中），则接收段的优先级必须与本地优先级完全匹配，否则必须发送重置。</p><p>If the incoming segment has an ACK field, the reset takes its sequence number from the ACK field of the segment, otherwise the reset has sequence number zero and the ACK field is set to the sum of the sequence number and segment length of the incoming segment.<br>如果接收的段有 ACK 字段，重置从该段的 ACK 字段中获取其序列号，否则重置的序列号为 0，ACK 字段设置为接收段的序列号和段长之和。</p><p>The connection remains in the same state.<br>连接保持相同状态。</p><p>3.If the connection is in a synchronized state (ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT), any unacceptable segment (out of window sequence number or unacceptible acknowledgment number) must elicit only an empty acknowledgment segment containing the current send-sequence number and an acknowledgment indicating the next sequence number expected to be received, and the connection remains in the same state.<br>3.如果连接处于同步状态（ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、CLOSE-WAIT、CLOSING、LAST-ACK、TIME-WAIT），任何无效的段（超出窗口序列号或无效的确认号）只需回复一个空确认段，其中包含当前发送序列号和一个表示下一个预期接收序列号的确认，并且连接保持相同状态。</p><p>If an incoming segment has a security level, or compartment, or precedence which does not exactly match the level, and compartment, and precedence requested for the connection,a reset is sent and connection goes to the CLOSED state. The reset takes its sequence number from the ACK field of the incoming segment.<br>如果接收段的安全级别、区段或优先级与连接请求的级别、区段和优先级不完全匹配，则发送重置，连接进入 CLOSED 状态。 重置从接收段的 ACK 字段中获取其序列号。</p><p><strong>Reset Processing</strong><br><strong>重置处理</strong></p><p>In all states except SYN-SENT, all reset (RST) segments are validated by checking their SEQ-fields.<br>在除 SYN-SENT 之外的所有状态中，所有的重置（RST）段都通过检查其 SEQ 字段来验证。</p><p>A reset is valid if its sequence number is in the window.<br>如果重置的序列号在窗口范围中，则重置有效。</p><p>In the SYN-SENT state (a RST received in response to an initial SYN), the RST is acceptable if the ACK field acknowledges the SYN.<br>在 SYN-SENT 状态（接收到响应初始 SYN 的 RST），如果 ACK 字段确认 SYN，则 RST 是有效的。</p><p>The receiver of a RST first validates it, then changes state.<br>RST 的接收者首先验证它，然后改变状态。</p><p>If the receiver was in the LISTEN state, it ignores it.<br>如果接收器处于 LISTEN 状态，就会忽略它。</p><p>If the receiver was in SYN-RECEIVED state and had previously been in the LISTEN state, then the receiver returns to the LISTEN state, otherwise the receiver aborts the connection and goes to the CLOSED state.<br>如果接收方处于 SYN-RECEIVED 状态，并且之前处于 LISTEN 状态，那么接收方返回到 LISTEN 状态，否则接收方中止连接，进入 CLOSED 状态。</p><p>If the receiver was in any other state, it aborts the connection and advises the user and goes to the CLOSED state.<br>如果接收方处于任何其它状态，它将中止连接并通知用户并进入 CLOSED 状态。</p><h3 id=关闭连接>关闭连接
<a class=anchor href=#%e5%85%b3%e9%97%ad%e8%bf%9e%e6%8e%a5>#</a></h3><p><strong>3.5. Closing a Connection</strong></p><p>CLOSE is an operation meaning &ldquo;I have no more data to send.&rdquo;<br>CLOSE 是一个操作，意思是 &ldquo;我没有更多的数据要发送&rdquo;。</p><p>The notion of closing a full-duplex connection is subject to ambiguous interpretation, of course, since it may not be obvious how to treat the receiving side of the connection.<br>当然，关闭全双工连接的概念会有模糊的解释，因为如何处理连接的接收方可能并不明显。</p><p>We have chosen to treat CLOSE in a simplex fashion.<br>我们选择以简单的方式来处理 CLOSE。</p><p>The user who CLOSEs may continue to RECEIVE until he is told that the other side has CLOSED also.<br>主动关闭的用户可以继续接收，直到他被告知另一方也关闭了。</p><p>Thus, a program could initiate several SENDs followed by a CLOSE, and then continue to RECEIVE until signaled that a RECEIVE failed because the other side has CLOSED.<br>因此，一个程序可以多次发送，然后关闭，再继续接收，直到有信号说接收失败，因为对方已经关闭。</p><p>We assume that the TCP will signal a user, even if no RECEIVEs are outstanding, that the other side has closed, so the user can terminate his side gracefully.<br>我们假设，即使没有未完成的接收，TCP 也会通知用户对方已经关闭，所以用户可以优雅地中止自己这端。</p><p>A TCP will reliably deliver all buffers SENT before the connection was CLOSED so a user who expects no data in return need only wait to hear the connection was CLOSED successfully to know that all his data was received at the destination TCP.<br>TCP 将在连接关闭前可靠地发送的所有缓冲区的数据，因此没有数据接收的用户只需等到连接被成功关闭，就能知道他的所有数据已经成功发送到目的地 TCP。</p><p>Users must keep reading connections they close for sending until the TCP says no more data.<br>用户必须继续读取他们关闭发送的连接，直到 TCP 说没有更多数据为止。</p><p>There are essentially three cases:<br>主要有三种情况：</p><p> 1) The user initiates by telling the TCP to CLOSE the connection<br> 1) 用户主动告诉 TCP 关闭连接</p><p> 2) The remote TCP initiates by sending a FIN control signal<br> 2) 远程 TCP 通过发送 FIN 控制标志开始关闭</p><p> 3) Both users CLOSE simultaneously<br> 3) 两个用户同时关闭</p><p>Case 1: Local user initiates the close<br>情况 1：本地用户发起关闭</p><p>In this case, a FIN segment can be constructed and placed on the outgoing segment queue.<br>在这种情况下，会生成一个 FIN 段，并将其加入到发送段队列中。</p><p>No further SENDs from the user will be accepted by the TCP, and it enters the FIN-WAIT-1 state.<br>TCP 将不再接受用户的发送，并进入 FIN-WAIT-1 状态。</p><p>RECEIVEs are allowed in this state.<br>在这种状态下，允许接收</p><p>All segments preceding and including FIN will be retransmitted until acknowledged.<br>在 FIN 之前和包括 FIN 在内的所有段超时将被重传，直到被确认。</p><p>When the other TCP has both acknowledged the FIN and sent a FIN of its own, the first TCP can ACK this FIN.<br>当另一个 TCP 既确认了 FIN 又发送了自己的 FIN 时，第一个 TCP 可以对这个 FIN 进行 ACK。</p><p>It should be noted that a TCP receiving a FIN will ACK but not send its own FIN until its user has CLOSED the connection also.<br>应该注意的是，收到 FIN 的 TCP 会进行 ACK，但不会发送自己的 FIN，直到其用户也关闭了连接。</p><p>Case 2: TCP receives a FIN from the network<br>情况 2：TCP 收到来自网络的 FIN</p><p>If an unsolicited FIN arrives from the network, the receiving TCP can ACK it and tell the user that the connection is closing.<br>如果来自网络的未经请求的 FIN 到达，接收的 TCP 可以确认该 FIN 并告诉用户连接正在关闭。</p><p>The user should respond with a CLOSE, upon which the TCP can send a FIN to the other TCP.<br>用户应该用 CLOSE 来回应，在此基础上，TCP 可以向其他 TCP 发送 FIN。</p><p>The TCP then waits until its own FIN is acknowledged whereupon it deletes the connection.<br>然后，TCP 等待，直到它自己的 FIN 被确认，然后它删除连接。</p><p>If an ACK is not forthcoming, after a timeout the connection is aborted and the user is told.<br>如果没有收到 ACK，在超时后，连接将被终止，并告诉用户。</p><p>Case 3: both users close simultaneously<br>情况 3：两个用户同时关闭</p><p>A simultaneous CLOSE by users at both ends of a connection causes FIN segments to be exchanged.<br>连接两端的用户同时关闭会交换 FIN 段。</p><p>When all segments preceding the FINs have been processed and acknowledged, each TCP can ACK the FIN it has received.<br>当 FIN 之前的所有段都被处理并确认后，每个 TCP 可以对它所收到的 FIN 进行 ACK。</p><p>Both will, upon receiving these ACKs, delete the connection.<br>两者都将在收到这些 ACK 后，删除连接。</p><pre tabindex=0><code>      TCP A                                                TCP B
  1.  ESTABLISHED                                          ESTABLISHED
  2.  (Close)
      FIN-WAIT-1  --&gt; &lt;SEQ=100&gt;&lt;ACK=300&gt;&lt;CTL=FIN,ACK&gt;  --&gt; CLOSE-WAIT
  3.  FIN-WAIT-2  &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=ACK&gt;      &lt;-- CLOSE-WAIT
  4.                                                       (Close)
      TIME-WAIT   &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=FIN,ACK&gt;  &lt;-- LAST-ACK
  5.  TIME-WAIT   --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;      --&gt; CLOSED
  6.  (2 MSL)
      CLOSED
</code></pre><div class=text-center><p>Normal Close Sequence<br>正常关闭序列</p><p>Figure 13.</p></div><pre tabindex=0><code>      TCP A                                                TCP B
  1.  ESTABLISHED                                          ESTABLISHED
  2.  (Close)                                              (Close)
      FIN-WAIT-1  --&gt; &lt;SEQ=100&gt;&lt;ACK=300&gt;&lt;CTL=FIN,ACK&gt;  ... FIN-WAIT-1
                  &lt;-- &lt;SEQ=300&gt;&lt;ACK=100&gt;&lt;CTL=FIN,ACK&gt;  &lt;--
                  ... &lt;SEQ=100&gt;&lt;ACK=300&gt;&lt;CTL=FIN,ACK&gt;  --&gt;
  3.  CLOSING     --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;      ... CLOSING
                  &lt;-- &lt;SEQ=301&gt;&lt;ACK=101&gt;&lt;CTL=ACK&gt;      &lt;--
                  ... &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;      --&gt;
  4.  TIME-WAIT                                            TIME-WAIT
      (2 MSL)                                              (2 MSL)
      CLOSED                                               CLOSED
</code></pre><div class=text-center><p>Simultaneous Close Sequence<br>同时关闭序列</p><p>Figure 14.</p></div><h3 id=优先级和安全性-1>优先级和安全性
<a class=anchor href=#%e4%bc%98%e5%85%88%e7%ba%a7%e5%92%8c%e5%ae%89%e5%85%a8%e6%80%a7-1>#</a></h3><p><strong>3.6. Precedence and Security</strong></p><p>The intent is that connection be allowed only between ports operating with exactly the same security and compartment values and at the higher of the precedence level requested by the two ports.<br>目的是只允许在以完全相同的安全和区段值运行的端口之间进行连接，并且使用两端要求较高的优先级。</p><p>The precedence and security parameters used in TCP are exactly those defined in the Internet Protocol (IP) [2].<br>TCP 中使用的优先级和安全参数与网际互连协议 (IP) 中定义的完全相同[2] 。</p><p>Throughout this TCP specification the term &ldquo;security/compartment&rdquo; is intended to indicate the security parameters used in IP including security, compartment, user group, and handling restriction.<br>在本 TCP 规范中，术语 &ldquo;安全/区段&rdquo; 旨在表示 IP 中使用的安全参数，包括安全、区段、用户组和处理限制。</p><p>A connection attempt with mismatched security/compartment values or a lower precedence value should be rejected by sending a reset.<br>通过发送重置段来拒绝安全/区段值不匹配或优先级较低的连接尝试。</p><p>Rejecting a connection due to too low a precedence only occurs after an acknowledgment of the SYN has been received.<br>因为优先级太低而拒绝连接只会在收到 SYN 确认后发生。</p><p>Note that TCP modules which operate only at the default value of precedence will still have to check the precedence of incoming segments and possibly raise the precedence level they use on the connection.<br>请注意，只在默认优先级值下运行的 TCP 模块仍然需要检查接收段的优先级，并可能提高它们在连接上使用的优先级。</p><p>The security paramaters may be used even in a non-secure environment (the values would indicate unclassified data), thus hosts in non-secure environments must be prepared to receive the security parameters, though they need not send them.<br>安全参数甚至可以在非安全环境中使用（这些值将表示非保密数据），因此非安全环境中的主机必须准备好接收安全参数，尽管它们不需要发送它们。</p><h3 id=数据通信-1>数据通信
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e9%80%9a%e4%bf%a1-1>#</a></h3><p><strong>3.7. Data Communication</strong></p><p>Once the connection is established data is communicated by the exchange of segments.<br>一旦建立了连接，就通过交换 TCP 段来传递数据。</p><p>Because segments may be lost due to errors (checksum test failure), or network congestion, TCP uses retransmission (after a timeout) to ensure delivery of every segment.<br>由于 TCP 段可能因错误（校验和测试失败）或网络拥堵而丢失，TCP 使用重传（超时后）来确保每个段的交付。</p><p>Duplicate segments may arrive due to network or TCP retransmission.<br>由于网络或 TCP 重传，可能会出现重复的 TCP 段。</p><p>As discussed in the section on sequence numbers the TCP performs certain tests on the sequence and acknowledgment numbers in the segments to verify their acceptability.<br>正如在序列号一节中所讨论的，TCP 对段中的序列号和确认号进行某些测试，以验证其是否有效。</p><p>The sender of data keeps track of the next sequence number to use in the variable SND.NXT.<br>数据发送方在变量 SND.NXT 中记录下一个要使用的序列号。</p><p>The receiver of data keeps track of the next sequence number to expect in the variable RCV.NXT.<br>数据接收方在变量 RCV.NXT 中保存下一个期望的序列号。</p><p>The sender of data keeps track of the oldest unacknowledged sequence number in the variable SND.UNA.<br>数据发送方在变量 SND.UNA 中跟踪最久的未确认的序列号。</p><p>If the data flow is momentarily idle and all data sent has been acknowledged then the three variables will be equal.<br>如果数据流暂时处于空闲状态，并且所有发送的数据都被确认，那么这三个变量将是相等的。</p><p>When the sender creates a segment and transmits it the sender advances SND.NXT.<br>当发送方创建一个 TCP 段并发送时，发送方会推进 SND.NXT。</p><p>When the receiver accepts a segment it advances RCV.NXT and sends an acknowledgment.<br>当接收方接收一个 TCP 段时，它推进 RCV.NXT 并发送一个确认。</p><p>When the data sender receives an acknowledgment it advances SND.UNA.<br>当数据发送方收到确认时，它会推进 SND.UNA。</p><p>The extent to which the values of these variables differ is a measure of the delay in the communication.<br>这些变量值的不同程度是衡量通信延迟的一个标准。</p><p>The amount by which the variables are advanced is the length of the data in the segment.<br>通常情况下，变量推进的数量是 TCP 段中数据的长度。</p><p>Note that once in the ESTABLISHED state all segments must carry current acknowledgment information.<br>请注意，一旦处于 ESTABLISHED 状态，所有段都必须携带当前确认信息。</p><p>The CLOSE user call implies a push function, as does the FIN control flag in an incoming segment.<br>CLOSE 用户调用暗示推送功能，接收段中的 FIN 控制标志也是如此。</p><p><strong>Retransmission Timeout</strong><br><strong>重传超时</strong></p><p>Because of the variability of the networks that compose an internetwork system and the wide range of uses of TCP connections the retransmission timeout must be dynamically determined.<br>由于构成互联网系统的网络的可变性和 TCP 连接的广泛使用，重传超时必须动态地确定。</p><p>One procedure for determining a retransmission time out is given here as an illustration.<br>这里给出一个确定重传超时的程序，作为说明。</p><p>An Example Retransmission Timeout Procedure<br>重传超时程序示例</p><p>Measure the elapsed time between sending a data octet with a particular sequence number and receiving an acknowledgment that covers that sequence number (segments sent do not have to match segments received).<br>测量发送具有特定序列号的数据与接收到包含该序列号的确认之间经过的时间（发送的段不必与接收到的段匹配）。</p><p>This measured elapsed time is the Round Trip Time (RTT). Next compute a Smoothed Round Trip Time (SRTT) as:<br>此测量的经过时间是往返时间 (RTT)， 接下来计算平滑往返时间 (SRTT) 为：</p><p>SRTT = ( ALPHA * SRTT ) + ((1-ALPHA) * RTT)</p><p>and based on this, compute the retransmission timeout (RTO) as:<br>并在此基础上，计算出重传超时（RTO）为：</p><p>RTO = min[UBOUND,max[LBOUND,(BETA*SRTT)]]</p><p>where UBOUND is an upper bound on the timeout (e.g., 1 minute), LBOUND is a lower bound on the timeout (e.g., 1 second), ALPHA is a smoothing factor (e.g., .8 to .9), and BETA is a delay variance factor (e.g., 1.3 to 2.0).<br>其中 UBOUND 是超时的上限（如 1 分钟），LBOUND 是超时的下限（如 1 秒），ALPHA 是平滑系数（如 0.8 至 0.9），BETA 是延迟差异系数（如 1.3 至 2.0）。</p><p><strong>The Communication of Urgent Information</strong><br><strong>紧急信息的传递</strong></p><p>The objective of the TCP urgent mechanism is to allow the sending user to stimulate the receiving user to accept some urgent data and to permit the receiving TCP to indicate to the receiving user when all the currently known urgent data has been received by the user.<br>TCP 紧急机制的目的是允许发送者促使接收者接收一些紧急数据，并允许接收 TCP 告知接收者，用户何时已经接收到所有当前已知的紧急数据。</p><p>This mechanism permits a point in the data stream to be designated as the end of &ldquo;urgent&rdquo; information.<br>这一机制允许将数据流中的某一点指定为 &ldquo;紧急&rdquo; 信息的终点。</p><p>Whenever this point is in advance of the receive sequence number (RCV.NXT) at the receiving TCP, that TCP should tell the user to go into &ldquo;urgent mode&rdquo;; when the receive sequence number catches up to the urgent pointer, the TCP should tell user to go into &ldquo;normal mode&rdquo;.<br>只要这个点在接收 TCP 的接收序列号（RCV.NXT）之前，该 TCP 就应该告诉用户进入 &ldquo;紧急模式&rdquo;；当接收序列号赶上紧急指针时，该 TCP 应该告诉用户进入 &ldquo;正常模式&rdquo;。</p><p>If the urgent pointer is updated while the user is in &ldquo;urgent mode&rdquo;, the update will be invisible to the user.<br>如果紧急指针在用户处于 &ldquo;紧急模式&rdquo; 时被更新，用户将看不到更新。</p><p>The method employs a urgent field which is carried in all segments transmitted.<br>该方法使用了一个紧急字段，它在所有传输的段中都会携带。</p><p>The URG control flag indicates that the urgent field is meaningful and should be added to the segment sequence number to yield the urgent pointer.<br>URG 控制标志表示紧急字段是有效的，应该加到段序列号中，以产生紧急指针。</p><p>The absence of this flag indicates that the urgent pointer has not changed.<br>没有这个标志表示紧急指针没有变化。</p><p>To send an urgent indication the user must also send at least one data octet.<br>要发送一个紧急指令，用户也必须发送至少一个字节的数据。</p><p>If the sending user also indicates a push, timely delivery of the urgent information to the destination process is enhanced.<br>如果发送用户也指示推送，则紧急信息会被更加及时地传递到目的地的进程。</p><p><strong>Managing the Window</strong><br><strong>管理窗口</strong></p><p>The window sent in each segment indicates the range of sequence number the sender of the window (the data receiver) is currently prepared to accept.<br>每个 TCP 段中发送的窗口表示窗口的发送方（数据接收方）目前准备接受的序列号范围。</p><p>There is an assumption that this is related to the currently available data buffer space available for this connection.<br>有一种假设是，这与当前可用于该连接的数据缓冲区空间有关。</p><p>Indicating a large window encourages transmissions.<br>发送较大的窗口有利于传输。</p><p>If more data arrives than can be accepted, it will be discarded.<br>如果接收的数据超过了可接受的范围，那么将被丢弃。</p><p>This will result in excessive retransmissions, adding unnecessarily to the load on the network and the TCPs.<br>这将导致过度的重传，增加不必要地网络和 TCP 的负载。</p><p>Indicating a small window may restrict the transmission of data to the point of introducing a round trip delay between each new segment transmitted.<br>发送较小的窗口可能会限制数据的传输，以至于在每个新传输段之间引入一个往返延迟。</p><p>The mechanisms provided allow a TCP to advertise a large window and to subsequently advertise a much smaller window without having accepted that much data.<br>这种机制允许 TCP 发送一个大窗口，并随后在不需要接收那么多数据时发送一个小得多的窗口。</p><p>This, so called &ldquo;shrinking the window,&rdquo; is strongly discouraged.<br>这就是所谓的 &ldquo;缩减窗口&rdquo;，是被强烈反对的。</p><p>The robustness principle dictates that TCPs will not shrink the window themselves, but will be prepared for such behavior on the part of other TCPs.<br>稳健性原则决定了 TCP 不会自己缩减窗口，但会对其他 TCP 的这种行为做好准备。</p><p>The sending TCP must be prepared to accept and send at least one octet of new data even if the send window is zero.<br>发送 TCP 必须准备好接收和发送至少一个字节的新数据，即使发送窗口为 0。</p><p>The sending TCP must regularly retransmit to the receiving TCP even when the window is zero.<br>即使窗口为 0，发送的 TCP 也要定期向接收的 TCP 重传。</p><p>Two minutes is recommended for the retransmission interval when the window is zero.<br>当窗口为 0 时，建议重传间隔为 2 分钟。</p><p>This retransmission is essential to guarantee that when either TCP has a zero window the re-opening of the window will be reliably reported to the other.<br>这种重传对于保证任一个窗口为 0 的 TCP，当窗口的重新打开将可靠地报告给另一端是非常重要的。</p><p>When the receiving TCP has a zero window and a segment arrives it must still send an acknowledgment showing its next expected sequence number and current window (zero).<br>当接收 TCP 的窗口大小为 0 并且收到段时，它仍然需要发送一个确认，表示它的下一个预期序列号和当前窗口（0）。</p><p>The sending TCP packages the data to be transmitted into segments which fit the current window, and may repackage segments on the retransmission queue.<br>发送 TCP 把要传输的数据打包成适合当前窗口的段，并可能在重传队列中重新打包段。</p><p>Such repackaging is not required, but may be helpful.<br>这种重新打包不是必须的，但可能会有用。</p><p>In a connection with a one-way data flow, the window information will be carried in acknowledgment segments that all have the same sequence number so there will be no way to reorder them if they arrive out of order.<br>在一个单向数据流的连接中，窗口信息将携带在确认段中，这些确认段都有相同的序列号，所以如果它们不按顺序到达，就没有办法重新排序。</p><p>This is not a serious problem, but it will allow the window information to be on occasion temporarily based on old reports from the data receiver.<br>这不是一个严重的问题，但它会让窗口信息偶尔暂时基于数据接收者之前的信息。</p><p>A refinement to avoid this problem is to act on the window information from segments that carry the highest acknowledgment number (that is segments with acknowledgment number equal or greater than the highest previously received).<br>避免这一问题的改进方法是，更新带有最高确认号的段的窗口信息（即确认号等于或大于先前收到的最高确认号的段）。</p><p>The window management procedure has significant influence on the communication performance. The following comments are suggestions to implementers.<br>窗口管理程序对通信性能有重要影响。以下是给实现者的建议。</p><p>Window Management Suggestions<br>窗口管理建议</p><p>Allocating a very small window causes data to be transmitted in many small segments when better performance is achieved using fewer large segments.<br>分配一个非常小的窗口会导致数据在许多小段中传输，使用较少的大段可以获得更好的性能。</p><p>One suggestion for avoiding small windows is for the receiver to defer updating a window until the additional allocation is at least X percent of the maximum allocation possible for the connection (where X might be 20 to 40).<br>避免小窗口的一个建议是，接收方推迟更新一个窗口，直到额外的分配至少是该连接可能的最大分配的 X%（其中 X 可能是 20 到 40）。</p><p>Another suggestion is for the sender to avoid sending small segments by waiting until the window is large enough before sending data.<br>另一个建议是发送方通过等到窗口足够大后再发送数据来避免发送小段。</p><p>If the the user signals a push function then the data must be sent even if it is a small segment.<br>如果用户发出推送功能信号，则即使是一小段数据也必须发送。</p><p>Note that the acknowledgments should not be delayed or unnecessary retransmissions will result.<br>注意，确认不应该延迟，否则将导致不必要的重传。</p><p>One strategy would be to send an acknowledgment when a small segment arrives (with out updating the window information), and then to send another acknowledgment with new window information when the window is larger.<br>一种策略是在小段到达时发送确认（不更新窗口信息），然后在窗口较大时发送带有新窗口信息的另一个确认。</p><p>The segment sent to probe a zero window may also begin a break up of transmitted data into smaller and smaller segments.<br>为探测零窗口而发送的段也可能开始将传输的数据分解成越来越小的段。</p><p>If a segment containing a single data octet sent to probe a zero window is accepted, it consumes one octet of the window now available.<br>如果发送一个包含单个字节的数据段去探测零窗口被接受，它就会消耗现在可用窗口的一个字节。</p><p>If the sending TCP simply sends as much as it can whenever the window is non zero, the transmitted data will be broken into alternating big and small segments.<br>如果发送 TCP 在窗口非零时尽可能多地发送，则传输的数据将分成大小交替的段。</p><p>As time goes on, occasional pauses in the receiver making window allocation available will result in breaking the big segments into a small and not quite so big pair.<br>随着时间的推移，接收者偶尔的暂停使窗口分配可用，将导致大的片段被分成小的和不太大的一对。</p><p>And after a while the data transmission will be in mostly small segments.
而在一段时间后，数据传输将大多是小段的。</p><p>The suggestion here is that the TCP implementations need to actively attempt to combine small window allocations into larger windows, since the mechanisms for managing the window tend to lead to many small windows in the simplest minded implementations.<br>这里的建议是，TCP 实现需要积极尝试将小窗口分配合并到更大的窗口中，因为管理窗口的机制往往导致最简单的实现中出现许多小窗口。</p><h3 id=接口-2>接口
<a class=anchor href=#%e6%8e%a5%e5%8f%a3-2>#</a></h3><p><strong>3.8. Interfaces</strong></p><p>There are of course two interfaces of concern: the user/TCP interface and the TCP/IP interface.<br>有两个值得关注的接口：用户/TCP 接口和 TCP/IP 接口。</p><p>We have a fairly elaborate model of the user/TCP interface, but the interface to the lower level protocol module is left unspecified here, since it will be specified in detail by the specification of the lowel level protocol.<br>我们有一个相当详细的用户/TCP 接口模型，但是这里没有指定下层协议模块的接口，因为它将在下层协议的规范中详细说明。</p><p>For the case that the lower level is IP we note some of the parameter values that TCPs might use.<br>对于下层是 IP 协议的情况，我们注意到 TCP 可能使用的一些参数值。</p><p><strong>User/TCP Interface</strong><br><strong>用户/TCP 接口</strong></p><p>The following functional description of user commands to the TCP is, at best, fictional, since every operating system will have different facilities.<br>下面对 TCP 的用户命令的功能描述几乎是抽象的，因为每个操作系统会有不同的特点。</p><p>Consequently, we must warn readers that different TCP implementations may have different user interfaces.<br>因此，我们必须提示读者，不同的 TCP 实现可能有不同的用户接口。</p><p>However, all TCPs must provide a certain minimum set of services to guarantee that all TCP implementations can support the same protocol hierarchy.<br>然而，所有的 TCP 都必须提供一个最低限度的服务，以保证所有的 TCP 实现都能支持相同的协议阶层。</p><p>This section specifies the functional interfaces required of all TCP implementations.<br>本节规定了所有 TCP 实现所需的功能接口。</p><p>TCP User Commands<br>TCP 用户命令</p><p>The following sections functionally characterize a USER/TCP interface.<br>下面的章节从功能上描述了 USER/TCP 接口的特性。</p><p>The notation used is similar to most procedure or function calls in high level languages, but this usage is not meant to rule out trap type service calls (e.g., SVCs, UUOs, EMTs).<br>使用的符号类似于高级语言中的大多数过程或函数调用，但这种用法并不意味着排除限定类型的服务调用（例如，SVCs、UUO、EMTs）。</p><p>The user commands described below specify the basic functions the TCP must perform to support interprocess communication.<br>下面描述的用户命令规定了 TCP 必须执行的基本功能，以支持进程间通信。</p><p>Individual implementations should define their own exact format, and may provide combinations or subsets of the basic functions in single calls.<br>不同的实现应该定义自己的具体格式，并且可以在单个调用中提供基本功能的组合或子集。</p><p>In particular, some implementations may wish to automatically OPEN a connection on the first SEND or RECEIVE issued by the user for a given connection.<br>特别是，某些实现可能希望在用户为给定连接发出的第一个 SEND 或 RECEIVE 时自动打开连接。</p><p>In providing interprocess communication facilities, the TCP must not only accept commands, but must also return information to the processes it serves.<br>在提供进程间通信功能时，TCP 不仅需要接受命令，还必须将信息返回给它所服务的进程。</p><p>The latter consists of:<br>后者包括：</p><p>(a) general information about a connection (e.g., interrupts, remote close, binding of unspecified foreign socket).<br>(a) 关于一个连接的基础信息（例如，中断、远程关闭、未指定的外部套接字的绑定）。</p><p>(b) replies to specific user commands indicating success or various types of failure.<br>(b) 对特定用户命令的回复，表明成功或各种类型的失败。</p><p><strong>Open</strong><br><strong>打开</strong></p><p>Format: OPEN (local port, foreign socket, active/passive [, timeout] [, precedence] [, security/compartment] [, options]) -> local connection name<br>格式：OPEN（本地端口，外部套接字，主动/被动 [，超时] [，优先级] [，安全/区段] [，选项]）-> 本地连接名称</p><p>We assume that the local TCP is aware of the identity of the processes it serves and will check the authority of the process to use the connection specified.<br>我们假设本地 TCP 知道它所服务的进程的身份，并将检查进程的权限以使用指定的连接。</p><p>Depending upon the implementation of the TCP, the local network and TCP identifiers for the source address will either be supplied by the TCP or the lower level protocol (e.g., IP).<br>根据 TCP 的实现，本地网络和源地址的 TCP 标识符将由 TCP 或下层协议（例如，IP 协议）提供。</p><p>These considerations are the result of concern about security, to the extent that no TCP be able to masquerade as another one, and so on.<br>这些考虑是出于对安全的关注，以至于没有 TCP 能够伪装成另一个 TCP，等等。</p><p>Similarly, no process can masquerade as another without the collusion of the TCP.<br>同样，如果 TCP 没有串通，任何进程都无法伪装成另一个进程。</p><p>If the active/passive flag is set to passive, then this is a call to LISTEN for an incoming connection.<br>如果主动/被动标志被设置为被动，那么这就是一个调用 LISTEN 以获得一个外部的连接。</p><p>A passive open may have either a fully specified foreign socket to wait for a particular connection or an unspecified foreign socket to wait for any call.<br>一个被动打开可以完全指定一个外部套接字来等待一个特定的连接，也可以有一个不指定的外部套接字来等待任何连接。</p><p>A transmission control block (TCB) is created and partially filled in with data from the OPEN command parameters.<br>创建一个传输控制块 (TCB)，并用来自 OPEN 命令参数的数据部分填充。</p><p>On an active OPEN command, the TCP will begin the procedure to synchronize (i.e., establish) the connection at once.<br>在主动 OPEN 命令上，TCP 将立即开始同步（即建立）连接的过程。</p><p>The timeout, if present, permits the caller to set up a timeout for all data transmitted on the connection.<br>如果存在超时，允许调用者为连接上传输的数据设置一个超时。</p><p>If a buffer is not successfully delivered to the destination within the timeout period, the TCP will abort the connection.<br>如果在超时时间内没有成功将缓冲区送到目的地，TCP 将终止连接。</p><p>The present global default is five minutes.<br>目前全局默认为 5 分钟。</p><p>The TCP or some component of the operating system will verify the users authority to open a connection with the specified precedence or security/compartment.<br>TCP 或操作系统的某些组件会验证用户是否有权以指定的优先级或安全/区段打开连接。</p><p>The absence of precedence or security/compartment specification in the OPEN call indicates the default values should be used.<br>在 OPEN 调用中没有优先级或安全/区段规范，表明应该使用默认值。</p><p>TCP will accept incoming requests as matching only if the security/compartment information is exactly the same and only if the precedence is equal to or higher than the precedence requested in the OPEN call.<br>只有当安全/区段信息完全相同且优先级等于或高于 OPEN 调用中请求的优先级时，TCP 才会匹配收到请求。</p><p>The precedence for the connection is the higher of the values requested in the OPEN call and received from the incoming request, and fixed at that value for the life of the connection.<br>连接的优先级是 OPEN 调用中请求的值和从收到请求中收到的值中较高的一个，并在连接的有效期内固定为该值。</p><p>Implementers may want to give the user control of this precedence negotiation.<br>实现者可能希望让用户控制这种优先级协商。</p><p>For example, the user might be allowed to specify that the precedence must be exactly matched, or that any attempt to raise the precedence be confirmed by the user.<br>例如，可以允许用户指定优先级必须完全匹配，或者经过用户确认后尝试提高优先级。</p><p>A local connection name will be returned to the user by the TCP.<br>TCP 将向用户返回一个本地连接名。</p><p>The local connection name can then be used as a short hand term for the connection defined by the &lt;local socket, foreign socket> pair.<br>然后，本地连接名称可以用作 &lt;local socket, foreign socket> 对定义的连接的简称。</p><p><strong>Send</strong><br><strong>发送</strong></p><p>Format: SEND(local connection name, buffer address, byte count, PUSH flag, URGENT flag [, timeout])<br>格式：SEND(本地连接名, 缓冲区地址, 字节数, PUSH 标志, 紧急标志 [, 超时] )</p><p>This call causes the data contained in the indicated user buffer to be sent on the indicated connection.<br>这个调用将指定的用户缓冲区中包含的数据发送到指定的连接上。</p><p>If the connection has not been opened, the SEND is considered an error.<br>如果连接没有打开，SEND 会出现错误。</p><p>Some implementations may allow users to SEND first; in which case, an automatic OPEN would be done.<br>有些实现可能允许用户先 SEND，在这种情况下，连接会自动打开。</p><p>If the calling process is not authorized to use this connection, an error is returned.<br>如果调用进程没有被授权使用这个连接，将返回错误。</p><p>If the PUSH flag is set, the data must be transmitted promptly to the receiver, and the PUSH bit will be set in the last TCP segment created from the buffer.<br>如果设置了 PUSH 标志，则数据必须立即传输到接收方，PUSH 位将被设置在从缓冲区创建的最后一个 TCP 段中。</p><p>If the PUSH flag is not set, the data may be combined with data from subsequent SENDs for transmission efficiency.<br>如果未设置 PUSH 标志，则数据可能会与来自后续 SEND 的数据合并以提高传输效率。</p><p>If the URGENT flag is set, segments sent to the destination TCP will have the urgent pointer set.<br>如果设置了 URGENT 标志，则发送到目标 TCP 的段将设置紧急指针。</p><p>The receiving TCP will signal the urgent condition to the receiving process if the urgent pointer indicates that data preceding the urgent pointer has not been consumed by the receiving process.<br>如果紧急指针表明紧急指针之前的数据尚未被接收进程消耗，接收 TCP 就会向接收进程发出紧急情况信号。</p><p>The purpose of urgent is to stimulate the receiver to accept some urgent data and to indicate to the receiver when all the currently known urgent data has been received.<br>紧急特性的目的是促使接收方接收一些紧急数据，并向接收方指示何时已经收到当前所有已知的紧急数据。</p><p>The number of times the sending user&rsquo;s TCP signals urgent will not necessarily be equal to the number of times the receiving user will be notified of the presence of urgent data.<br>发送用户的 TCP 发出紧急信号的次数不一定等于接收用户被通知有紧急数据的次数。</p><p>If no foreign socket was specified in the OPEN, but the connection is established (e.g., because a LISTENing connection has become specific due to a foreign segment arriving for the local socket), then the designated buffer is sent to the implied foreign socket.<br>如果在 OPEN 中没有指定外部套接字，但连接已经建立（例如，由于外部段到达本地套接字，监听的连接已经成为特定的连接），那么指定的缓冲区被发送到隐含的外部套接字。</p><p>Users who make use of OPEN with an unspecified foreign socket can make use of SEND without ever explicitly knowing the foreign socket address.<br>对未指定的外部套接字使用 OPEN 的用户可以使用 SEND，而无需明确知道外部套接字地址。</p><p>In some implementations the TCP may notify the user when an unspecified socket is bound.<br>在一些实现中，当绑定了未指定的套接字时，TCP 可以通知用户。</p><p>If a timeout is specified, the current user timeout for this connection is changed to the new one.<br>如果指定了超时，则这个连接的当前用户超时将被改变为新的超时。</p><p>In the simplest implementation, SEND would not return control to the sending process until either the transmission was complete or the timeout had been exceeded. However, this simple method is both subject to deadlocks (for example, both sides of the connection might try to do SENDs before doing any RECEIVEs) and offers poor performance, so it is not recommended.<br>在最简单的实现中，在传输完成或超时之前，Send 不会将控制权归还给发送进程。然而，这种简单的方法会受到死锁的影响(例如，连接的两端可能会在进行任何接收之前尝试进行发送)，并且性能较差，因此不建议使用这种方法。</p><p>A more sophisticated implementation would return immediately to allow the process to run concurrently with network I/O, and, furthermore, to allow multiple SENDs to be in progress.<br>一个更复杂的实现是立即返回，以允许进程与网络 I/O 同时运行，而且，允许多个 SENDs 同时进行。</p><p>Multiple SENDs are served in first come, first served order, so the TCP will queue those it cannot service immediately.<br>多个 SEND 以先到先得的顺序提供服务，因此 TCP 将对无法立即提供服务的 SEND 进行排队。</p><p>We have implicitly assumed an asynchronous user interface in which a SEND later elicits some kind of SIGNAL or pseudo-interrupt from the serving TCP.<br>我们隐式地假设了一个异步的用户接口，在这个接口中，一个 SEND 后来发出了某种 SIGNAL 或来自服务 TCP 的伪中断。</p><p>An alternative is to return a response immediately.<br>另一种方法是立即返回响应。</p><p>For instance, SENDs might return immediate local acknowledgment, even if the segment sent had not been acknowledged by the distant TCP.<br>例如，SENDs 可能会立即返回本地确认，即使发送的段没有被远端 TCP 确认。</p><p>We could optimistically assume eventual success.<br>我们可以乐观地认为最终会成功。</p><p>If we are wrong, the connection will close anyway due to the timeout.<br>如果我们错了，连接将由于超时而关闭。</p><p>In implementations of this kind (synchronous), there will still be some asynchronous signals, but these will deal with the connection itself, and not with specific segments or letters.<br>在这种（同步）的实现中，仍然会有一些异步信号，但这些信号将处理连接本身，而不是处理具体的段或信件。</p><p>In order for the process to distinguish among error or success indications for different SENDs, it might be appropriate for the buffer address to be returned along with the coded response to the SEND request.<br>为了让进程区分不同 SEND 的错误或成功指示，缓冲区地址与对 SEND 请求的编码响应一起返回会更合适。</p><p>TCP-to-user signals are discussed below, indicating the information which should be returned to the calling process.<br>下面会讨论 TCP 到用户的信号，指出应该返回给调用进程的信息。</p><p><strong>Receive</strong><br><strong>接收</strong></p><p>Format: RECEIVE (local connection name, buffer address, byte count) -> byte count, urgent flag, push flag
格式：RECEIVE（本地连接名称，缓冲区地址，字节数）-> 字节数, 紧急标识, 推送标识</p><p>This command allocates a receiving buffer associated with the specified connection.<br>该命令分配一个与指定连接相关的接收缓冲区。</p><p>If no OPEN precedes this command or the calling process is not authorized to use this connection, an error is returned.<br>如果该命令之前没有 OPEN，或者调用进程没有被授权使用该连接，则返回错误。</p><p>In the simplest implementation, control would not return to the calling program until either the buffer was filled, or some error occurred, but this scheme is highly subject to deadlocks.<br>在最简单的实现中，在缓冲区被填满或发生错误之前，控制不会返回给调用程序，但这种方案很容易发生死锁。</p><p>A more sophisticated implementation would permit several RECEIVEs to be outstanding at once.<br>更复杂的实现将允许几个 RECEIVE 同时出现。</p><p>These would be filled as, segments arrive.<br>它们将在收到段时被填充。</p><p>This strategy permits increased throughput at the cost of a more elaborate scheme (possibly asynchronous) to notify the calling program that a PUSH has been seen or a buffer filled.<br>这种策略可以增加吞吐量，但代价是需要一个更复杂的方案（可能是异步的）来通知调用程序收到了 PUSH 或填满了一个缓冲区。</p><p>If enough data arrive to fill the buffer before a PUSH is seen, the PUSH flag will not be set in the response to the RECEIVE.<br>如果在收到 PUSH 之前有足够的数据到达以填充缓冲区，则不会在对 RECEIVE 的响应中设置 PUSH 标志。</p><p>The buffer will be filled with as much data as it can hold.<br>缓冲区会填充尽可能多的数据。</p><p>If a PUSH is seen before the buffer is filled the buffer will be returned partially filled and PUSH indicated.<br>如果在缓冲区填充之前收到 PUSH，则缓冲区将返回部分填充并标志 PUSH。</p><p>If there is urgent data the user will have been informed as soon as it arrived via a TCP-to-user signal.<br>如果有紧急数据，在数据到达后将立即通过 TCP 到用户的信号通知用户。</p><p>The receiving user should thus be in &ldquo;urgent mode&rdquo;.<br>接收用户因此应该进入 &ldquo;紧急模式&rdquo;。</p><p>If the URGENT flag is on, additional urgent data remains.<br>如果 URGENT 标志开启，就有额外的紧急数据存在。</p><p>If the URGENT flag is off, this call to RECEIVE has returned all the urgent data, and the user may now leave &ldquo;urgent mode&rdquo;.<br>如果 URGENT 标志关闭，这个 RECEIVE 的调用已经返回了所有的紧急数据，用户现在可以离开 &ldquo;紧急模式&rdquo;。</p><p>Note that data following the urgent pointer (non-urgent data) cannot be delivered to the user in the same buffer with preceeding urgent data unless the boundary is clearly marked for the user.<br>请注意，紧急指针之后的数据（非紧急数据）不能与前面的紧急数据在同一个缓冲区中传递给用户，除非为用户明确标出了边界。</p><p>To distinguish among several outstanding RECEIVEs and to take care of the case that a buffer is not completely filled, the return code is accompanied by both a buffer pointer and a byte count indicating the actual length of the data received.<br>为了区分几个未完成的 RECEIVE 并处理缓冲区未完全填满的情况，返回代码会附带缓冲区指针和表示接收到的数据的实际长度的字节数。</p><p>Alternative implementations of RECEIVE might have the TCP allocate buffer storage, or the TCP might share a ring buffer with the user.<br>RECEIVE 的其他实现可能会让 TCP 分配缓冲区存储，或者 TCP 与用户共享一个环形缓冲区。</p><p>Close<br>关闭</p><p>Format: CLOSE(local connection name)<br>格式：CLOSE(本地连接名)</p><p>This command causes the connection specified to be closed.<br>该命令关闭指定的连接。</p><p>If the connection is not open or the calling process is not authorized to use this connection, an error is returned.<br>如果连接没有打开，或者调用进程没有被授权使用这个连接，将返回错误。</p><p>Closing connections is intended to be a graceful operation in the sense that outstanding SENDs will be transmitted (and retransmitted), as flow control permits, until all have been serviced.<br>关闭连接是一个优雅的操作，即在流量控制允许的情况下，未完成的 SEND 将被传输（和重传），直到所有的服务都完成。</p><p>Thus, it should be acceptable to make several SEND calls, followed by a CLOSE, and expect all the data to be sent to the destination.<br>因此，应该可以调用几次 SEND ，然后再调用 CLOSE，并期望所有的数据都被发送到目的地。</p><p>It should also be clear that users should continue to RECEIVE on CLOSING connections, since the other side may be trying to transmit the last of its data.<br>还应该明确的是，用户可以在关闭中的连接上继续接收，因为对方可能正试图传输其最后的数据。</p><p>Thus, CLOSE means &ldquo;I have no more to send&rdquo; but does not mean &ldquo;I will not receive any more.&rdquo;<br>因此，CLOSE 的意思是 &ldquo;我没有更多的东西可以发送&rdquo;，但并不意味着 &ldquo;我不会再收到任何东西&rdquo;。</p><p>It may happen (if the user level protocol is not well thought out) that the closing side is unable to get rid of all its data before timing out.<br>可能会发生这样的情况 (如果用户级协议考虑不周)，关闭端无法在超时之前发完其所有数据。</p><p>In this event, CLOSE turns into ABORT, and the closing TCP gives up.<br>在这种情况下，CLOSE 变成了 ABORT，而关闭端 TCP 则放弃了。</p><p>The user may CLOSE the connection at any time on his own initiative, or in response to various prompts from the TCP (e.g., remote close executed, transmission timeout exceeded, destination inaccessible).<br>用户可以随时主动关闭连接，或响应来自 TCP 的各种提示（例如，执行远程关闭、传输超时、目标不可访问）。</p><p>Because closing a connection requires communication with the foreign TCP, connections may remain in the closing state for a short time.<br>因为关闭连接需要与外部 TCP 通信，所以连接可能会在短时间内保持在关闭中状态。</p><p>Attempts to reopen the connection before the TCP replies to the CLOSE command will result in error responses.<br>试图在 TCP 回复 CLOSE 命令之前重新打开连接将导致错误响应。</p><p>Close also implies push function.<br>关闭也暗含推送功能。</p><p>Status
状态</p><p>Format: STATUS(local connection name) -> status data<br>格式：STATUS(本地连接名) -> 状态数据</p><p>This is an implementation dependent user command and could be excluded without adverse effect.<br>这是一个依赖于实现的用户命令，可以排除而不会产生不良影响。</p><p>Information returned would typically come from the TCB associated with the connection.<br>返回的信息通常来自与连接关联的 TCB。</p><p>This command returns a data block containing the following information:<br>该命令返回一个包含以下信息的数据块：</p><p> local socket,<br> 本地套接字,</p><p> foreign socket,<br> 外部套接字,</p><p> local connection name,<br> 本地连接名,</p><p> receive window,<br> 接收窗口,</p><p> send window,<br> 发送窗口,</p><p> connection state,<br> 连接状态,</p><p> number of buffers awaiting acknowledgment,<br> 等待确认的缓冲区数量,</p><p> number of buffers pending receipt,<br> 等待接收的缓冲区的数量,</p><p> urgent state,<br> 紧急状态,</p><p> precedence,<br> 优先级,</p><p> security/compartment,<br> 安全/区段,</p><p> and default transmission timeout.<br> 以及默认的传输超时,</p><p>Depending on the state of the connection, or on the implementation itself, some of this information may not be available or meaningful.<br>根据连接状态或实现本身，某些信息可能不可用或没有意义。</p><p>If the calling process is not authorized to use this connection, an error is returned.<br>如果调用进程没有被授权使用这个连接，将返回错误。</p><p>This prevents unauthorized processes from gaining information about a connection.<br>这可以防止未经授权的进程获得有关连接的信息。</p><p>Abort<br>中止</p><p>Format: ABORT (local connection name)<br>格式：ABORT（本地连接名）</p><p>This command causes all pending SENDs and RECEIVES to be aborted, the TCB to be removed, and a special RESET message to be sent to the TCP on the other side of the connection.<br>该命令导致所有待定的发送和接收被终止，TCB 被删除，并向连接另一端的 TCP 发送一个特殊的 RESET 消息。</p><p>Depending on the implementation, users may receive abort indications for each outstanding SEND or RECEIVE, or may simply receive an ABORT-acknowledgment.<br>根据不同的实现，用户可能会收到每个未完成的 SEND 或 RECEIVE 的中止指示，或者只是收到一个 ABORT 确认。</p><p>The following information is provided:<br>提供的信息如下：</p><pre tabindex=0><code>Local Connection Name                    Always
Response String                          Always
Buffer Address                           Send &amp; Receive
Byte count (counts bytes received)       Receive
Push flag                                Receive
Urgent flag                              Receive
</code></pre><h4 id=tcp下层-接口>TCP/下层 接口
<a class=anchor href=#tcp%e4%b8%8b%e5%b1%82-%e6%8e%a5%e5%8f%a3>#</a></h4><p><strong>TCP/Lower-Level Interface</strong></p><p>The TCP calls on a lower level protocol module to actually send and receive information over a network.<br>TCP 调用较低级别的协议模块，以通过网络实际发送和接收信息。</p><p>One case is that of the ARPA internetwork system where the lower level module is the Internet Protocol [2].<br>一种情况是 ARPA 网际网络系统，其中较低级别的模块是 IP 协议[2]。</p><p>If the lower level protocol is IP it provides arguments for a type of service and for a time to live.<br>如果下层协议是 IP 协议，它提供服务类型和生存时间参数。</p><p>TCP uses the following settings for these parameters:<br>TCP 对这些参数采用以下设置：</p><pre tabindex=0><code>Type of Service = Precedence: routine, Delay: normal, Throughput:
                  normal, Reliability: normal; or 00000000.
Time to Live    = one minute, or 00111100.
</code></pre><p>Note that the assumed maximum segment lifetime is two minutes.<br>注意，假设段的最大存活时间是两分钟。</p><p>Here we explicitly ask that a segment be destroyed if it cannot be delivered by the internet system within one minute.<br>这里我们明确要求，如果一个段不能在一分钟内被互联网系统送达，则销毁该段。</p><p>If the lower level is IP (or other protocol that provides this feature) and source routing is used, the interface must allow the route information to be communicated.<br>如果下层是 IP（或其他提供此功能的协议），并且使用了源路由，那么接口必须允许通信路由信息。</p><p>This is especially important so that the source and destination addresses used in the TCP checksum be the originating source and ultimate destination.<br>这一点特别重要，以便在 TCP 校验中使用的源地址和目的地址是来源地和最终目的地。</p><p>It is also important to preserve the return route to answer connection requests.<br>这对保留返回路由以响应连接请求也很重要。</p><p>Any lower level protocol will have to provide the source address, destination address, and protocol fields, and some way to determine the &ldquo;TCP length&rdquo;, both to provide the functional equivlent service of IP and to be used in the TCP checksum.<br>所有下层的协议都必须提供源地址、目标地址和协议字段，以及确定 &ldquo;TCP 长度&rdquo; 的方法，以提供与 IP 功能相当的服务，用于 TCP 校验。</p><h3 id=事件处理>事件处理
<a class=anchor href=#%e4%ba%8b%e4%bb%b6%e5%a4%84%e7%90%86>#</a></h3><p><strong>3.9. Event Processing</strong></p><p>The processing depicted in this section is an example of one possible implementation.<br>本节中描述的处理是一种可能实现的示例。</p><p>Other implementations may have slightly different processing sequences, but they should differ from those in this section only in detail, not in substance.<br>其他实现可能会有稍微不同的处理顺序，但它们应该只在细节上与本节中的处理顺序不同，而不是在实质上。</p><p>The activity of the TCP can be characterized as responding to events.<br>可以将 TCP 的活动描述为对事件的响应。</p><p>The events that occur can be cast into three categories: user calls, arriving segments, and timeouts.<br>发生的事件可以分为三类：用户调用、收到段和超时。</p><p>This section describes the processing the TCP does in response to each of the events.<br>本节描述了 TCP 对每个事件所做的处理。</p><p>In many cases the processing required depends on the state of the connection.<br>在很多情况下，需要根据连接状态做对应的处理。</p><p>Events that occur:<br>事件发生：</p><p>User Calls 用户调用<br> OPEN<br> SEND<br> RECEIVE<br> CLOSE<br> ABORT<br> STATUS</p><p>Arriving Segments 收到段<br> SEGMENT ARRIVES</p><p>Timeouts 超时<br> USER TIMEOUT<br> RETRANSMISSION TIMEOUT<br> TIME-WAIT TIMEOUT</p><p>The model of the TCP/user interface is that user commands receive an immediate return and possibly a delayed response via an event or pseudo interrupt.<br>TCP/用户接口的模型是用户命令通过事件或伪中断接收立即返回和可能的延迟响应。</p><p>In the following descriptions, the term &ldquo;signal&rdquo; means cause a delayed response.<br>在以下描述中，术语 &ldquo;signal&rdquo; 是指引起延迟响应。</p><p>Error responses are given as character strings.<br>错误响应是以字符串的形式给出的。</p><p>For example, user commands referencing connections that do not exist receive &ldquo;error: connection not open&rdquo;.<br>例如，引用不存在的连接的用户命令收到 &ldquo;error: connection not open&rdquo;。</p><p>Please note in the following that all arithmetic on sequence numbers, acknowledgment numbers, windows, et cetera, is modulo 2**32 the size of the sequence number space.<br>请注意，下面所有关于序列号、确认号、窗口等的算术都是以序列号空间大小的模 2**32。</p><p>Also note that &ldquo;=&lt;&rdquo; means less than or equal to (modulo 2**32).
还要注意，"=&lt;&rdquo; 表示小于或等于（模 2**32）。</p><p>A natural way to think about processing incoming segments is to imagine that they are first tested for proper sequence number (i.e., that their contents lie in the range of the expected &ldquo;receive window&rdquo; in the sequence number space) and then that they are generally queued and processed in sequence number order.<br>考虑处理接收段的一种自然方式是想象它们首先被测试是否有正确的序列号(即，它们是位于序列号空间中预期的"接收窗口"的范围内)，然后它们通常按序列号顺序排队和再依次处理。</p><p>When a segment overlaps other already received segments we reconstruct the segment to contain just the new data, and adjust the header fields to be consistent.<br>当一个 TCP 段与其他已经收到的 TCP 段重叠时，我们会重建段，使其只包含新的数据，并调整头部字段以保持一致。</p><p>Note that if no state change is mentioned the TCP stays in the same state.<br>注意，如果未提及状态更改，则 TCP 将保持相同状态。</p><p><strong>OPEN Call</strong><br><strong>OPEN 调用</strong></p><p>CLOSED STATE (i.e., TCB does not exist)</p><p>Create a new transmission control block (TCB) to hold connection state information.<br>创建一个新的传输控制块（TCB）来保存连接状态信息。</p><p>Fill in local socket identifier, foreign socket, precedence, security/compartment, and user timeout information.<br>填入本地套接字标识、外部套接字、优先级、安全/分区和用户超时信息。</p><p>Note that some parts of the foreign socket may be unspecified in a passive OPEN and are to be filled in by the parameters of the incoming SYN segment.<br>请注意，外部套接字的某些部分可能在被动 OPEN 中没有指定，并由接收 SYN 段的参数填充。</p><p>Verify the security and precedence requested are allowed for this user, if not return &ldquo;error: precedence not allowed&rdquo; or &ldquo;error: security/compartment not allowed.&rdquo;<br>验证此用户允许请求的安全性和优先权，如果不允许，则返回 &ldquo;error: precedence not allowed&rdquo; 或 &ldquo;error: security/compartment not allowed&rdquo;。</p><p>If passive enter the LISTEN state and return.
如果被动 OPEN 则进入 LISTEN 状态并返回。</p><p>If active and the foreign socket is unspecified, return &ldquo;error: foreign socket unspecified&rdquo;; if active and the foreign socket is specified, issue a SYN segment.<br>如果是主动 OPEN 且外部套接字未指定，则返回 &ldquo;error: foreign socket unspecified&rdquo;； 如果是主动 OPEN 并且指定了外部套接字，则发出 SYN 段。</p><p>An initial send sequence number (ISS) is selected.
选择初始发送序列号 (ISS) 。</p><p>A SYN segment of the form &lt;SEQ=ISS>&lt;CTL=SYN> is sent.<br>发送格式为 &lt;SEQ=ISS>&lt;CTL=SYN> 的 SYN 段。</p><p>Set SND.UNA to ISS, SND.NXT to ISS+1, enter SYN-SENT state, and return.<br>设置 SND.UNA 为 ISS，SND.NXT 为 ISS+1，进入 SYN-SENT 状态，并返回。</p><p>If the caller does not have access to the local socket specified, return &ldquo;error: connection illegal for this process&rdquo;.<br>如果调用者无权访问指定的本地套接字，返回 &ldquo;error: connection illegal for this process&rdquo;。</p><p>If there is no room to create a new connection, return &ldquo;error: insufficient resources&rdquo;.<br>如果没有空间创建新连接，则返回 &ldquo;error: insufficient resources&rdquo;。</p><p>LISTEN STATE</p><p>If active and the foreign socket is specified, then change the connection from passive to active, select an ISS.<br>如果指定了主动和外部套接字，则将连接从被动更改为主动，选择一个 ISS。</p><p>Send a SYN segment, set SND.UNA to ISS, SND.NXT to ISS+1.<br>发送一个 SYN 段，设置 SND.UNA 为 ISS，SND.NXT 为 ISS+1。</p><p>Enter SYN-SENT state.<br>进入 SYN-SENT 状态。</p><p>Data associated with SEND may be sent with SYN segment or queued for transmission after entering ESTABLISHED state.<br>在进入 ESTABLISHED 状态后，与 SEND 关联的数据可能与 SYN 段一起发送或排队等待传输。</p><p>The urgent bit if requested in the command must be sent with the data segments sent as a result of this command.<br>如果在命令中有紧急标志，则应与该命令结果发送的第一个数据段一起发送。</p><p>If there is no room to queue the request, respond with &ldquo;error: insufficient resources&rdquo;.<br>如果没有空间入队请求，请返回 &ldquo;error: insufficient resources&rdquo;。</p><p>If Foreign socket was not specified, then return &ldquo;error: foreign socket unspecified&rdquo;.<br>如果未指定外部套接字，则返回 &ldquo;error: foreign socket unspecified&rdquo;。</p><p>SYN-SENT STATE<br>SYN-RECEIVED STATE<br>ESTABLISHED STATE<br>FIN-WAIT-1 STATE
FIN-WAIT-2 STATE<br>TIME-WAIT STATE<br>CLOSE-WAIT STATE<br>CLOSING STATE</p><p>Return &ldquo;error: connection already exists&rdquo;.<br>返回 &ldquo;error: connection already exists&rdquo;.</p><p><strong>SEND Call</strong><br><strong>SEND 调用</strong></p><p>CLOSED STATE (i.e., TCB does not exist)</p><p>If the user does not have access to such a connection, then return &ldquo;error: connection illegal for this process&rdquo;.<br>如果调用者无权访问这个连接，则返回 &ldquo;error: connection illegal for this process&rdquo;。</p><p>Otherwise, return &ldquo;error: connection does not exist&rdquo;.<br>否则，返回 &ldquo;error: connection does not exist&rdquo;。</p><p>LISTEN STATE</p><p>If the foreign socket is specified, then change the connection from passive to active, select an ISS, and select the receive buffer size.<br>如果指定了外部套接字，则将连接从被动更改为主动，选择一个 ISS，然后选择接收缓冲区大小。</p><p>Send a SYN segment, set SND.UNA to ISS, SND.NXT to ISS+1 and SND.LBB to ISS+1.<br>发送一个 SYN 段，设置 SND.UNA 为 ISS，SND.NXT 为 ISS+1，SND.LBB 为 ISS+1。</p><p>Enter SYN-SENT state. Data associated with SEND may be sent with SYN segment or queued for transmission after entering ESTABLISHED state.<br>进入 SYN-SENT 状态。 在进入 ESTABLISHED 状态后，与 SEND 关联的数据可能与 SYN 段一起发送或排队等待传输。</p><p>The urgent bit if requested in the command should be sent with the first data segment sent as a result of this command.<br>如果在命令中有紧急标志，则应与该命令结果发送的第一个数据段一起发送。</p><p>If there is no room to queue the request, respond with &ldquo;error: insufficient resources&rdquo;.<br>如果没有空间入队请求，请返回 &ldquo;error: insufficient resources&rdquo;。</p><p>If Foreign socket was not specified, then return &ldquo;error: foreign socket unspecified&rdquo;.<br>如果未指定外部套接字，则返回 &ldquo;error: foreign socket unspecified&rdquo;。</p><p>SYN-SENT STATE<br>SYN-RECEIVED STATE</p><p>Queue the data for transmission after entering ESTABLISHED state.
Queue for later processing after entering ESTABLISHED state.<br>进入 ESTABLISHED 状态后排队传输数据。</p><p>If no space to queue, respond with &ldquo;error: insufficient resources&rdquo;.<br>如果没有空间入队，则返回 &ldquo;error: insufficient resources&rdquo;。</p><p>ESTABLISHED STATE<br>CLOSE-WAIT STATE</p><p>Segmentize the buffer and send it with a piggybacked acknowledgment (acknowledgment value = RCV.NXT).<br>将缓冲区进行分段，并在发送时附加一个确认（确认值=RCV.NXT）。</p><p>If there is insufficient space to remember this buffer, simply return &ldquo;error: insufficient resources&rdquo;.<br>如果没有足够的空间来保存这个缓冲区，就返回 &ldquo;error: insufficient resources&rdquo;。</p><p>If the urgent flag is set, then SND.UP &lt;- SND.NXT-1 and set the urgent pointer in the outgoing segment.<br>如果设置了紧急标志，则 SND.UP &lt;- SND.NXT-1 并在传出段中设置紧急指针。</p><p>FIN-WAIT-1 STATE<br>FIN-WAIT-2 STATE<br>CLOSING STATE<br>LAST-ACK STATE<br>TIME-WAIT STATE</p><p>Return &ldquo;error: connection closing&rdquo; and do not service request.<br>返回 &ldquo;error: connection closing&rdquo;， 并且不处理请求。</p><p><strong>RECEIVE Call</strong><br><strong>RECEIVE 调用</strong></p><p>CLOSED STATE (i.e., TCB does not exist)</p><p>If the user does not have access to such a connection, return &ldquo;error: connection illegal for this process&rdquo;.<br>如果调用者无权访问这个连接，返回 &ldquo;error: connection illegal for this process&rdquo;。</p><p>Otherwise return &ldquo;error: connection does not exist&rdquo;.<br>否则返回 &ldquo;error: connection does not exist&rdquo;。</p><p>LISTEN STATE<br>SYN-SENT STATE<br>SYN-RECEIVED STATE</p><p>Queue for processing after entering ESTABLISHED state.<br>进入 ESTABLISHED 状态后排队等待后续处理。</p><p>If there is no room to queue this request, respond with &ldquo;error: insufficient resources&rdquo;.<br>如果没有空间入队这个请求，则返回 &ldquo;error: insufficient resources&rdquo;。</p><p>ESTABLISHED STATE<br>FIN-WAIT-1 STATE<br>FIN-WAIT-2 STATE</p><p>If insufficient incoming segments are queued to satisfy the request, queue the request.<br>如果队列中没有足够的接收段，则将请求加入到队列。</p><p>If there is no queue space to remember the RECEIVE, respond with &ldquo;error: insufficient resources&rdquo;.<br>如果没有队列空间来保存 RECEIVE，则返回 &ldquo;error: insufficient resources&rdquo;。</p><p>Reassemble queued incoming segments into receive buffer and return to user.<br>将排队的接收段重新组合到接收缓冲区并返回给用户。</p><p>Mark &ldquo;push seen&rdquo; (PUSH) if this is the case.<br>如果是这种情况，标记 &ldquo;push seen&rdquo; (PUSH)。</p><p>If RCV.UP is in advance of the data currently being passed to the user notify the user of the presence of urgent data.<br>如果 RCV.UP 在当前传递给用户的数据之前，则通知用户有紧急数据存在。</p><p>When the TCP takes responsibility for delivering data to the user that fact must be communicated to the sender via an acknowledgment.<br>当 TCP 向用户传递数据时，必须通过确认将这一情况传达给发送者。</p><p>The formation of such an acknowledgment is described below in the discussion of processing an incoming segment.<br>这种确认的形成会在下面处理接收段的讨论中描述。</p><p>CLOSE-WAIT STATE</p><p>Since the remote side has already sent FIN, RECEIVEs must be satisfied by text already on hand, but not yet delivered to the user.
由于远程端已经发送了 FIN，RECEIVE 必须返回已经收到但尚未交付给用户的内容。</p><p>If no text is awaiting delivery, the RECEIVE will get a &ldquo;error: connection closing&rdquo; response.<br>如果没有内容等待传递，RECEIVE 将收到 &ldquo;error: connection closing&rdquo; 响应。</p><p>Otherwise, any remaining text can be used to satisfy the RECEIVE.<br>否则，可以使用任何剩余的内容来返回 RECEIVE 。</p><p>CLOSING STATE<br>LAST-ACK STATE<br>TIME-WAIT STATE</p><p>Return &ldquo;error: connection closing&rdquo;<br>返回 &ldquo;error: connection closing&rdquo;。</p><p><strong>CLOSE Call</strong><br><strong>CLOSE 调用</strong></p><p>CLOSED STATE (i.e., TCB does not exist)</p><p>If the user does not have access to such a connection, return &ldquo;error: connection illegal for this process&rdquo;.<br>如果调用者无权访问这个连接，返回 &ldquo;error: connection illegal for this process&rdquo;。</p><p>Otherwise, return &ldquo;error: connection does not exist&rdquo;.<br>否则返回 &ldquo;error: connection does not exist&rdquo;。</p><p>LISTEN STATE</p><p>Any outstanding RECEIVEs should be returned with &ldquo;error: closing&rdquo; responses. Delete TCB, enter CLOSED state, and return.
任何未完成的 RECEIVE 都应返回 &ldquo;error: closing&rdquo;，删除 TCB，进入 CLOSED 状态，然后返回。</p><p>SYN-SENT STATE</p><p>Delete the TCB and return &ldquo;error: closing&rdquo; responses to any queued SENDs, or RECEIVEs.<br>删除 TCB 并向所有队列中的 SEND 或 RECEIVE 返回 &ldquo;error: closing&rdquo; 响应。</p><p>SYN-RECEIVED STATE</p><p>If no SENDs have been issued and there is no pending data to send, then form a FIN segment and send it, and enter FIN-WAIT-1 state; otherwise queue for processing after entering ESTABLISHED state.<br>如果没有发出 SEND，也没有待发送的数据，则生成一个 FIN 段发送，进入 FIN-WAIT-1 状态； 否则进入 ESTABLISHED 状态后排队等待处理。</p><p>ESTABLISHED STATE</p><p>Queue this until all preceding SENDs have been segmentized, then form a FIN segment and send it.<br>排队直到所有前面的 SEND 都被分段，然后形成一个 FIN 段并发送它。</p><p>In any case, enter FIN-WAIT-1 state.<br>无论什么情况下，进入 FIN-WAIT-1 状态。</p><p>FIN-WAIT-1 STATE
FIN-WAIT-2 STATE</p><p>Strictly speaking, this is an error and should receive a &ldquo;error: connection closing&rdquo; response.<br>严格来说，这是一个错误，应该收到 &ldquo;error: connection closing&rdquo; 响应。</p><p>An &ldquo;ok&rdquo; response would be acceptable, too, as long as a second FIN is not emitted (the first FIN may be retransmitted though).
只要不发出第二个 FIN（尽管可以重传第一个 FIN），返回 &ldquo;ok&rdquo; 也是可以接受的。</p><p>CLOSE-WAIT STATE</p><p>Queue this request until all preceding SENDs have been segmentized; then send a FIN segment, enter CLOSING state.<br>排队直到所有前面的 SEND 都被分段，然后形成一个 FIN 段并发送它，进入 CLOSING 状态。</p><p>CLOSING STATE<br>LAST-ACK STATE<br>TIME-WAIT STATE</p><p>Respond with &ldquo;error: connection closing&rdquo;<br>返回 &ldquo;error: connection closing&rdquo;</p><p><strong>ABORT Call</strong><br><strong>ABORT 调用</strong></p><p>CLOSED STATE (i.e., TCB does not exist)</p><p>If the user should no have access to such a connection, return &ldquo;error: connection illegal for this process&rdquo;.<br>如果调用者无权访问这个连接，返回 &ldquo;error: connection illegal for this process&rdquo;。</p><p>Otherwise return &ldquo;error: connection does not exist&rdquo;.<br>否则返回 &ldquo;error: connection does not exist&rdquo;。</p><p>LISTEN STATE</p><p>Any outstanding RECEIVEs should be returned with &ldquo;error: connection reset&rdquo; responses.<br>任何未完成的 RECEIVE 都应返回 &ldquo;error: connection reset&rdquo; 响应。</p><p>Delete TCB, enter CLOSED state, and return.<br>删除 TCB，进入 CLOSED 状态，然后返回。</p><p>SYN-SENT STATE</p><p>All queued SENDs and RECEIVEs should be given &ldquo;connection reset&rdquo; notification, delete the TCB, enter CLOSED state, and return.<br>所有队列中的 SEND 和 RECEIVE 都应收到 &ldquo;connection reset&rdquo; 通知，删除 TCB，进入 CLOSED 状态，然后返回。</p><p>SYN-RECEIVED STATE<br>ESTABLISHED STATE<br>FIN-WAIT-1 STATE<br>FIN-WAIT-2 STATE<br>CLOSE-WAIT STATE</p><p>Send a reset segment:</p><p>&lt;SEQ=SND.NXT>&lt;CTL=RST></p><p>All queued SENDs and RECEIVEs should be given &ldquo;connection reset&rdquo; notification;<br>所有队列中的 SEND 和 RECEIVE 都应收到 &ldquo;connection reset&rdquo; 通知；</p><p>all segments queued for transmission (except for the RST formed above) or retransmission should be flushed, delete the TCB, enter CLOSED state, and return.<br>所有队列中等待传输（除了上面生成的 RST）或重传的段都应该被清除，删除 TCB，进入 CLOSED 状态，然后返回。</p><p>CLOSING STATE<br>LAST-ACK STATE<br>TIME-WAIT STATE</p><p>Respond with &ldquo;ok&rdquo; and delete the TCB, enter CLOSED state, and return.<br>响应 &ldquo;ok&rdquo; 并删除 TCB，进入 CLOSED 状态，然后返回。</p><p><strong>STATUS Call</strong><br><strong>STATUS 调用</strong></p><p>CLOSED STATE (i.e., TCB does not exist)</p><p>If the user should no have access to such a connection, return &ldquo;error: connection illegal for this process&rdquo;.<br>如果调用者无权访问这个连接，返回 &ldquo;error: connection illegal for this process&rdquo;。</p><p>Otherwise return &ldquo;error: connection does not exist&rdquo;.<br>否则返回 &ldquo;error: connection does not exist&rdquo;。</p><p>LISTEN STATE</p><p>Return &ldquo;state = LISTEN&rdquo;, and the TCB pointer.<br>返回 &ldquo;state = LISTEN&rdquo;，以及 TCB 指针。</p><p>SYN-SENT STATE</p><p>Return &ldquo;state = SYN-SENT&rdquo;, and the TCB pointer.<br>返回 &ldquo;state = SYN-SENT&rdquo;，以及 TCB 指针。</p><p>SYN-RECEIVED STATE</p><p>Return &ldquo;state = SYN-RECEIVED&rdquo;, and the TCB pointer.<br>返回 &ldquo;state = SYN-RECEIVED&rdquo;，以及 TCB 指针。</p><p>ESTABLISHED STATE</p><p>Return &ldquo;state = ESTABLISHED&rdquo;, and the TCB pointer.<br>返回 &ldquo;state = ESTABLISHED&rdquo;，以及 TCB 指针。</p><p>FIN-WAIT-1 STATE</p><p>Return &ldquo;state = FIN-WAIT-1&rdquo;, and the TCB pointer.<br>返回 &ldquo;state = FIN-WAIT-1&rdquo;，以及 TCB 指针。</p><p>FIN-WAIT-2 STATE</p><p>Return &ldquo;state = FIN-WAIT-2&rdquo;, and the TCB pointer.<br>返回 &ldquo;state = FIN-WAIT-2&rdquo;，以及 TCB 指针。</p><p>CLOSE-WAIT STATE</p><p>Return &ldquo;state = CLOSE-WAIT&rdquo;, and the TCB pointer.<br>返回 &ldquo;state = CLOSE-WAIT&rdquo;，以及 TCB 指针。</p><p>CLOSING STATE</p><p>Return &ldquo;state = CLOSING&rdquo;, and the TCB pointer.<br>返回 &ldquo;state = CLOSING&rdquo;，以及 TCB 指针。</p><p>LAST-ACK STATE</p><p>Return &ldquo;state = LAST-ACK STATE&rdquo;, and the TCB pointer.<br>返回 &ldquo;state = LAST-ACK STATE&rdquo;，以及 TCB 指针。</p><p>TIME-WAIT STATE</p><p>Return &ldquo;state = TIME-WAIT&rdquo; and the TCB pointer.<br>返回 &ldquo;state = TIME-WAIT&rdquo;，以及 TCB 指针。</p><p><strong>SEGMENT ARRIVES</strong><br><strong>段到达</strong></p><p>If the state is CLOSED (i.e., TCB does not exist) then<br>如果状态为 CLOSED（即 TCB 不存在），则</p><div style=padding-left:1em><p>all data in the incoming segment is discarded.<br>接收段中的所有数据都被丢弃。</p><p>An incoming segment containing a RST is discarded.<br>丢弃包含 RST 的接收段。</p><p>An incoming segment not containing a RST causes a RST to be sent in response.<br>如果接收段不包含 RST，则回复一个 RST。</p><p>The acknowledgment and sequence field values are selected to make the reset sequence acceptable to the TCP that sent the offending segment.<br>选择确认和序列字段值是为了使发送无效段的 TCP 可以有效的接收重置序列。</p><p>If the ACK bit is off, sequence number zero is used,<br>如果没有 ACK 标志位，则使用序列号零，</p><p>&lt;SEQ=0>&lt;ACK=SEG.SEQ+SEG.LEN>&lt;CTL=RST,ACK></p><p>If the ACK bit is on,<br>如果有 ACK 标志位，</p><p>&lt;SEQ=SEG.ACK>&lt;CTL=RST></p><p>Return.<br>返回。</p></div><p>If the state is LISTEN then<br>如果状态是 LISTEN，则</p><div style=padding-left:1em><p>first check for an RST<br>第一步，检查是否是 RST</p><p>An incoming RST should be ignored. Return.<br>接收到 RST 则忽略，然后返回。</p><p>second check for an ACK<br>第二步，检查是否是 ACK</p><p>Any acknowledgment is bad if it arrives on a connection still in the LISTEN state.<br>如果连接仍处于 LISTEN 状态的连接，则任何 ACK（确认）都是无效的。</p><p>An acceptable reset segment should be formed for any arriving ACK-bearing segment, except another RST.<br>除了另一个 RST 之外，任何到达的带有 ACK 段都应该生成一个有效的重置段。</p><p>The RST should be formatted as follows:<br>RST 的格式应如下所示：</p><p>&lt;SEQ=SEG.ACK>&lt;CTL=RST></p><p>Return.<br>返回。</p><p>third check for a SYN<br>第三步，检查是否是 SYN</p><p>If the SYN bit is set, check the security.<br>如果设置了 SYN 标志位，则检查安全性。</p><p>If the security/compartment on the incoming segment does not exactly match the security/compartment in the TCB then send a reset and return.<br>如果接收段上的安全/区段与 TCB 中的安全/区段不完全匹配，则发送重置段并返回。</p><p>&lt;SEQ=SEG.ACK>&lt;CTL=RST></p><p>If the SEG.PRC is greater than the TCB.PRC then if allowed by the user and the system set TCB.PRC&lt;-SEG.PRC, if not allowed send a reset and return.<br>如果 SEG.PRC 大于 TCB.PRC，则如果用户和系统允许，则设置 TCB.PRC&lt;-SEG.PRC，如果不允许，则发送重置并返回。</p><p>&lt;SEQ=SEG.ACK>&lt;CTL=RST></p><p>If the SEG.PRC is less than the TCB.PRC then continue.<br>如果 SEG.PRC 小于 TCB.PRC，则继续。</p><p>Set RCV.NXT to SEG.SEQ+1, IRS is set to SEG.SEQ and any other control or text should be queued for processing later.<br>将 RCV.NXT 设置为 SEG.SEQ+1，IRS 设置为 SEG.SEQ，任何其他控制或内容都需要排队等待稍后处理。</p><p>ISS should be selected and a SYN segment sent of the form:<br>应选择 ISS 并发送以下形式的 SYN 段：</p><p>&lt;SEQ=ISS>&lt;ACK=RCV.NXT>&lt;CTL=SYN,ACK></p><p>SND.NXT is set to ISS+1 and SND.UNA to ISS.<br>SND.NXT 设置为 ISS+1，SND.UNA 设置为 ISS。</p><p>The connection state should be changed to SYN-RECEIVED.<br>连接状态应更改为 SYN-RECEIVED。</p><p>Note that any other incoming control or data (combined with SYN) will be processed in the SYN-RECEIVED state, but processing of SYN and ACK should not be repeated.<br>注意，任何其它收到的控制或数据（与 SYN 关联）将在 SYN-RECEIVED 状态下处理，但 SYN 和 ACK 的处理不能重复。</p><p>If the listen was not fully specified (i.e., the foreign socket was not fully specified), then the unspecified fields should be filled in now.<br>如果没有完全指定监听（即没有完全指定外部套接字），那么现在应该填写未指定的字段。</p><p>fourth other text or control<br>第四步，处理其它内容和控制</p><p>Any other control or text-bearing segment (not containing SYN) must have an ACK and thus would be discarded by the ACK processing.<br>任何其他操作或带内容的段（不包含 SYN）都会回复一个 ACK，但是数据会在处理 ACK 时丢弃。</p><p>An incoming RST segment could not be valid, since it could not have been sent in response to anything sent by this incarnation of the connection.<br>接收的 RST 段不可能是有效的，因为它不可能是为了响应这个连接所发送的任何东西而发送的。</p><p>So you are unlikely to get here, but if you do, drop the segment, and return.<br>所以你不太可能会遇到这种情况，但如果你遇到了，就丢弃这个段，然后返回。</p></div><p>If the state is SYN-SENT then<br>如果状态是 SYN-SENT，则</p><div style=padding-left:1em><p>first check the ACK bit<br>第一步，检查 ACK 标识位</p><p>If the ACK bit is set<br>如果设置了 ACK 标识</p><p>If SEG.ACK =&lt; ISS, or SEG.ACK > SND.NXT, send a reset (unless the RST bit is set, if so drop the segment and return)<br>如果 SEG.ACK =&lt; ISS，或 SEG.ACK > SND.NXT，发送一个重置（除非设置了 RST 位，如果设置了则丢弃该段并返回）</p><p>&lt;SEQ=SEG.ACK>&lt;CTL=RST></p><p>and discard the segment. Return.<br>然后丢弃该段并返回。</p><p>If SND.UNA =&lt; SEG.ACK =&lt; SND.NXT then the ACK is acceptable.<br>如果 SND.UNA =&lt; SEG.ACK =&lt; SND.NXT 那么 ACK 是有效的。</p><p>second check the RST bit<br>第二步，检查 RST 标识位</p><p>If the RST bit is set<br>如果设置了 RST 标识</p><p>If the ACK was acceptable then signal the user &ldquo;error: connection reset&rdquo;, drop the segment, enter CLOSED state, delete TCB, and return.<br>如果 ACK 是有效的，则向用户发出 &ldquo;error: connection reset&rdquo; 信号，丢弃该段，进入 CLOSED 状态，删除 TCB，然后返回。</p><p>Otherwise (no ACK) drop the segment and return.<br>否则（无 ACK）丢弃该段并返回。</p><p>third check the security and precedence<br>第三步，检查安全和优先级</p><p>If the security/compartment in the segment does not exactly match the security/compartment in the TCB, send a reset<br>如果段中的安全/区段与 TCB 中的安全/区段不完全匹配，则发送一个重置信号</p><p> If there is an ACK<br> 如果有 ACK</p><p> &lt;SEQ=SEG.ACK>&lt;CTL=RST></p><p> Otherwise<br> 否则</p><p> &lt;SEQ=0>&lt;ACK=SEG.SEQ+SEG.LEN>&lt;CTL=RST,ACK></p><p>If there is an ACK<br>如果有 ACK</p><p>The precedence in the segment must match the precedence in the TCB, if not, send a reset<br>段中的优先级必须与 TCB 中的优先级匹配，如果不匹配，则发送重置</p><p>&lt;SEQ=SEG.ACK>&lt;CTL=RST></p><p>If there is no ACK<br>如果没有 ACK</p><p>If the precedence in the segment is higher than the precedence in the TCB then if allowed by the user and the system raise the precedence in the TCB to that in the segment, if not allowed to raise the prec then send a reset.<br>如果段中的优先级高于 TCB 中的优先级，则如果用户允许并且系统将 TCB 中的优先级提高到段中的优先级，如果不允许提高优先级，则发送重置。</p><p>&lt;SEQ=0>&lt;ACK=SEG.SEQ+SEG.LEN>&lt;CTL=RST,ACK></p><p>If the precedence in the segment is lower than the precedence in the TCB continue.<br>如果段中的优先级低于 TCB 中的优先级，则继续。</p><p>If a reset was sent, discard the segment and return.<br>如果发送了重置，则丢弃该段并返回。</p><p>fourth check the SYN bit<br>第四步，检查 SYN 标识位</p><p>This step should be reached only if the ACK is ok, or there is no ACK, and it the segment did not contain a RST.<br>仅当 ACK 正常或没有 ACK 且该段不包含 RST 时才应执行此步骤。</p><p>If the SYN bit is on and the security/compartment and precedence are acceptable then, RCV.NXT is set to SEG.SEQ+1, IRS is set to SEG.SEQ.<br>如果 SYN 位打开并且安全/隔间和优先级是有效的，则 RCV.NXT 设置为 SEG.SEQ+1，IRS 设置为 SEG.SEQ。</p><p>SND.UNA should be advanced to equal SEG.ACK (if there is an ACK), and any segments on the retransmission queue which are thereby acknowledged should be removed.<br>SND.UNA 应增加到等于 SEG.ACK，重传队列中任何因此被确认的片段应被删除。</p><p>If SND.UNA > ISS (our SYN has been ACKed), change the connection state to ESTABLISHED, form an ACK segment<br>如果 SND.UNA>ISS（我们的 SYN 已经被 ACK 了），将连接状态改为 ESTABLISHED，形成一个 ACK 段</p><p>&lt;SEQ=SND.NXT>&lt;ACK=RCV.NXT>&lt;CTL=ACK></p><p>and send it.<br>然后发送它。</p><p>Data or controls which were queued for transmission may be included.<br>数据中可能包括队列中等待发送的数据或控制。</p><p>If there are other controls or text in the segment then continue processing at the sixth step below where the URG bit is checked, otherwise return.<br>如果段中还有其他操作或内容，则继续下面第六步检查 URG 位的处理，否则返回。</p><p>Otherwise enter SYN-RECEIVED, form a SYN, ACK segment<br>否则进入 SYN-RECEIVED 状态，生成一个 SYN，ACK 段</p><p>&lt;SEQ=ISS>&lt;ACK=RCV.NXT>&lt;CTL=SYN,ACK></p><p>and send it.<br>然后发送它。</p><p>If there are other controls or text in the segment, queue them for processing after the ESTABLISHED state has been reached, return.<br>如果段中有其他控制或内容，在达到 ESTABLISHED 状态后排队处理，返回。</p><p>fifth, if neither of the SYN or RST bits is set then drop the segment and return.<br>第五步，如果 SYN 或 RST 标识位均未设置，则丢弃该段并返回。</p></div><p>Otherwise,<br>否则，</p><div style=padding-left:1em><p>first check sequence number<br>第一步，检查序列号</p><p>SYN-RECEIVED STATE<br>ESTABLISHED STATE<br>FIN-WAIT-1 STATE<br>FIN-WAIT-2 STATE<br>CLOSE-WAIT STATE<br>CLOSING STATE<br>LAST-ACK STATE<br>TIME-WAIT STATE</p><p>Segments are processed in sequence.<br>按顺序处理段。</p><p>Initial tests on arrival are used to discard old duplicates, but further processing is done in SEG.SEQ order.<br>到达时的初始检测用于丢弃旧的重复项，但进一步处理按 SEG.SEQ 顺序完成。</p><p>If a segment&rsquo;s contents straddle the boundary between old and new, only the new parts should be processed.<br>如果一个段的内容即包括了新内容也包括了旧内容，那么应该只处理新的部分。</p><p>There are four cases for the acceptability test for an incoming segment:<br>检查接收段是否有效的情况有四种：</p><pre tabindex=0><code>  Segment Receive  Test
  Length  Window
  ------- -------  -------------------------------------------
      0       0     SEG.SEQ = RCV.NXT
      0      &gt;0     RCV.NXT =&lt; SEG.SEQ &lt; RCV.NXT+RCV.WND
     &gt;0       0     not acceptable
     &gt;0      &gt;0     RCV.NXT &lt;= SEG.SEQ+SEG.LEN &lt; RCV.NXT+RCV.WND
                 or RCV.NXT =&lt; SEG.SEQ+SEG.LEN-1 &lt; RCV.NXT+RCV.WND
</code></pre><p>If the RCV.WND is zero, no segments will be acceptable, but special allowance should be made to accept valid ACKs, URGs and RSTs.<br>如果 RCV.WND 为 0，则不接收任何段，但有效的 ACK、URG 和 RST 还是需要处理。</p><p>If an incoming segment is not acceptable, an acknowledgment should be sent in reply (unless the RST bit is set, if so drop the segment and return):<br>如果收到的段无效，则应发送确认段作为回复（除非 RST 位被设置，如果是那样，则放弃该段并返回）：</p><p>&lt;SEQ=SND.NXT>&lt;ACK=RCV.NXT>&lt;CTL=ACK></p><p>After sending the acknowledgment, drop the unacceptable segment and return.<br>在发送确认后，丢弃无效的段，然后返回。</p><p>In the following it is assumed that the segment is the idealized segment that begins at RCV.NXT and does not exceed the window.<br>在下文中，假定该段是从 RCV.NXT 开始并且不超过窗口的理想化段。</p><p>One could tailor actual segments to fit this assumption by trimming off any portions that lie outside the window (including SYN and FIN), and only processing further if the segment then begins at RCV.NXT.<br>我们可以通过修剪位于窗口之外的任何部分（包括 SYN 和 FIN），并只在该段从 RCV.NXT 开始时才进一步处理，从而使实际段符合这一假设。</p><p>Segments with higher begining sequence numbers may be held for later processing.<br>可以保留具有较高开始序列号的段以供后续处理。</p><p>second check the RST bit,<br>第二步，检查 RST 标识位，</p><p>SYN-RECEIVED STATE</p><p>If the RST bit is set<br>如果设置了 RST 标识位</p><p>If this connection was initiated with a passive OPEN (i.e., came from the LISTEN state), then return this connection to LISTEN state and return.<br>如果这个连接是以被动的 OPEN 启动的（即来自于 LISTEN 状态），那么就把这个连接返回到 LISTEN 状态。</p><p>The user need not be informed.<br>不需要通知用户。</p><p>If this connection was initiated with an active OPEN (i.e., came from SYN-SENT state) then the connection was refused, signal the user &ldquo;connection refused&rdquo;.<br>如果这个连接是以主动 OPEN 启动的（即来自 SYN-SENT 状态），然后这个连接被拒绝了，则向用户发出 &ldquo;connection refused&rdquo; 的信号。</p><p>In either case, all segments on the retransmission queue should be removed.<br>在这两种情况下，重传队列中的所有段都应被删除。</p><p>And in the active OPEN case, enter the CLOSED state and delete the TCB, and return.<br>如果是在主动 OPEN 情况下，进入 CLOSED 状态并删除 TCB，然后返回。</p><p>ESTABLISHED<br>FIN-WAIT-1<br>FIN-WAIT-2<br>CLOSE-WAIT</p><p>If the RST bit is set then, any outstanding RECEIVEs and SEND should receive &ldquo;reset&rdquo; responses.<br>如果设置了 RST 标识位，那么所有未完成的 RECEIVE 和 SEND 都应该收到 &ldquo;reset&rdquo; 响应。</p><p>All segment queues should be flushed.<br>所有的段队列都应该被清除。</p><p>Users should also receive an unsolicited general &ldquo;connection reset&rdquo; signal.<br>用户还应收到未经请求通用的 &ldquo;connection reset&rdquo; 信号。</p><p>Enter the CLOSED state, delete the TCB, and return.<br>进入 CLOSED 状态，删除 TCB，并返回。</p><p>CLOSING STATE
LAST-ACK STATE
TIME-WAIT</p><p>If the RST bit is set then, enter the CLOSED state, delete the TCB, and return.<br>如果设置了 RST 标识位，进入 CLOSED 状态，删除 TCB，并返回。</p><p>third check security and precedence<br>第三步，检查安全和优先级</p><p>SYN-RECEIVED</p><p>If the security/compartment and precedence in the segment do not exactly match the security/compartment and precedence in the TCB then send a reset, and return.<br>如果段上的安全/区段与 TCB 中的安全/区段不完全匹配，则发送重置段并返回。</p><p>ESTABLISHED STATE</p><p>If the security/compartment and precedence in the segment do not exactly match the security/compartment and precedence in the TCB then send a reset, any outstanding RECEIVEs and SEND should receive &ldquo;reset&rdquo; responses.<br>如果段上的安全/区段与 TCB 中的安全/区段不完全匹配，则发送重置段，所有未完成的 RECEIVE 和 SEND 都应该收到 &ldquo;reset&rdquo; 响应。</p><p>All segment queues should be flushed.<br>所有的段队列都应该被清除。</p><p>Users should also receive an unsolicited general &ldquo;connection reset&rdquo; signal.<br>用户还应收到未经请求通用的 &ldquo;connection reset&rdquo; 信号。</p><p>Enter the CLOSED state, delete the TCB, and return.<br>进入 CLOSED 状态，删除 TCB，并返回。</p><p>Note this check is placed following the sequence check to prevent a segment from an old connection between these ports with a different security or precedence from causing an abort of the current connection.<br>注意，这个检查是放在序列号之后的，以防止在这些段之间存在一个来自旧连接具有不同安全性或优先级的段引起当前连接的中止。</p><p>fourth, check the SYN bit,<br>第四步，检查 SYN 标识位，</p><p>SYN-RECEIVED<br>ESTABLISHED STATE<br>FIN-WAIT STATE-1<br>FIN-WAIT STATE-2<br>CLOSE-WAIT STATE<br>CLOSING STATE<br>LAST-ACK STATE<br>TIME-WAIT STATE</p><p>If the SYN is in the window it is an error, send a reset, any outstanding RECEIVEs and SEND should receive &ldquo;reset&rdquo; responses, all segment queues should be flushed, the user should also receive an unsolicited general &ldquo;connection reset&rdquo; signal, enter the CLOSED state, delete the TCB, and return.<br>如果 SYN 在窗口中，则出现错误了，发送重置段，所有未完成的 RECEIVE 和 SEND 都应该收到 &ldquo;reset&rdquo; 响应，所有的段队列都应该被清除，用户还应收到未经请求通用的 &ldquo;connection reset&rdquo; 信号，进入 CLOSED 状态，删除 TCB，并返回。</p><p>If the SYN is not in the window this step would not be reached and an ack would have been sent in the first step (sequence number check).<br>如果 SYN 不在窗口中，则不会到这里，并且会在第一步（序列号检查）中发送确认。</p><p>fifth check the ACK field,<br>第五步，检查 ACK 标识位，</p><p>if the ACK bit is off drop the segment and return<br>如果 ACK 标识位没有开启，则丢弃该段并返回。</p><p>if the ACK bit is on<br>如果 ACK 标识位开启</p><p>SYN-RECEIVED STATE</p><p>If SND.UNA =&lt; SEG.ACK =&lt; SND.NXT then enter ESTABLISHED state and continue processing.<br>如果 SND.UNA =&lt; SEG.ACK =&lt; SND.NXT 则进入 ESTABLISHED 状态，并且继续处理。</p><p>If the segment acknowledgment is not acceptable, form a reset segment,<br>如果段确认无效，生成一个重置段，</p><p>&lt;SEQ=SEG.ACK>&lt;CTL=RST></p><p>and send it.<br>然后发送。</p><p>ESTABLISHED STATE</p><p>If SND.UNA &lt; SEG.ACK =&lt; SND.NXT then, set SND.UNA &lt;- SEG.ACK.<br>如果 SND.UNA &lt; SEG.ACK =&lt; SND.NXT，那么，设置 SND.UNA &lt;- SEG.ACK。</p><p>Any segments on the retransmission queue which are thereby entirely acknowledged are removed.<br>移除重传队列上所有因此完全确认的段。</p><p>Users should receive positive acknowledgments for buffers which have been SENT and fully acknowledged (i.e., SEND buffer should be returned with &ldquo;ok&rdquo; response).<br>对于已经发送并完全确认的缓冲区，用户应该收到肯定的确认（即，SEND 缓冲区应该返回 &ldquo;ok &ldquo;响应）。</p><p>If the ACK is a duplicate (SEG.ACK &lt; SND.UNA), it can be ignored.<br>如果 ACK 是重复的，就可以忽略。</p><p>If the ACK acks something not yet sent (SEG.ACK > SND.NXT) then send an ACK, drop the segment, and return.<br>如果 ACK 确认没有发送过的内容（SEG.ACK > SND.NXT），则发送 ACK，丢弃该段，然后返回。</p><p>If SND.UNA &lt; SEG.ACK =&lt; SND.NXT, the send window should be updated.<br>如果 SND.UNA &lt; SEG.ACK =&lt; SND.NXT，则应该更新发送窗口。</p><p>If (SND.WL1 &lt; SEG.SEQ or (SND.WL1 = SEG.SEQ and SND.WL2 =&lt; SEG.ACK)), set SND.WND &lt;- SEG.WND, set SND.WL1 &lt;- SEG.SEQ, and set SND.WL2 &lt;- SEG.ACK.<br>如果(SND.WL1 &lt; SEG.SEQ 或 (SND.WL1 = SEG.SEQ 和 SND.WL2 =&lt; SEG.ACK))，设置 SND.WND &lt;- SEG.WND，设置 SND.WL1 &lt;- SEG.SEQ，并设置 SND.WL2 &lt;- SEG.ACK。</p><p>Note that SND.WND is an offset from SND.UNA, that SND.WL1 records the sequence number of the last segment used to update SND.WND, and that SND.WL2 records the acknowledgment number of the last segment used to update SND.WND.<br>注意，SND.WND 是 SND.UNA 的偏移量，SND.WL1 记录用于更新 SND.WND 的最后一个段的序列号，SND.WL2 记录用于更新 SND.WND 的最后一个段的确认号。</p><p>The check here prevents using old segments to update the window.<br>此处的检查可防止使用旧段更新窗口。</p><p>FIN-WAIT-1 STATE</p><p>In addition to the processing for the ESTABLISHED state, if our FIN is now acknowledged then enter FIN-WAIT-2 and continue processing in that state.<br>除了 ESTABLISHED 状态的处理之外，如果我们的 FIN 现在被确认，则进入 FIN-WAIT-2 并继续在该状态下处理。</p><p>FIN-WAIT-2 STATE</p><p>In addition to the processing for the ESTABLISHED state, if the retransmission queue is empty, the user&rsquo;s CLOSE can be acknowledged (&ldquo;ok&rdquo;) but do not delete the TCB.<br>除了对 ESTABLISHED 状态的处理，如果重传队列为空，可以用 &ldquo;ok&rdquo; 确认用户的 CLOSE， 但不删除 TCB。</p><p>CLOSE-WAIT STATE</p><p>Do the same processing as for the ESTABLISHED state.<br>做与 ESTABLISHED 状态相同的处理。</p><p>CLOSING STATE</p><p>In addition to the processing for the ESTABLISHED state, if the ACK acknowledges our FIN then enter the TIME-WAIT state, otherwise ignore the segment.<br>除了 ESTABLISHED 状态的处理外，如果 ACK 确认了我们的 FIN，则进入 TIME-WAIT 状态，否则忽略该段。</p><p>LAST-ACK STATE</p><p>The only thing that can arrive in this state is an acknowledgment of our FIN.<br>唯一能到达这种状态的是对我们的 FIN 的确认。</p><p>If our FIN is now acknowledged, delete the TCB, enter the CLOSED state, and return.<br>如果现在确认了我们的 FIN，删除 TCB，进入 CLOSED 状态，然后返回。</p><p>TIME-WAIT STATE</p><p>The only thing that can arrive in this state is a retransmission of the remote FIN.<br>唯一可以到达此状态的是远程 FIN 的重传。</p><p>Acknowledge it, and restart the 2 MSL timeout.<br>确认它，并重新启动 2 MSL 超时。</p><p>sixth, check the URG bit,<br>第六步，检查 URG 标识位，</p><p>ESTABLISHED STATE<br>FIN-WAIT-1 STATE<br>FIN-WAIT-2 STATE</p><p>If the URG bit is set, RCV.UP &lt;- max(RCV.UP,SEG.UP), and signal the user that the remote side has urgent data if the urgent pointer (RCV.UP) is in advance of the data consumed.<br>如果设置了 URG 标识位，RCV.UP &lt;- max(RCV.UP,SEG.UP)，如果紧急指针(RCV.UP)在所接收的数据之前，则向用户发出信号，表明远程端有紧急数据。</p><p>If the user has already been signaled (or is still in the &ldquo;urgent mode&rdquo;) for this continuous sequence of urgent data, do not signal the user again.<br>如果已经因为这个连续的紧急数据序列向用户发出了信号（或仍处于"紧急模式&rdquo;），就不要再次向用户发出信号。</p><p>CLOSE-WAIT STATE<br>CLOSING STATE<br>LAST-ACK STATE<br>TIME-WAIT</p><p>This should not occur, since a FIN has been received from the remote side. Ignore the URG.<br>这不应该发生，因为已经收到了来自远程端的 FIN，忽略 URG。</p><p>seventh, process the segment text,<br>第七步，处理段内容，</p><p>ESTABLISHED STATE
FIN-WAIT-1 STATE
FIN-WAIT-2 STATE</p><p>Once in the ESTABLISHED state, it is possible to deliver segment text to user RECEIVE buffers.<br>一旦进入 ESTABLISHED 状态，就有可能向用户的 RECEIVE 缓冲区传送段内容。</p><p>Text from segments can be moved into buffers until either the buffer is full or the segment is empty.<br>将段中的内容移入缓冲区，直到缓冲区已满或段为空。</p><p>If the segment empties and carries an PUSH flag, then the user is informed, when the buffer is returned, that a PUSH has been received.<br>如果该段为空并带有 PUSH 标志，则在返回缓冲区时通知用户已收到 PUSH。</p><p>When the TCP takes responsibility for delivering the data to the user it must also acknowledge the receipt of the data.<br>当 TCP 负责将数据传送给用户时，它也必须确认数据的接收。</p><p>Once the TCP takes responsibility for the data it advances RCV.NXT over the data accepted, and adjusts RCV.WND as apporopriate to the current buffer availability.<br>一旦 TCP 对数据处理，它将 RCV.NXT 推进到所接受的数据上，并根据当前缓冲区的可用性调整 RCV.WND。</p><p>The total of RCV.NXT and RCV.WND should not be reduced.<br>RCV.NXT 和 RCV.WND 的总和不应减少。</p><p>Please note the window management suggestions in section 3.7.<br>请注意 3.7 节中的窗口管理建议。</p><p>Send an acknowledgment of the form:<br>发送以下格式的确认段：</p><p>&lt;SEQ=SND.NXT>&lt;ACK=RCV.NXT>&lt;CTL=ACK></p><p>This acknowledgment should be piggybacked on a segment being transmitted if possible without incurring undue delay.<br>如果可能的话，该确认应加在正准备传输的段上，这样就不会导致不必要的延迟。</p><p>CLOSE-WAIT STATE<br>CLOSING STATE<br>LAST-ACK STATE<br>TIME-WAIT STATE</p><p>This should not occur, since a FIN has been received from the remote side. Ignore the segment text.<br>这不应该发生，因为已经收到了来自远程端的 FIN。忽略该段内容。</p><p>eighth, check the FIN bit,<br>第八步，检查 FIN 标识位，</p><p>Do not process the FIN if the state is CLOSED, LISTEN or SYN-SENT since the SEG.SEQ cannot be validated; drop the segment and return.<br>如果状态为 CLOSED、LISTEN 或 SYN-SENT，则不要处理 FIN，因为无法验证 SEG.SEQ；丢弃段并返回。</p><p>If the FIN bit is set, signal the user &ldquo;connection closing&rdquo; and return any pending RECEIVEs with same message, advance RCV.NXT over the FIN, and send an acknowledgment for the FIN.<br>如果设置了 FIN 标识位，向用户发出 &ldquo;connection closing&rdquo; 信号，并使用相同的消息返回任何待处理的 RECEIVE，推进 RCV.NXT 到 FIN，并发送 FIN 的确认。</p><p>Note that FIN implies PUSH for any segment text not yet delivered to the user.<br>注意，对于还没有传给用户的任何段内容，FIN 意味着 PUSH。</p><p>SYN-RECEIVED STATE
ESTABLISHED STATE</p><p>Enter the CLOSE-WAIT state.<br>进入 CLOSE-WAIT 状态。</p><p>FIN-WAIT-1 STATE</p><p>If our FIN has been ACKed (perhaps in this segment), then enter TIME-WAIT, start the time-wait timer, turn off the other timers; otherwise enter the CLOSING state.<br>如果我们的 FIN 已经被 ACK 了（可能在这个段），那么进入 TIME-WAIT，启动 time-wait 定时器，关闭其他定时器；否则进入 CLOSING 状态。</p><p>FIN-WAIT-2 STATE</p><p>Enter the TIME-WAIT state. Start the time-wait timer, turn off the other timers.<br>进入 TIME-WAIT 状态。 启动时间等待定时器，关闭其他定时器。</p><p>CLOSE-WAIT STATE</p><p>Remain in the CLOSE-WAIT state.<br>保持在 CLOSE-WAIT 状态。</p><p>CLOSING STATE</p><p>Remain in the CLOSING state.<br>保持在 CLOSING 状态。</p><p>LAST-ACK STATE</p><p>Remain in the LAST-ACK state.<br>保持在 LAST-ACK 状态。</p><p>TIME-WAIT STATE</p><p>Remain in the TIME-WAIT state. Restart the 2 MSL time-wait timeout.<br>保持在 TIME-WAIT 状态，重启 2MSL 超时定时器。</p></div><p>and return.<br>然后返回。</p><p>USER TIMEOUT</p><p>For any state if the user timeout expires, flush all queues, signal the user &ldquo;error: connection aborted due to user timeout&rdquo; in general and for any outstanding calls, delete the TCB, enter the CLOSED state and return.
对于任何状态，如果用户超时到期，清空所有队列，对于任何未完成的调用，向用户发出信号 &ldquo;error: connection aborted due to user timeout&rdquo;，删除 TCB，进入到 CLOSE 状态并返回。</p><p>RETRANSMISSION TIMEOUT</p><p>For any state if the retransmission timeout expires on a segment in the retransmission queue, send the segment at the front of the retransmission queue again, reinitialize the retransmission timer, and return.<br>对于任何状态，如果重传队列中的一个段的重传超时，再次发送重传队列前面的段，重新初始化重传定时器，然后返回。</p><p>TIME-WAIT TIMEOUT</p><p>If the time-wait timeout expires on a connection delete the TCB, enter the CLOSED state and return.<br>如果连接中的 time-wait 超时，则删除 TCB，进入 CLOSED 状态并返回。</p><h2 id=词汇表>词汇表
<a class=anchor href=#%e8%af%8d%e6%b1%87%e8%a1%a8>#</a></h2><p><strong>GLOSSARY</strong></p><p><strong>1822</strong><br>BBN Report 1822, &ldquo;The Specification of the Interconnection of a Host and an IMP&rdquo;.<br>BBN Report 1822，&ldquo;主机与 IMP 互连规范&rdquo;。</p><p>The specification of interface between a host and the ARPANET.<br>主机和 ARPANET 之间的接口规范。</p><p><strong>ACK</strong><br>A control bit (acknowledge) occupying no sequence space, which indicates that the acknowledgment field of this segment specifies the next sequence number the sender of this segment is expecting to receive, hence acknowledging receipt of all previous sequence numbers.<br>不占用序列空间的控制位（确认），它表明该段的确认字段表示该段的发送方期望接收的下一个序列号，并且确认收到所有先前的序列号。</p><p><strong>ARPANET message</strong><br>The unit of transmission between a host and an IMP in the ARPANET. The maximum size is about 1012 octets (8096 bits).<br>ARPANET 中主机和 IMP 之间的传输单位。最大值约为 1012 个 octets（8096 bit）。</p><p><strong>ARPANET packet</strong><br>A unit of transmission used internally in the ARPANET between IMPs. The maximum size is about 126 octets (1008 bits).<br>ARPANET 中 IMP 之间使用的一种传输单位。最大尺寸约为 126 个 octets（1008 bit）。</p><p><strong>connection</strong><br>A logical communication path identified by a pair of sockets.<br>由一对套接字标识的逻辑通信通道。</p><p><strong>datagram</strong><br>A message sent in a packet switched computer communications network.<br>在分组交换计算机通信网络中发送的消息。</p><p><strong>Destination Address</strong><br>The destination address, usually the network and host identifiers.<br>目标地址，通常是网络和主机标识符。</p><p><strong>FIN</strong><br>A control bit (finis) occupying one sequence number, which indicates that the sender will send no more data or control occupying sequence space.<br>占用一个序列号的控制位（finis），表示发送方将不再发送数据或占用序列空间的控制。</p><p><strong>fragment</strong><br>A portion of a logical unit of data, in particular an internet fragment is a portion of an internet datagram.<br>数据的逻辑单位的一部分，特别是网络片段是网络数据报的一部分。</p><p><strong>FTP</strong><br>A file transfer protocol.<br>文件传输协议。</p><p><strong>header</strong><br>Control information at the beginning of a message, segment, fragment, packet or block of data.<br>消息、段、分段、数据包或数据块开头的控制信息。</p><p><strong>host</strong><br>A computer. In particular a source or destination of messages from the point of view of the communication network.<br>一台计算机，特别是从通信网络的角度来看，是信息的来源或目的地。</p><p><strong>Identification</strong><br>An Internet Protocol field. This identifying value assigned by the sender aids in assembling the fragments of a datagram.<br>IP 协议字段，发送方分配的这个标识值有助于组装数据报的分段。</p><p><strong>IMP</strong><br>The Interface Message Processor, the packet switch of the ARPANET.<br>接口消息处理器，ARPANET 的分组交换机。</p><p><strong>internet address</strong><br>A source or destination address specific to the host level.<br>主机级别的源地址或目标地址。</p><p><strong>internet datagram</strong><br>The unit of data exchanged between an internet module and the higher level protocol together with the internet header.<br>在 Internet 模块和更高级别的协议之间交换的数据单元连同 Internet 报头。</p><p><strong>internet fragment</strong><br>A portion of the data of an internet datagram with an internet header.
带有 Internet 报头的 Internet 数据报的一部分数据。</p><p><strong>IP</strong><br>Internet Protocol.
网际互连/IP 协议。</p><p><strong>IRS</strong><br>The Initial Receive Sequence number. The first sequence number used by the sender on a connection.<br>初始接收序列号，发送方在连接上使用的第一个序列号。</p><p><strong>ISN</strong><br>The Initial Sequence Number. The first sequence number used on a connection, (either ISS or IRS). Selected on a clock based procedure.<br>初始序列号，连接上使用的第一个序列号（ISS 或 IRS），在基于时钟的程序中选择。</p><p><strong>ISS</strong><br>The Initial Send Sequence number. The first sequence number used by the sender on a connection.<br>初始发送序列号，发送方在连接上使用的第一个序列号。</p><p><strong>leader</strong><br>Control information at the beginning of a message or block of data. In particular, in the ARPANET, the control information on an ARPANET message at the host-IMP interface.<br>消息或数据块开头的控制信息， 特别是 ARPANET 中，在 主机-IMP 接口上的 ARPANET 消息上的控制信息。</p><p><strong>left sequence</strong><br>This is the next sequence number to be acknowledged by the data receiving TCP (or the lowest currently unacknowledged sequence number) and is sometimes referred to as the left edge of the send window.<br>这是数据接收 TCP 确认的下一个序列号（或当前未确认的最低序列号），有时称为发送窗口的左边缘。</p><p><strong>local packet</strong><br>The unit of transmission within a local network.<br>本地网络中的传输单元。</p><p><strong>module</strong><br>An implementation, usually in software, of a protocol or other procedure.<br>协议或其他程序的实现，通常在软件中。</p><p><strong>MSL</strong><br>Maximum Segment Lifetime, the time a TCP segment can exist in the internetwork system. Arbitrarily defined to be 2 minutes.<br>最大段存活时间，TCP 段可以存在于网络中的时间，定义为 2 分钟。</p><p><strong>octet</strong><br>An eight bit byte.<br>一个八位字节。</p><p><strong>Options</strong><br>An Option field may contain several options, and each option may be several octets in length.<br>选项字段可能包含多个选项，每个选项的长度可能是几个字节。</p><p>The options are used primarily in testing situations; for example, to carry timestamps.<br>选项主要用于测试场景；例如，携带时间戳。</p><p>Both the Internet Protocol and TCP provide for options fields.<br>IP 协议和 TCP 协议都提供选项字段。</p><p><strong>packet</strong><br>A package of data with a header which may or may not be logically complete.<br>带有报头的数据包，在逻辑上可能完整也可能不完整。</p><p>More often a physical packaging than a logical packaging of data.<br>数据的物理打包比逻辑打包更常见。</p><p><strong>port</strong><br>The portion of a socket that specifies which logical input or output channel of a process is associated with the data.<br>套接字的一部分，它指定进程的哪个逻辑输入或输出通道与数据相关联。</p><p><strong>process</strong><br>A program in execution. A source or destination of data from the point of view of the TCP or other host-to-host protocol.<br>正在执行的程序，从 TCP 或其他主机到主机协议的角度来看，数据的来源或目的地。</p><p><strong>PUSH</strong><br>A control bit occupying no sequence space, indicating that this segment contains data that must be pushed through to the receiving user.<br>不占用序列空间的控制位，表示该段包含必须推送给接收用户的数据。</p><p><strong>RCV.NXT</strong><br>receive next sequence number<br>接收下一个序列号</p><p><strong>RCV.UP</strong><br>receive urgent pointer<br>接收紧急指针</p><p><strong>RCV.WND</strong><br>receive window<br>接收窗口</p><p><strong>receive next sequence number</strong><br>This is the next sequence number the local TCP is expecting to receive.<br>这是本地 TCP 期望接收的下一个序列号。</p><p><strong>receive window</strong><br>This represents the sequence numbers the local (receiving) TCP is willing to receive.<br>这表示本地（接收）TCP 可接收的序列号。</p><p>Thus, the local TCP considers that segments overlapping the range RCV.NXT to RCV.NXT + RCV.WND - 1 carry acceptable data or control.<br>因此，本地 TCP 认为与范围 RCV.NXT 到 RCV.NXT + RCV.WND - 1 重叠的段携带有效的数据或控制。</p><p>Segments containing sequence numbers entirely outside of this range are considered duplicates and discarded.<br>完全超出此范围的序列号的段被认为是重复的并被丢弃。</p><p><strong>RST</strong><br>A control bit (reset), occupying no sequence space, indicating that the receiver should delete the connection without further interaction.<br>控制位（重置），不占用序列空间，表示接收方应该删除连接而不需要进一步的交互。</p><p>The receiver can determine, based on the sequence number and acknowledgment fields of the incoming segment, whether it should honor the reset command or ignore it.<br>接收方可以根据传入段的序列号和确认字段来确定它是应该遵守重置命令还是忽略它。</p><p>In no case does receipt of a segment containing RST give rise to a RST in response.<br>在任何情况下，收到包含 RST 的段都不会产生 RST 作为响应。</p><p><strong>RTP</strong><br>Real Time Protocol: A host-to-host protocol for communication of time critical information.
实时协议，用于时间关键信息通信的主机到主机协议。</p><p><strong>SEG.ACK</strong><br>segment acknowledgment<br>段的确认</p><p><strong>SEG.LEN</strong><br>segment length<br>段的长度</p><p><strong>SEG.PRC</strong><br>segment precedence value<br>段的优先级</p><p><strong>SEG.SEQ</strong><br>segment sequence<br>段的序列号</p><p><strong>SEG.UP</strong><br>segment urgent pointer field<br>段的紧急指针</p><p><strong>SEG.WND</strong><br>segment window field<br>段的接收窗口</p><p><strong>segment</strong><br>A logical unit of data, in particular a TCP segment is the unit of data transfered between a pair of TCP modules.<br>逻辑数据单元，特别的是， TCP 段是在一对 TCP 模块之间传输的数据单元。</p><p><strong>segment acknowledgment</strong><br>The sequence number in the acknowledgment field of the arriving segment.<br>到达段的确认字段中的序号。</p><p><strong>segment length</strong><br>The amount of sequence number space occupied by a segment, including any controls which occupy sequence space.<br>段所占用的序列号空间的数量，包括任何占用序列空间的控制位。</p><p><strong>segment sequence</strong><br>The number in the sequence field of the arriving segment.<br>到达段的序列字段中的序列号。</p><p><strong>send sequence</strong><br>This is the next sequence number the local (sending) TCP will use on the connection.<br>这是本地（发送）TCP 将在连接上使用的下一个序列号。</p><p>It is initially selected from an initial sequence number curve (ISN) and is incremented for each octet of data or sequenced control transmitted.<br>它最初是从初始序列号曲线 (ISN) 中选择的，并针对传输的每个字节数据或顺序控制递增。</p><p><strong>send window</strong><br>This represents the sequence numbers which the remote (receiving) TCP is willing to receive.<br>这表示远程（接收）TCP 期望接收的序列号。</p><p>It is the value of the window field specified in segments from the remote (data receiving) TCP.<br>它是来自远程（数据接收）TCP 的段中指定的窗口字段的值。</p><p>The range of sequence numbers which may be emitted by a TCP lies between SND.NXT and SND.UNA + SND.WND - 1.(Retransmissions of sequence numbers between SND.UNA and SND.NXT are expected, of course.)<br>TCP 可能发出的序列号范围位于 SND.NXT 和 SND.UNA + SND.WND - 1 之间。（当然，在 SND.UNA 和 SND.NXT 之间重传序列号是意料之中的。）</p><p><strong>SND.NXT</strong><br>send sequence<br>发送序列</p><p><strong>SND.UNA</strong><br>left sequence<br>左边序列（未确认的序列）</p><p><strong>SND.UP</strong>
send urgent pointer<br>发送紧急指针</p><p><strong>SND.WL1</strong><br>segment sequence number at last window update<br>在最后一次窗口更新时的序列号</p><p><strong>SND.WL2</strong><br>segment acknowledgment number at last window update<br>在最后一次窗口更新时的确认号</p><p>*SND.WND**<br>send window<br>发送窗口</p><p><strong>socket</strong><br>An address which specifically includes a port identifier, that is, the concatenation of an Internet Address with a TCP port.<br>包括具体端口标识符的地址，即网络地址与 TCP 端口的组合。</p><p><strong>Source Address</strong><br>The source address, usually the network and host identifiers.<br>源地址，通常是网络和主机标识符。</p><p><strong>SYN</strong><br>A control bit in the incoming segment, occupying one sequence number, used at the initiation of a connection, to indicate where the sequence numbering will start.<br>接收段中的控制位，占用一个序列号，在建立连接时使用，以指示序列号将从何处开始。</p><p><strong>TCB</strong><br>Transmission control block, the data structure that records the state of a connection.<br>传输控制块，记录连接状态的数据结构。</p><p><strong>TCB.PRC</strong><br>The precedence of the connection.<br>连接的优先级。</p><p><strong>TCP</strong><br>Transmission Control Protocol: A host-to-host protocol for reliable communication in internetwork environments.<br>传输控制协议：用于在互联网络环境中进行可靠通信的主机到主机协议。</p><p><strong>TOS</strong><br>Type of Service, an Internet Protocol field.<br>服务类型，IP 协议字段。</p><p><strong>Type of Service</strong><br>An Internet Protocol field which indicates the type of service for this internet fragment.
IP 协议字段，表示网络数据段的服务类型。</p><p><strong>URG</strong><br>A control bit (urgent), occupying no sequence space, used to indicate that the receiving user should be notified to do urgent processing as long as there is data to be consumed with sequence numbers less than the value indicated in the urgent pointer.<br>控制位（urgent），不占用序列空间，用于表示只要有序列号小于 urgent 指针指示值的数据需要消费，就通知接收用户做紧急处理。</p><p><strong>urgent pointer</strong><br>A control field meaningful only when the URG bit is on.<br>紧急指针，仅当 URG 标志位打开时才有意义的控制字段。</p><p>This field communicates the value of the urgent pointer which indicates the data octet associated with the sending user&rsquo;s urgent call.<br>这个字段是紧急指针的值，表示与发送用户的紧急调用相关的数据。</p><h2 id=参考文献>参考文献
<a class=anchor href=#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae>#</a></h2><p><strong>REFERENCES</strong></p><p>[1] Cerf, V., and R. Kahn, &ldquo;A Protocol for Packet Network Intercommunication,&rdquo; IEEE Transactions on Communications, Vol. COM-22, No. 5, pp 637-648, May 1974.</p><p>[2] Postel, J. (ed.), &ldquo;Internet Protocol - DARPA Internet Program Protocol Specification&rdquo;, RFC 791, USC/Information Sciences Institute, September 1981.</p><p>[3] Dalal, Y. and C. Sunshine, &ldquo;Connection Management in Transport Protocols&rdquo;, Computer Networks, Vol. 2, No. 6, pp. 454-473, December 1978.</p><p>[4] Postel, J., &ldquo;Assigned Numbers&rdquo;, RFC 790, USC/Information Sciences Institute, September 1981.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/zhixingxiaoke/zhixingxiaoke.github.io/commit/a853d2cae9e68184de01564b1f00a4994053da27 title='Last modified by ZXEducation | March 9, 2023' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>March 9, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/zhixingxiaoke/zhixingxiaoke.github.io/edit/main/content/docs/translations/rfc793.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#封面>封面</a></li><li><a href=#目录>目录</a></li><li><a href=#前言>前言</a></li><li><a href=#介绍>介绍</a><ul><li><a href=#动机>动机</a></li><li><a href=#范围>范围</a></li><li><a href=#关于本文>关于本文</a></li><li><a href=#接口>接口</a></li><li><a href=#操作>操作</a></li></ul></li><li><a href=#基本原理>基本原理</a><ul><li><a href=#互联网系统的要素>互联网系统的要素</a></li><li><a href=#运作模式>运作模式</a></li><li><a href=#主机环境>主机环境</a></li><li><a href=#接口-1>接口</a></li><li><a href=#与其他协议的关系>与其他协议的关系</a></li><li><a href=#可靠的通信>可靠的通信</a></li><li><a href=#连接的建立和清除>连接的建立和清除</a></li></ul></li><li><a href=#数据通信>数据通信</a><ul><li><a href=#优先级和安全性>优先级和安全性</a></li><li><a href=#稳健性原则>稳健性原则</a></li></ul></li><li><a href=#功能规范>功能规范</a><ul><li><a href=#头部格式>头部格式</a></li><li><a href=#术语表>术语表</a></li><li><a href=#序列号>序列号</a></li><li><a href=#建立连接>建立连接</a></li><li><a href=#关闭连接>关闭连接</a></li><li><a href=#优先级和安全性-1>优先级和安全性</a></li><li><a href=#数据通信-1>数据通信</a></li><li><a href=#接口-2>接口</a></li><li><a href=#事件处理>事件处理</a></li></ul></li><li><a href=#词汇表>词汇表</a></li><li><a href=#参考文献>参考文献</a></li></ul></nav></div></aside></main></body></html>