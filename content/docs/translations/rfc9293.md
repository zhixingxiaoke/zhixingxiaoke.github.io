---
title: RFC9293 TCP åè®®
weight: 3
draft: true
# bookFlatSection: false
# bookToc: true
# bookHidden: false
# bookCollapseSection: false
# bookComments: false
# bookSearchExclude: false
---

# RFC9293 TCP åè®®ä¸­æ–‡ç¿»è¯‘

è¿™æ˜¯ RFC ä¸Šæœ€æ–°ï¼ˆæˆªæ­¢åˆ° 2023 å¹´ 3 æœˆï¼‰å®Œæ•´æè¿°äº† TCP åè®®æ ‡å‡†çš„æ–‡æ¡£ï¼Œå®ƒæ•´åˆäº† RFC793 æå‡ºçš„ TCP è§„èŒƒä»¥åŠåæ¥æå‡ºçš„å¤šé¡¹ä¼˜åŒ– ï¼Œå¦‚æœå¯¹ RFC793 æ„Ÿå…´è¶£å¯ä»¥å‚è€ƒ[RFC793 TCP åè®®ä¸­æ–‡ç¿»è¯‘](../translations/rfc793)ã€‚

åŸæ–‡ï¼š[Transmission Control Protocol (TCP)](https://datatracker.ietf.org/doc/rfc9293/)

## å°é¢

Internet Engineering Task Force (IETF)  
STD: 7  
Request for Comments: 9293  
Obsoletes: 793, 879, 2873, 6093, 6429, 6528, 6691  
Updates: 1011, 1122, 5961  
Category: Standards Track  
ISSN: 2070-1721

{{< right >}}
W. Eddy, Ed.  
MTI Systems  
August 2022
{{< /right >}}

{{< center >}}
Transmission Control Protocol (TCP)  
ä¼ è¾“æ§åˆ¶åè®®ï¼ˆTCPï¼‰
{{< /center >}}

## æ‘˜è¦

**Abstract**

This document specifies the Transmission Control Protocol (TCP).  
æœ¬æ–‡æ¡£è§„å®šäº†ä¼ è¾“æ§åˆ¶åè®®ï¼ˆTCPï¼‰ã€‚

TCP is an important transport-layer protocol in the Internet protocol stack, and it has continuously evolved over decades of use and growth of the Internet.  
TCP æ˜¯ Internet åè®®æ ˆä¸­é‡è¦çš„ä¼ è¾“å±‚åè®®ï¼Œåœ¨äº’è”ç½‘æ•°åå¹´çš„ä½¿ç”¨å’Œå‘å±•è¿‡ç¨‹ä¸­ä¸æ–­æ”¹è¿›ã€‚

Over this time, a number of changes have been made to TCP as it was specified in RFC 793, though these have only been documented in a piecemeal fashion.  
åœ¨è¿™æ®µæ—¶é—´é‡Œï¼Œå·²ç»å¯¹ RFC 793 ä¸­è§„å®šçš„ TCP è¿›è¡Œäº†ä¸€äº›ä¿®æ”¹ï¼Œå°½ç®¡è¿™äº›ä¿®æ”¹åªæ˜¯ä»¥é›¶æ•£çš„æ–¹å¼è¢«è®°å½•ä¸‹æ¥ã€‚

This document collects and brings those changes together with the protocol specification from RFC 793.  
æœ¬æ–‡ä»¶æ”¶é›†äº†è¿™äº›å˜åŒ–ï¼Œå¹¶å°†å…¶ä¸ RFC 793 çš„åè®®è§„èŒƒç»“åˆåœ¨ä¸€èµ·ã€‚

This document obsoletes RFC 793, as well as RFCs 879, 2873, 6093, 6429, 6528, and 6691 that updated parts of RFC 793.  
æœ¬æ–‡æ¡£åºŸå¼ƒäº† RFC 793ï¼Œä»¥åŠæ›´æ–°äº† RFC 793 éƒ¨åˆ†å†…å®¹çš„ RFC 879ã€2873ã€6093ã€6429ã€6528 å’Œ 6691ã€‚

It updates RFCs 1011 and 1122, and it should be considered as a replacement for the portions of those documents dealing with TCP requirements.  
å®ƒæ›´æ–°äº† RFC 1011 å’Œ 1122ï¼Œå®ƒå¯ä»¥è¢«è§†ä¸ºé‚£äº›æ–‡æ¡£ä¸­æ¶‰åŠ TCP è¦æ±‚çš„éƒ¨åˆ†çš„æ›¿ä»£å“ã€‚

It also updates RFC 5961 by adding a small clarification in reset handling while in the SYN-RECEIVED state.  
å®ƒè¿˜æ›´æ–°äº† RFC 5961ï¼Œåœ¨ SYN-RECEIVED çŠ¶æ€ä¸‹åœ¨é‡ç½®å¤„ç†ä¸­æ·»åŠ äº†ä¸€ä¸ªå°çš„è¯´æ˜ã€‚

The TCP header control bits from RFC 793 have also been updated based on RFC 3168.  
RFC 793 ä¸­çš„ TCP å¤´æ§åˆ¶ä½ä¹Ÿæ ¹æ® RFC 3168 è¿›è¡Œäº†æ›´æ–°ã€‚

**Status of This Memo**

This is an Internet Standards Track document.  
è¿™æ˜¯ä¸€ä»½äº’è”ç½‘æ ‡å‡†è¿½è¸ªæ–‡ä»¶ã€‚

This document is a product of the Internet Engineering Task Force (IETF).  
æœ¬æ–‡æ¡£æ˜¯ Internet å·¥ç¨‹ä»»åŠ¡ç»„ (IETF) çš„äº§å“ã€‚

It represents the consensus of the IETF community.  
å®ƒä»£è¡¨äº† IETF ç¤¾åŒºçš„å…±è¯†ã€‚

It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG).  
å®ƒå·²ç»æ¥å—äº†å…¬ä¼—å®¡é˜…ï¼Œå¹¶å·²è¢«äº’è”ç½‘å·¥ç¨‹æŒ‡å¯¼å°ç»„ (IESG) æ‰¹å‡†å‘å¸ƒã€‚

Further information on Internet Standards is available in Section 2 of RFC 7841.  
æœ‰å…³ Internet æ ‡å‡†çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… RFC 7841 çš„ç¬¬ 2 èŠ‚ã€‚

Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9293.  
æœ‰å…³æœ¬æ–‡æ¡£çš„å½“å‰çŠ¶æ€ã€ä»»ä½•å‹˜è¯¯è¡¨ä»¥åŠå¦‚ä½•æä¾›åé¦ˆçš„ä¿¡æ¯ï¼Œè¯·è®¿é—® [ğŸ”—](https://www.rfc-editor.org/info/rfc9293)ã€‚

## ç‰ˆæƒå£°æ˜

**Copyright Notice**

Copyright (c) 2022 IETF Trust and the persons identified as the document authors.  
Copyright (c) 2022 IETF Trust å’Œè¢«è®¤å®šä¸ºæœ¬æ–‡æ¡£ä½œè€…çš„äººå‘˜ã€‚

All rights reserved.  
ä¿ç•™æ‰€æœ‰æƒåˆ©ã€‚

This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  
æœ¬æ–‡æ¡£å— BCP 78 å’Œ IETF ä¿¡æ‰˜ä¸ IETF æ–‡æ¡£ç›¸å…³çš„æ³•å¾‹è§„å®š [ğŸ”—](https://trustee.ietf.org/license-info) çš„çº¦æŸï¼Œè¿™äº›æ¡æ¬¾åœ¨æœ¬æ–‡æ¡£å‘å¸ƒä¹‹æ—¥ç”Ÿæ•ˆã€‚

Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  
è¯·ä»”ç»†é˜…è¯»è¿™äº›æ–‡ä»¶ï¼Œå› ä¸ºå®ƒä»¬æè¿°äº†æ‚¨å¯¹æœ¬æ–‡ä»¶çš„æƒåˆ©å’Œé™åˆ¶ã€‚

Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.  
ä»æœ¬æ–‡ä»¶ä¸­æå–çš„ä»£ç ç»„ä»¶å¿…é¡»åŒ…æ‹¬ä¿¡æ‰˜æ³•å¾‹æ¡æ¬¾ç¬¬ 4.e èŠ‚ä¸­æè¿°çš„ä¿®è®¢ç‰ˆ BSD è®¸å¯æ–‡æœ¬ï¼Œå¹¶ä¸”ä¸æä¾›ä¿®è®¢ç‰ˆ BSD è®¸å¯ä¸­æè¿°çš„ä¿è¯ã€‚

This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008.  
æœ¬æ–‡æ¡£å¯èƒ½åŒ…å« 2008 å¹´ 11 æœˆ 10 æ—¥ä¹‹å‰å‘å¸ƒæˆ–å…¬å¼€æä¾›çš„ IETF æ–‡æ¡£æˆ– IETF æ–‡ç¨¿ä¸­çš„ææ–™ã€‚

The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process.  
æ§åˆ¶æœ¬ææ–™æŸäº›ç‰ˆæƒçš„äººå¯èƒ½æœªæˆäºˆ IETF ä¿¡æ‰˜å…è®¸åœ¨ IETF æ ‡å‡†æµç¨‹ä¹‹å¤–ä¿®æ”¹æ­¤ç±»ææ–™çš„æƒåˆ©ã€‚

Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.  
å¦‚æœæ²¡æœ‰ä»æ§åˆ¶æ­¤ç±»ææ–™çš„ç‰ˆæƒçš„äººé‚£é‡Œè·å¾—è¶³å¤Ÿçš„è®¸å¯ï¼Œåˆ™ä¸å¾—åœ¨ IETF æ ‡å‡†æµç¨‹ä¹‹å¤–ä¿®æ”¹æœ¬æ–‡æ¡£ï¼Œå¹¶ä¸”ä¸å¾—åœ¨ IETF æ ‡å‡†æµç¨‹ä¹‹å¤–åˆ›å»ºå…¶è¡ç”Ÿä½œå“ï¼Œé™¤éå°†å…¶æ ¼å¼åŒ–ä¸º RFC å‡ºç‰ˆæˆ–å°†å…¶ç¿»è¯‘æˆè‹±è¯­ä»¥å¤–çš„å…¶ä»–è¯­è¨€ã€‚

## ç›®å½•

{{< center >}}
Table of Contents
{{< /center >}}

1.Purpose and Scope ç›®çš„å’ŒèŒƒå›´

2.Introduction ä»‹ç»  
&emsp;2.1. Requirements Language éœ€æ±‚è¯­è¨€  
&emsp;2.2. Key TCP Concepts å…³é”®çš„ TCP æ¦‚å¿µ

3.Functional Specification åŠŸèƒ½è§„èŒƒ  
&emsp;3.1. Header Format å¤´éƒ¨æ ¼å¼  
&emsp;3.2. Specific Option Definitions å…·ä½“é€‰é¡¹å®šä¹‰  
&emsp;&emsp;3.2.1. Other Common Options å…¶ä»–å¸¸ç”¨é€‰é¡¹  
&emsp;&emsp;3.2.2. Experimental TCP Options å®éªŒæ€§ TCP é€‰é¡¹  
&emsp;3.3. TCP Terminology Overview TCP æœ¯è¯­æ¦‚è¿°  
&emsp;&emsp;3.3.1. Key Connection State Variables å…³é”®è¿æ¥çŠ¶æ€å˜é‡  
&emsp;&emsp;3.3.2. State Machine Overview çŠ¶æ€æœºæ¦‚è¿°  
&emsp;3.4. Sequence Numbers åºåˆ—å·  
&emsp;&emsp;3.4.1. Initial Sequence Number Selection åˆå§‹åºåˆ—å·é€‰æ‹©  
&emsp;&emsp;3.4.2. Knowing When to Keep Quiet çŸ¥é“ä»€ä¹ˆæ—¶å€™è¯¥ä¿æŒé™é»˜  
&emsp;&emsp;3.4.3. The TCP Quiet Time Concept TCP é™é»˜æ—¶é—´æ¦‚å¿µ  
&emsp;3.5. Establishing a Connection å»ºç«‹è¿æ¥  
&emsp;&emsp;3.5.1. Half-Open Connections and Other Anomalies åŠå¼€è¿æ¥å’Œå…¶ä»–å¼‚å¸¸  
&emsp;&emsp;3.5.2. Reset Generation é‡ç½®ç”Ÿæˆ  
&emsp;&emsp;3.5.3. Reset Processing é‡ç½®å¤„ç†  
&emsp;3.6. Closing a Connection å…³é—­è¿æ¥  
&emsp;&emsp;3.6.1. Half-Closed Connections åŠé—­è¿æ¥  
&emsp;3.7. Segmentation åˆ†æ®µ  
&emsp;&emsp;3.7.1. Maximum Segment Size Option æœ€å¤§æ®µé•¿åº¦é€‰é¡¹  
&emsp;&emsp;3.7.2. Path MTU Discovery è·¯å¾„ MTU å‘ç°  
&emsp;&emsp;3.7.3. Interfaces with Variable MTU Values å¯å˜ MTU å€¼çš„æ¥å£  
&emsp;&emsp;3.7.4. Nagle Algorithm Nagle ç®—æ³•  
&emsp;&emsp;3.7.5. IPv6 Jumbograms  
&emsp;3.8. Data Communication æ•°æ®é€šä¿¡  
&emsp;&emsp;3.8.1. Retransmission Timeout é‡ä¼ è¶…æ—¶  
&emsp;&emsp;3.8.2. TCP Congestion Control TCP æ‹¥å¡æ§åˆ¶  
&emsp;&emsp;3.8.3. TCP Connection Failures TCP è¿æ¥æ•…éšœ  
&emsp;&emsp;3.8.4. TCP Keep-Alives  
&emsp;&emsp;3.8.5. The Communication of Urgent Information ç´§æ€¥ä¿¡æ¯çš„é€šä¿¡  
&emsp;&emsp;3.8.6. Managing the Window ç®¡ç†çª—å£  
&emsp;3.9. Interfaces æ¥å£  
&emsp;&emsp;3.9.1. User/TCP Interface ç”¨æˆ·/TCP æ¥å£  
&emsp;&emsp;3.9.2. TCP/Lower-Level Interface TCP/ä¸‹å±‚åè®®æ¥å£  
&emsp;3.10. Event Processing äº‹ä»¶å¤„ç†  
&emsp;&emsp;3.10.1. OPEN Call OPEN è°ƒç”¨  
&emsp;&emsp;3.10.2. SEND Call SEND è°ƒç”¨  
&emsp;&emsp;3.10.3. RECEIVE Call RECEIVE è°ƒç”¨  
&emsp;&emsp;3.10.4. CLOSE Call CLOSE è°ƒç”¨  
&emsp;&emsp;3.10.5. ABORT Call ABORT è°ƒç”¨  
&emsp;&emsp;3.10.6. STATUS Call STATUS è°ƒç”¨  
&emsp;&emsp;3.10.7. SEGMENT ARRIVES æ”¶åˆ°æ®µ  
&emsp;&emsp;3.10.8. Timeouts è¶…æ—¶

4.Glossary è¯æ±‡è¡¨

5.Changes from RFC 793 ä¸ RFC 793 ç›¸æ¯”çš„æ”¹åŠ¨

6.IANA Considerations IANA çš„æ³¨æ„äº‹é¡¹

7.Security and Privacy Considerations å®‰å…¨å’Œéšç§æ³¨æ„äº‹é¡¹

8.References å‚è€ƒæ–‡çŒ®  
&emsp;8.1. Normative References è§„èŒƒæ€§å‚è€ƒæ–‡çŒ®  
&emsp;8.2. Informative References éè§„èŒƒæ€§å‚è€ƒæ–‡çŒ®

Appendix A. Other Implementation Notes å…¶ä»–å®ç°è¯´æ˜  
&emsp;A.1. IP Security Compartment and Precedence IP å®‰å…¨éƒ¨åˆ†å’Œä¼˜å…ˆçº§  
&emsp;&emsp;A.1.1. Precedence ä¼˜å…ˆçº§  
&emsp;&emsp;A.1.2. MLS Systems MLS ç³»ç»Ÿ  
&emsp;A.2. Sequence Number Validation åºåˆ—å·éªŒè¯  
&emsp;A.3. Nagle Modification Nagle ä¿®æ”¹  
&emsp;A.4. Low Watermark Settings ä½æ°´å°è®¾ç½®

Appendix B. TCP Requirement Summary TCP è¦æ±‚æ¦‚è¿°

Acknowledgments è‡´è°¢

Author's Address ä½œè€…çš„åœ°å€

## ç›®çš„å’ŒèŒƒå›´

**1.Purpose and Scope**

In 1981, RFC 793 [16] was released, documenting the Transmission Control Protocol (TCP) and replacing earlier published specifications for TCP.  
1981 å¹´ï¼ŒRFC 793 [16] å‘å¸ƒï¼Œè®°å½•äº†ä¼ è¾“æ§åˆ¶åè®® (TCP) å¹¶å–ä»£äº†æ—©æœŸå‘å¸ƒçš„ TCP è§„èŒƒã€‚

Since then, TCP has been widely implemented, and it has been used as a transport protocol for numerous applications on the Internet.  
ä»é‚£æ—¶èµ·ï¼ŒTCP å¾—åˆ°äº†å¹¿æ³›çš„åº”ç”¨ï¼Œå¹¶è¢«ç”¨ä½œ Internet ä¸Šä¼—å¤šåº”ç”¨ç¨‹åºçš„ä¼ è¾“åè®®ã€‚

For several decades, RFC 793 plus a number of other documents have combined to serve as the core specification for TCP [49].  
å‡ åå¹´æ¥ï¼ŒRFC 793 åŠ ä¸Šè®¸å¤šå…¶ä»–æ–‡æ¡£å·²åˆå¹¶ä¸º TCP çš„æ ¸å¿ƒè§„èŒƒ[49]ã€‚

Over time, a number of errata have been filed against RFC 793.  
éšç€æ—¶é—´çš„æµé€ï¼Œå·²ç»é’ˆå¯¹ RFC 793 æå‡ºäº†è®¸å¤šå‹˜è¯¯è¡¨ã€‚

There have also been deficiencies found and resolved in security, performance, and many other aspects.  
åœ¨å®‰å…¨ã€æ€§èƒ½å’Œå…¶ä»–è®¸å¤šæ–¹é¢ä¹Ÿå‘ç°å’Œè§£å†³äº†ä¸€äº›ç¼ºé™·ã€‚

The number of enhancements has grown over time across many separate documents.  
éšç€æ—¶é—´çš„æ¨ç§»ï¼Œæ”¹è¿›çš„æ•°é‡åœ¨è®¸å¤šç‹¬ç«‹çš„æ–‡ä»¶ä¸­ä¸æ–­å¢åŠ ã€‚

These were never accumulated together into a comprehensive update to the base specification.  
è¿™äº›æ”¹è¿›è¿˜æ²¡æœ‰è¢«æ•´åˆåˆ°ä¸€èµ·ï¼Œæ•´ä½“æ›´æ–°åŸºæœ¬è§„èŒƒã€‚

The purpose of this document is to bring together all of the IETF Standards Track changes and other clarifications that have been made to the base TCP functional specification (RFC 793) and to unify them into an updated version of the specification.  
æœ¬æ–‡æ¡£çš„ç›®çš„æ˜¯å°†æ‰€æœ‰ IETF æ ‡å‡†è½¨é“çš„ä¿®æ”¹å’Œå…¶ä»–å¯¹åŸºç¡€ TCP åŠŸèƒ½è§„èŒƒï¼ˆRFC 793ï¼‰çš„è¯´æ˜æ±‡é›†åœ¨ä¸€èµ·ï¼Œå¹¶å°†å®ƒä»¬ç»Ÿä¸€åˆ°è§„èŒƒçš„æ›´æ–°ç‰ˆæœ¬ä¸­ã€‚

Some companion documents are referenced for important algorithms that are used by TCP (e.g., for congestion control) but have not been completely included in this document.  
ä½†æ˜¯ä¸€äº›ç”¨äº TCP ä½¿ç”¨çš„é‡è¦ç®—æ³•ï¼ˆä¾‹å¦‚ï¼Œç”¨äºæ‹¥å¡æ§åˆ¶ï¼‰çš„ç›¸å…³æ–‡æ¡£ï¼Œè¿˜æ²¡æœ‰å®Œå…¨åŒ…æ‹¬åœ¨æœ¬æ–‡æ¡£ä¸­ã€‚

This is a conscious choice, as this base specification can be used with multiple additional algorithms that are developed and incorporated separately.  
è¿™æ˜¯ä¸€ä¸ªæœ‰æ„è¯†çš„é€‰æ‹©ï¼Œå› ä¸ºè¯¥åŸºæœ¬è§„èŒƒå¯ä»¥ä¸å¤šç§é¢å¤–çš„ç®—æ³•ä¸€èµ·ä½¿ç”¨ï¼Œè¿™äº›ç®—æ³•æ˜¯å•ç‹¬å¼€å‘å’Œåˆå¹¶çš„ã€‚

This document focuses on the common basis that all TCP implementations must support in order to interoperate.  
æœ¬æ–‡æ¡£é‡ç‚¹å…³æ³¨æ‰€æœ‰ TCP å®ç°å¿…é¡»æ”¯æŒçš„å…±åŒåŸºç¡€ï¼Œä»¥å®ç°äº’æ“ä½œã€‚

Since some additional TCP features have become quite complicated themselves (e.g., advanced loss recovery and congestion control), future companion documents may attempt to similarly bring these together.  
å› ä¸ºä¸€äº›é¢å¤–çš„ TCP åŠŸèƒ½æœ¬èº«å·²ç»å˜å¾—ç›¸å½“å¤æ‚ï¼ˆä¾‹å¦‚ï¼Œé«˜çº§æŸå¤±æ¢å¤å’Œæ‹¥å¡æ§åˆ¶ï¼‰ï¼Œæœªæ¥çš„é…å¥—æ–‡æ¡£å¯èƒ½ä¼šè¯•å›¾ç±»ä¼¼åœ°å°†è¿™äº›åŠŸèƒ½é›†ä¸­èµ·æ¥ã€‚

In addition to the protocol specification that describes the TCP segment format, generation, and processing rules that are to be implemented in code, RFC 793 and other updates also contain informative and descriptive text for readers to understand aspects of the protocol design and operation.  
é™¤äº†æè¿°è¦åœ¨ä»£ç ä¸­å®ç°çš„ TCP æ®µæ ¼å¼ã€ç”Ÿæˆå’Œå¤„ç†è§„åˆ™çš„åè®®è§„èŒƒå¤–ï¼ŒRFC 793 å’Œå…¶ä»–æ›´æ–°è¿˜åŒ…å«ä¿¡æ¯å’Œæè¿°æ€§å†…å®¹ï¼Œä»¥ä¾¿è¯»è€…äº†è§£åè®®è®¾è®¡å’Œè¿è¡Œçš„å„ä¸ªæ–¹é¢ã€‚

This document does not attempt to alter or update this informative text and is focused only on updating the normative protocol specification.  
æœ¬æ–‡ä»¶å¹¶ä¸è¯•å›¾æ”¹å˜æˆ–æ›´æ–°è¿™äº›ä¿¡æ¯æ€§çš„å†…å®¹ï¼Œè€Œåªæ˜¯ä¸“æ³¨äºæ›´æ–°æ ‡å‡†åŒ–çš„åè®®è§„èŒƒã€‚

This document preserves references to the documentation containing the important explanations and rationale, where appropriate.  
æœ¬æ–‡æ¡£ä¿ç•™äº†å¯¹åŒ…å«é‡è¦è§£é‡Šå’ŒåŸºæœ¬åŸç†çš„æ–‡æ¡£çš„å¼•ç”¨ã€‚

This document is intended to be useful both in checking existing TCP implementations for conformance purposes, as well as in writing new implementations.  
è¯¥æ–‡æ¡£æ—¨åœ¨å¸®åŠ©æ£€æŸ¥ç°æœ‰çš„ TCP å®ç°ä»¥åŠç¼–å†™æ–°å®ç°ã€‚

## ä»‹ç»

**2.Introduction**

RFC 793 contains a discussion of the TCP design goals and provides examples of its operation, including examples of connection establishment, connection termination, and packet retransmission to repair losses.  
RFC 793 åŒ…å«äº†å¯¹ TCP è®¾è®¡ç›®æ ‡çš„è®¨è®ºï¼Œå¹¶æä¾›äº†å…¶æ“ä½œçš„ç¤ºä¾‹ï¼ŒåŒ…æ‹¬å»ºç«‹è¿æ¥ã€å…³é—­è¿æ¥ä»¥åŠå¼¥è¡¥ä¸¢å¤±çš„æ•°æ®åŒ…é‡ä¼ ã€‚

This document describes the basic functionality expected in modern TCP implementations and replaces the protocol specification in RFC 793.  
æœ¬æ–‡æ¡£æè¿°äº†ç°ä»£ TCP å®ç°ä¸­é¢„æœŸçš„åŸºæœ¬åŠŸèƒ½ï¼Œå¹¶æ›¿æ¢äº† RFC 793 ä¸­çš„åè®®è§„èŒƒã€‚

It does not replicate or attempt to update the introduction and philosophy content in Sections 1 and 2 of RFC 793.  
å®ƒä¸ä¼šå¤åˆ¶æˆ–å°è¯•æ›´æ–° RFC 793 ç¬¬ 1 å’Œ 2 èŠ‚ä¸­çš„ç®€ä»‹å’Œç†å¿µå†…å®¹ã€‚

Other documents are referenced to provide explanations of the theory of operation, rationale, and detailed discussion of design decisions.  
è¿˜å‚è€ƒäº†å…¶ä»–æ–‡ä»¶ï¼Œä»¥æä¾›å¯¹æ“ä½œç†è®ºã€åŸç†çš„è§£é‡Šï¼Œä»¥åŠå¯¹è®¾è®¡å†³ç­–çš„è¯¦ç»†è®¨è®ºã€‚

This document only focuses on the normative behavior of the protocol.  
æœ¬æ–‡æ¡£åªå…³æ³¨åè®®çš„æ ‡å‡†è¡Œä¸ºã€‚

The "TCP Roadmap" [49] provides a more extensive guide to the RFCs that define TCP and describe various important algorithms.
"TCP è·¯çº¿å›¾" [49] ä¸ºå®šä¹‰ TCP å’Œæè¿°å„ç§é‡è¦ç®—æ³•çš„ RFC æä¾›äº†æ›´å¹¿æ³›çš„æŒ‡å—ã€‚

The TCP Roadmap contains sections on strongly encouraged enhancements that improve performance and other aspects of TCP beyond the basic operation specified in this document.  
TCP è·¯çº¿å›¾åŒ…å«å¼ºçƒˆæ¨èçš„å¢å¼ºåŠŸèƒ½ï¼Œè¿™äº›å¢å¼ºåŠŸèƒ½å¯ä»¥æé«˜ TCP çš„æ€§èƒ½å’Œå…¶ä»–è¶…å‡ºæœ¬æ–‡æ¡£ä¸­è§„å®šçš„åŸºæœ¬æ“ä½œçš„æ–¹é¢ã€‚

As one example, implementing congestion control (e.g., [8]) is a TCP requirement, but it is a complex topic on its own and not described in detail in this document, as there are many options and possibilities that do not impact basic interoperability.  
ä¸¾ä¸ªä¾‹å­ï¼Œå®ç°æ‹¥å¡æ§åˆ¶ï¼ˆä¾‹å¦‚ï¼Œ[8]ï¼‰æ˜¯ä¸€é¡¹ TCP è¦æ±‚ï¼Œä½†å®ƒæœ¬èº«å°±æ˜¯ä¸€ä¸ªå¤æ‚çš„ä¸»é¢˜ï¼Œå¹¶ä¸”åœ¨æœ¬æ–‡æ¡£ä¸­æ²¡æœ‰è¯¦ç»†æè¿°ï¼Œå› ä¸ºæœ‰è®¸å¤šä¸ä¼šå½±å“åŸºæœ¬çš„äº’æ“ä½œæ€§çš„é€‰é¡¹å’Œå¯èƒ½æ€§ .

Similarly, most TCP implementations today include the high-performance extensions in [47], but these are not strictly required or discussed in this document.  
ç±»ä¼¼åœ°ï¼Œä»Šå¤©çš„å¤§å¤šæ•° TCP å®ç°éƒ½åŒ…æ‹¬ [47] ä¸­çš„é«˜æ€§èƒ½æ‰©å±•ï¼Œä½†è¿™äº›åœ¨æœ¬æ–‡æ¡£ä¸­å¹¶ä¸æ˜¯ä¸¥æ ¼è¦æ±‚æˆ–è®¨è®ºçš„ã€‚

Multipath considerations for TCP are also specified separately in [59].  
TCP çš„å¤šè·¯å¾„æ³¨æ„äº‹é¡¹ä¹Ÿåœ¨ [59] ä¸­å•ç‹¬æŒ‡å®šã€‚

A list of changes from RFC 793 is contained in Section 5.  
ä¸ RFC 793 ç›¸æ¯”çš„æ”¹åŠ¨æ¸…å•åŒ…å«åœ¨ç¬¬ 5 èŠ‚ã€‚

### éœ€æ±‚è¯­è¨€

**2.1. Requirements Language**

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 [3] [12] when, and only when, they appear in all capitals, as shown here.  
æœ¬æ–‡ä¸­çš„å…³é”®è¯ "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", å’Œ "OPTIONAL"ï¼Œå½“ä¸”ä»…å½“å®ƒä»¬ä»¥å¤§å†™å­—æ¯å‡ºç°æ—¶ï¼Œåº”æŒ‰ç…§ BCP 14 [3] [12] ä¸­çš„æè¿°è¿›è¡Œè§£é‡Šï¼Œå¦‚è¿™é‡Œæ‰€ç¤ºã€‚

Each use of RFC 2119 keywords in the document is individually labeled and referenced in Appendix B, which summarizes implementation requirements.  
æ–‡æ¡£ä¸­æ¯æ¬¡ä½¿ç”¨ RFC 2119 å…³é”®å­—éƒ½åœ¨é™„å½• B ä¸­å•ç‹¬æ ‡è®°å’Œå¼•ç”¨ï¼Œé™„å½• B æ€»ç»“äº†å®ç°è¦æ±‚ã€‚

Sentences using "MUST" are labeled as "MUST-X" with X being a numeric identifier enabling the requirement to be located easily when referenced from Appendix B.  
ä½¿ç”¨ "MUST" çš„å¥å­è¢«æ ‡è®°ä¸º "MUST-X"ï¼ŒX æ˜¯ä¸€ä¸ªæ•°å­—æ ‡è¯†ç¬¦ï¼Œå¯ä»¥å¾ˆå®¹æ˜“åœ°ä»é™„å½• B æ‰¾åˆ°å¼•ç”¨çš„è¦æ±‚ã€‚

Similarly, sentences using "SHOULD" are labeled with "SHLD-X", "MAY" with "MAY-X", and "RECOMMENDED" with "REC-X".  
åŒæ ·åœ°ï¼Œä½¿ç”¨ "SHOULD" çš„å¥å­è¢«æ ‡è®°ä¸º "SHLD-X"ï¼Œ"MAY" è¢«æ ‡è®°ä¸º "MAY-X"ï¼Œ"RECOMMENDED" è¢«æ ‡è®°ä¸º "REC-X"ã€‚

For the purposes of this labeling, "SHOULD NOT" and "MUST NOT" are labeled the same as "SHOULD" and "MUST" instances.  
å‡ºäºæ­¤æ ‡ç­¾çš„ç›®çš„ï¼Œ"SHOULD NOT" å’Œ "MUST NOT" çš„æ ‡ç­¾ä¸ "SHOULD" å’Œ "MUST" å®ä¾‹çš„æ ‡ç­¾ç›¸åŒã€‚

### å…³é”®çš„ TCP æ¦‚å¿µ

**2.2. Key TCP Concepts**

TCP provides a reliable, in-order, byte-stream service to applications.  
TCP ä¸ºåº”ç”¨ç¨‹åºæä¾›å¯é ã€æœ‰åºçš„å­—èŠ‚æµæœåŠ¡ã€‚

The application byte-stream is conveyed over the network via TCP segments, with each TCP segment sent as an Internet Protocol (IP) datagram.  
åº”ç”¨ç¨‹åºçš„å­—èŠ‚æµé€šè¿‡ TCP æ®µåœ¨ç½‘ç»œä¸Šä¼ è¾“ï¼Œæ¯ä¸ª TCP æ®µä½œä¸ºäº’è”ç½‘åè®® (IP) æ•°æ®æŠ¥å‘é€ã€‚

TCP reliability consists of detecting packet losses (via sequence numbers) and errors (via per-segment checksums), as well as correction via retransmission.  
TCP å¯é æ€§åŒ…æ‹¬æ£€æµ‹æ•°æ®åŒ…ä¸¢å¤±ï¼ˆé€šè¿‡åºåˆ—å·ï¼‰å’Œé”™è¯¯ï¼ˆé€šè¿‡æ®µæ ¡éªŒå’Œï¼‰ï¼Œä»¥åŠé€šè¿‡é‡ä¼ è¿›è¡Œçº æ­£ã€‚

TCP supports unicast delivery of data.  
TCP æ”¯æŒå•æ’­ä¼ è¾“æ•°æ®ã€‚

There are anycast applications that can successfully use TCP without modifications, though there is some risk of instability due to changes of lower-layer forwarding behavior [46].  
æœ‰ä¸€äº›ä»»æ’­åº”ç”¨ç¨‹åºå¯ä»¥åœ¨ä¸ä¿®æ”¹çš„æƒ…å†µä¸‹æˆåŠŸåœ°ä½¿ç”¨ TCPï¼Œå°½ç®¡ç”±äºä¸‹å±‚è½¬å‘è¡Œä¸ºçš„å˜åŒ–å­˜åœ¨ä¸€äº›ä¸ç¨³å®šçš„é£é™© [46]ã€‚

TCP is connection oriented, though it does not inherently include a liveness detection capability.  
TCP æ˜¯é¢å‘è¿æ¥çš„ï¼Œå°½ç®¡å®ƒæœ¬èº«å¹¶ä¸åŒ…æ‹¬æ´»è·ƒæ€§æ£€æµ‹åŠŸèƒ½ã€‚

Data flow is supported bidirectionally over TCP connections, though applications are free to send data only unidirectionally, if they so choose.  
é€šè¿‡ TCP è¿æ¥åŒå‘æ”¯æŒæ•°æ®æµï¼Œä½†å¦‚æœåº”ç”¨ç¨‹åºæ„¿æ„ï¼Œå®ƒä»¬å¯ä»¥è‡ªç”±åœ°ä»…å•å‘å‘é€æ•°æ®ã€‚

TCP uses port numbers to identify application services and to multiplex distinct flows between hosts.  
TCP ä½¿ç”¨ç«¯å£å·æ¥è¯†åˆ«åº”ç”¨ç¨‹åºæœåŠ¡å¹¶åœ¨ä¸»æœºä¹‹é—´å¤ç”¨ä¸åŒçš„æµã€‚

A more detailed description of TCP features compared to other transport protocols can be found in Section 3.1 of [52].  
ä¸å…¶ä»–ä¼ è¾“åè®®ç›¸æ¯”ï¼ŒTCP åŠŸèƒ½çš„æ›´è¯¦ç»†æè¿°å¯ä»¥åœ¨ [52] çš„ç¬¬ 3.1 èŠ‚ä¸­æ‰¾åˆ°ã€‚

Further description of the motivations for developing TCP and its role in the Internet protocol stack can be found in Section 2 of [16] and earlier versions of the TCP specification.  
å…³äºå¼€å‘ TCP çš„åŠ¨æœºå’Œå®ƒåœ¨äº’è”ç½‘åè®®æ ˆä¸­çš„ä½œç”¨çš„æ›´å¤šæè¿°ï¼Œå¯ä»¥åœ¨[16]çš„ç¬¬ 2 èŠ‚å’Œæ—©æœŸç‰ˆæœ¬çš„ TCP è§„èŒƒä¸­æ‰¾åˆ°ã€‚

## åŠŸèƒ½è§„èŒƒ

**3.Functional Specification**

### å¤´éƒ¨æ ¼å¼

**3.1. Header Format**

TCP segments are sent as internet datagrams.  
TCP æ®µä½œä¸ºç½‘ç»œæ•°æ®æŠ¥å‘é€ã€‚

The Internet Protocol (IP) header carries several information fields, including the source and destination host addresses [1] [13].
ç½‘é™…äº’è”åè®® (IP) æŠ¥å¤´æºå¸¦å¤šä¸ªä¿¡æ¯å­—æ®µï¼ŒåŒ…æ‹¬æºå’Œç›®æ ‡ä¸»æœºåœ°å€ [1] [13]ã€‚

A TCP header follows the IP headers, supplying information specific to TCP.  
TCP å¤´éƒ¨è·Ÿåœ¨ IP å¤´éƒ¨ä¹‹åï¼Œæä¾›ç‰¹å®šäº TCP çš„ä¿¡æ¯ã€‚

This division allows for the existence of host-level protocols other than TCP.  
è¿™ç§åˆ’åˆ†å…è®¸å­˜åœ¨é™¤ TCP ä¹‹å¤–çš„ä¸»æœºçº§åè®®ã€‚

In the early development of the Internet suite of protocols, the IP header fields had been a part of TCP.  
åœ¨ Internet åè®®å¥—ä»¶çš„æ—©æœŸå¼€å‘ä¸­ï¼ŒIP æŠ¥å¤´å­—æ®µä¸€ç›´æ˜¯ TCP çš„ä¸€éƒ¨åˆ†ã€‚

This document describes TCP, which uses TCP headers.  
æœ¬æ–‡æ¡£æè¿°äº†ä½¿ç”¨ TCP å¤´éƒ¨çš„ TCPã€‚

A TCP header, followed by any user data in the segment, is formatted as follows, using the style from [66]:  
åœ¨æ®µä¸­ï¼ŒTCP å¤´éƒ¨åé¢æ˜¯ä»»æ„ç”¨æˆ·æ•°æ®ï¼Œæ ¼å¼å¦‚ä¸‹ï¼Œä½¿ç”¨ [66] ä¸­çš„æ ·å¼ï¼š

{{< center >}}

```
 0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |       Destination Port        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data |       |C|E|U|A|P|R|S|F|                               |
   | Offset| Rsrvd |W|C|R|C|S|S|Y|I|            Window             |
   |       |       |R|E|G|K|H|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           [Options]                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               :
   :                             Data                              :
   :                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

Note that one tick mark represents one bit position.  
æ³¨æ„ï¼šä¸€ä¸ªåˆ»åº¦çº¿ä»£è¡¨ä¸€ä¸ªæ¯”ç‰¹ä½ã€‚

Figure 1: TCP Header Format  
å›¾ 1ï¼šTCP å¤´éƒ¨æ ¼å¼

{{< /center >}}

where:  
å…¶ä¸­ï¼š

**Source Port**: 16 bits  
{{< block-indent >}}
The source port number.  
æºç«¯å£å·
{{< /block-indent >}}

**Destination Port**: 16 bits  
{{< block-indent >}}
The destination port number.  
ç›®æ ‡ç«¯å£å·
{{< /block-indent >}}

**Sequence Number**: 32 bits  
{{< block-indent >}}
The sequence number of the first data octet in this segment (except when SYN is present).  
è¯¥æ®µæ•°æ®ä¸­ç¬¬ä¸€ä¸ªå­—èŠ‚çš„åºåˆ—å·ï¼ˆæœ‰ SYN æ ‡å¿—é™¤å¤–ï¼‰ã€‚  
If SYN is set, the sequence number is the initial sequence number (ISN) and the first data octet is ISN+1.  
å¦‚æœè®¾ç½®äº† SYNï¼Œåˆ™åºåˆ—å·æ˜¯åˆå§‹åºåˆ—å· (ISN)ï¼Œç¬¬ä¸€ä¸ªå­—èŠ‚æ•°æ®æ˜¯ ISN+1ã€‚
{{< /block-indent >}}

**Acknowledgment Number**: 32 bits
{{< block-indent >}}
If the ACK control bit is set, this field contains the value of the next sequence number the sender of the segment is expecting to receive. Once a connection is established, this is always sent.  
å¦‚æœè®¾ç½®äº† ACK æ ‡å¿—ï¼Œè¿™ä¸ªå­—æ®µè¡¨ç¤ºå‘é€è€…æœŸæœ›æ”¶åˆ°çš„ä¸‹ä¸€ä¸ªåºåˆ—å·çš„å€¼ã€‚ä¸€æ—¦å»ºç«‹äº†è¿æ¥ï¼Œä¸€ç›´ä¼šå‘é€è¿™ä¸ªå­—æ®µã€‚
{{< /block-indent >}}

**Data Offset (DOffset)**: 4 bits  
{{< block-indent >}}  
The number of 32 bit words in the TCP Header. This indicates where the data begins. The TCP header (even one including options) is an integer multiple of 32 bits long.  
è¿™ä¸ªæ•°è¡¨ç¤º TCP å¤´éƒ¨çš„é•¿åº¦æœ‰å¤šå°‘ä¸ª 32 bitï¼Œè¡¨ç¤ºçœŸæ­£æ•°æ®å¼€å§‹çš„ä½ç½®ã€‚TCP å¤´éƒ¨ï¼ˆå³ä½¿åŒ…æ‹¬é€‰é¡¹éƒ¨åˆ†ï¼‰çš„é•¿åº¦æ˜¯ 32 bit çš„æ•´æ•°å€ã€‚
{{< /block-indent >}}

**Reserved (Rsrvd)**: 4 bits  
{{< block-indent >}}
A set of control bits reserved for future use. Must be zero in generated segments and must be ignored in received segments if the corresponding future features are not implemented by the sending or receiving host.  
ä¸ºå°†æ¥ä½¿ç”¨è€Œä¿ç•™çš„ä¸€ç»„æ§åˆ¶ä½ã€‚å¦‚æœå‘é€æˆ–æ¥æ”¶ä¸»æœºæœªå®ç°ç›¸åº”çš„æœªæ¥åŠŸèƒ½ï¼Œåˆ™åœ¨ç”Ÿæˆçš„æ®µä¸­å¿…é¡»ä¸ºé›¶ï¼Œå¹¶ä¸”åœ¨æ¥æ”¶çš„æ®µä¸­å¿…é¡»å¿½ç•¥ã€‚
{{< /block-indent >}}

**Control bits**:  
{{< block-indent >}}
The control bits are also known as "flags".  
æ§åˆ¶ä½ä¹Ÿç§°ä¸º "æ ‡å¿—"ã€‚

Assignment is managed by IANA from the "TCP Header Flags" registry [62].  
ç”± IANA ä» "TCP Header Flags" æ³¨å†Œè¡¨ [62] ä¸­ç®¡ç†åˆ†é…ã€‚

The currently assigned control bits are CWR, ECE, URG, ACK, PSH, RST, SYN, and FIN.  
ç›®å‰åˆ†é…çš„æ§åˆ¶ä½æ˜¯ CWRã€ECEã€URGã€ACKã€PSHã€RSTã€SYN å’Œ FINã€‚

CWR: 1 bit

Congestion Window Reduced (see [6]).  
å‡å°‘æ‹¥å¡çª—å£ï¼ˆå‚è§ [6]ï¼‰ã€‚

ECE: 1 bit

ECN-Echo (see [6]).  
æ˜¾å¼æ‹¥å¡é€šçŸ¥å›åº”(å‚è§ [6]).

URG: 1 bit

Urgent pointer field is significant.  
ç´§æ€¥æŒ‡é’ˆå­—æ®µå¾ˆé‡è¦ã€‚

ACK: 1 bit

Acknowledgment field is significant.  
ç¡®è®¤å­—æ®µå¾ˆé‡è¦ã€‚

PSH: 1 bit

Push function (see the Send Call description in Section 3.9.1).  
æ¨é€åŠŸèƒ½ï¼ˆå‚è§ç¬¬ 3.9.1 èŠ‚ä¸­çš„ Send è°ƒç”¨è¯´æ˜ï¼‰ã€‚

RST: 1 bit

Reset the connection.  
é‡ç½®è¿æ¥ã€‚

SYN: 1 bit

Synchronize sequence numbers.  
åŒæ­¥åºåˆ—å·ã€‚

FIN: 1 bit

No more data from sender.  
å‘é€è€…æ²¡æœ‰æ›´å¤šæ•°æ®ã€‚

{{< /block-indent >}}

**Window**: 16 bits
{{< block-indent >}}
The number of data octets beginning with the one indicated in the acknowledgment field which the sender of this segment is willing to accept.  
ä»ç¡®è®¤åºå·å¼€å§‹ï¼Œå‘é€æ–¹å¯ä»¥æ¥æ”¶çš„å­—èŠ‚æ•°ã€‚

The value is shifted when the window scaling extension is used [47].  
å½“ä½¿ç”¨çª—å£ç¼©æ”¾æ‰©å±•æ—¶ï¼Œè¯¥å€¼ä¼šå‘ç”Ÿå˜åŒ– [47]ã€‚

The window size MUST be treated as an unsigned number, or else large window sizes will appear like negative windows and TCP will not work (MUST-1).  
çª—å£å¤§å°å¿…é¡»è¢«è§†ä¸ºæ— ç¬¦å·çš„æ•°å­—ï¼Œå¦åˆ™å¤§çš„çª—å£å¤§å°å°†å‡ºç°è´Ÿçª—å£ï¼ŒTCP å°†æ— æ³•å·¥ä½œï¼ˆMUST-1ï¼‰ã€‚

It is RECOMMENDED that implementations will reserve 32-bit fields for the send and receive window sizes in the connection record and do all window computations with 32 bits (REC-1).  
å»ºè®®å®ç°åœ¨è¿æ¥è®°å½•ä¸­ä¸ºå‘é€å’Œæ¥æ”¶çª—å£å¤§å°ä¿ç•™ 32 ä½å­—æ®µï¼Œå¹¶ä»¥ 32 ä½è¿›è¡Œæ‰€æœ‰çª—å£è®¡ç®—ï¼ˆREC-1ï¼‰ã€‚
{{< /block-indent >}}

**Checksum**: 16 bits  
{{< block-indent >}}
The checksum field is the 16 bit one's complement of the one's complement sum of all 16 bit words in the header and text.  
æ£€éªŒå’Œæ˜¯å¤´éƒ¨å’Œæ•°æ®éƒ¨åˆ†æ‰€æœ‰åˆ†å‰²æˆ 16 bit æ•°çš„ç»è¿‡äºŒè¿›åˆ¶åç æ±‚å’Œå¾—åˆ°çš„æ•°ã€‚

The checksum computation needs to ensure the 16-bit alignment of the data being summed.  
æ ¡éªŒå’Œè®¡ç®—éœ€è¦ç¡®ä¿æ±‚å’Œçš„æ•°æ® 16 ä½å¯¹é½ã€‚

If a segment contains an odd number of header and text octets, alignment can be achieved by padding the last octet with zeros on its right to form a 16-bit word for checksum purposes.  
å¦‚æœæ®µçš„å¤´éƒ¨å’Œå†…å®¹æ˜¯å¥‡æ•°ä¸ªå­—èŠ‚ï¼Œå¯ä»¥é€šè¿‡åœ¨æœ€åä¸€ä¸ªå­—èŠ‚çš„å³ä¾§å¡«å……é›¶æ¥å¯¹é½ï¼Œä»¥ç»„æˆä¸€ä¸ª 16 ä½å­—æ¥å®ç°æ ¡éªŒå’Œã€‚

The pad is not transmitted as part of the segment.  
å¡«å……ä¸ä¼šä½œä¸º TCP æ®µçš„ä¸€éƒ¨åˆ†è¿›è¡Œä¼ è¾“ã€‚

While computing the checksum, the checksum field itself is replaced with zeros.  
åœ¨è®¡ç®—æ ¡éªŒå’Œæ—¶ï¼Œæ ¡éªŒå’Œå­—æ®µæœ¬èº«ç”¨é›¶æ›¿æ¢ã€‚

The checksum also covers a pseudo-header (Figure 2) conceptually prefixed to the TCP header.  
æ ¡éªŒå’Œè¿˜åŒ…æ‹¬äº†ä¸€ä¸ªä¼ªå¤´éƒ¨ï¼ˆå›¾ 2ï¼‰ï¼Œåœ¨æ¦‚å¿µä¸Šä½œä¸º TCP å¤´éƒ¨çš„å‰ç¼€ã€‚

The pseudo-header is 96 bits for IPv4 and 320 bits for IPv6.  
ä¼ªå¤´éƒ¨åœ¨ IPv4 ä¸‹æ˜¯ 96 ä½ï¼Œåœ¨ IPv6 ä¸‹æ˜¯ 320 ä½ã€‚

Including the pseudo-header in the checksum gives the TCP connection protection against misrouted segments.  
åœ¨æ ¡éªŒå’Œä¸­åŒ…å«ä¼ªæ ‡å¤´å¯ä»¥é¿å… TCP è¿æ¥é”™è¯¯è·¯ç”±çš„æ®µã€‚

This information is carried in IP headers and is transferred across the TCP/network interface in the arguments or results of calls by the TCP implementation on the IP layer.  
è¿™äº›ä¿¡æ¯åŒ…å«åœ¨ IP å¤´éƒ¨ä¸­ï¼Œå¹¶åœ¨ TCP/ç½‘ç»œ æ¥å£ä¸Šé€šè¿‡ TCP å¯¹ IP å±‚çš„è°ƒç”¨çš„å‚æ•°æˆ–ç»“æœè¿›è¡Œä¼ è¾“ã€‚

{{< /block-indent >}}

{{< center >}}

```
+--------+--------+--------+--------+
|           Source Address          |
+--------+--------+--------+--------+
|         Destination Address       |
+--------+--------+--------+--------+
|  zero  |  PTCL  |    TCP Length   |
+--------+--------+--------+--------+
```

Figure 2: IPv4 Pseudo-header  
å›¾ 2ï¼šIPv4 ä¼ªå¤´éƒ¨

{{< /center >}}

{{< block-indent >}}
Pseudo-header components for IPv4:  
IPv4 çš„ä¼ªå¤´ç»„æˆ:

Source Address: the IPv4 source address in network byte order  
Source Address: ç½‘ç»œå­—èŠ‚åºçš„ IPv4 æºåœ°å€

Destination Address: the IPv4 destination address in network byte order  
Destination Address: ç½‘ç»œå­—èŠ‚åºçš„ IPv4 ç›®çš„åœ°å€

zero: bits set to zero  
zero: å…¨éƒ¨è®¾ç½®ä¸º 0

PTCL: the protocol number from the IP header  
PTCL: æ¥è‡ª IP å¤´éƒ¨çš„åè®®å·

TCP Length: the TCP header length plus the data length in octets (this is not an explicitly transmitted quantity but is computed), and it does not count the 12 octets of the pseudo-header.
TCP Length: TCP æŠ¥å¤´åŠ ä¸Šæ•°æ®éƒ¨åˆ†çš„é•¿åº¦ï¼Œå•ä½æ˜¯å­—èŠ‚ï¼ˆè¿™ä¸æ˜¯ä¸€ä¸ªæ˜ç¡®çš„ä¼ è¾“é‡ï¼Œè€Œæ˜¯è®¡ç®—å‡ºæ¥çš„ï¼‰ï¼Œå¹¶ä¸”ä¸åŒ…æ‹¬ 12 å­—èŠ‚çš„ä¼ªå¤´éƒ¨ã€‚

For IPv6, the pseudo-header is defined in Section 8.1 of RFC 8200 [13] and contains the IPv6 Source Address and Destination Address, an Upper-Layer Packet Length (a 32-bit value otherwise equivalent to TCP Length in the IPv4 pseudo-header), three bytes of zero padding, and a Next Header value, which differs from the IPv6 header value if there are extension headers present between IPv6 and TCP.  
å¯¹äº IPv6ï¼Œä¼ªæ ‡å¤´åœ¨ RFC 8200 [13] çš„ç¬¬ 8.1 èŠ‚ä¸­å®šä¹‰ï¼ŒåŒ…å« IPv6 æºåœ°å€å’Œç›®æ ‡åœ°å€ã€ä¸Šå±‚æ•°æ®åŒ…é•¿åº¦ï¼ˆä¸€ä¸ª 32 ä½å€¼ï¼Œå¦åˆ™ç­‰åŒäº IPv4 ä¼ªæ ‡å¤´ä¸­çš„ TCP é•¿åº¦ï¼‰ headerï¼‰ï¼Œä¸‰ä¸ªå­—èŠ‚çš„é›¶å¡«å……å’Œä¸€ä¸ª Next Header å€¼ï¼Œå¦‚æœ IPv6 å’Œ TCP ä¹‹é—´å­˜åœ¨æ‰©å±•å¤´éƒ¨ï¼Œåˆ™è¯¥å€¼ä¸ IPv6 å¤´éƒ¨å€¼ä¸åŒã€‚

The TCP checksum is never optional. The sender MUST generate it (MUST-2) and the receiver MUST check it (MUST-3).  
TCP æ ¡éªŒå’Œæ°¸è¿œä¸æ˜¯å¯é€‰çš„ï¼Œå‘é€æ–¹å¿…é¡»ç”Ÿæˆå®ƒï¼ˆMUST-2ï¼‰å¹¶ä¸”æ¥æ”¶æ–¹å¿…é¡»æ£€æŸ¥å®ƒï¼ˆMUST-3ï¼‰ã€‚

{{< /block-indent >}}

**Urgent Pointer**: 16 bits  
{{< block-indent >}}
This field communicates the current value of the urgent pointer as a positive offset from the sequence number in this segment.  
è¿™ä¸ªå­—æ®µè¡¨ç¤ºå½“å‰ç´§æ€¥æŒ‡é’ˆè·ç¦»æœ¬æ®µä¸­åºåˆ—å·çš„æ­£åç§»ã€‚

The urgent pointer points to the sequence number of the octet following the urgent data.  
ç´§æ€¥æŒ‡é’ˆæŒ‡å‘ç´§æ€¥æ•°æ®åçš„å­—èŠ‚çš„åºåˆ—å·ã€‚

This field should only be interpreted in segments with the URG control bit set.  
è¿™ä¸ªå­—æ®µåªåº”åœ¨è®¾ç½®äº† URG æ ‡å¿—çš„ TCP æ®µä¸­ä½¿ç”¨ã€‚
{{< /block-indent >}}

**Options**:  
{{< block-indent >}}
[TCP Option]; size(Options) == (DOffset-5)\*32; present only when DOffset > 5.  
[TCP Option]; size(Options) == (DOffset-5)\*32; åªæœ‰åœ¨ DOffset > 5 æ—¶å­˜åœ¨.

Note that this size expression also includes any padding trailing the actual options present.  
æ³¨æ„ï¼Œè¿™ä¸ªå¤§å°è¡¨è¾¾å¼è¿˜åŒ…æ‹¬åœ¨å®é™…é€‰é¡¹åé¢çš„ä»»ä½•å¡«å……ã€‚

Options may occupy space at the end of the TCP header and are a multiple of 8 bits in length.  
é€‰é¡¹éƒ¨åˆ†å¯èƒ½å ç”¨ TCP å¤´çš„æœ«å°¾çš„ç©ºé—´ï¼Œé•¿åº¦ä¸º 8bit çš„å€æ•°ã€‚

All options are included in the checksum.  
é€‰é¡¹éƒ¨åˆ†ä¹ŸåŒ…æ‹¬åœ¨æ£€éªŒå’Œçš„è®¡ç®—ä¸­ã€‚

An option may begin on any octet boundary.  
é€‰é¡¹éƒ¨åˆ†å¯ä»¥ä»ä»»ä½•å­—èŠ‚è¾¹ç•Œä¸Šå¼€å§‹ã€‚

There are two cases for the format of an option:  
é€‰é¡¹çš„æ ¼å¼æœ‰ä¸¤ç§æƒ…å†µï¼š

- Case 1: A single octet of option-kind.  
  æƒ…å†µ 1: ä¸€ä¸ªå­—èŠ‚çš„é€‰é¡¹ç±»å‹ã€‚
- Case 2: An octet of option-kind (Kind), an octet of option-length, and the actual option-data octets.  
  æƒ…å†µ 2: ä¸€ä¸ªå­—èŠ‚çš„é€‰é¡¹ç±»å‹(Kind)ã€ä¸€ä¸ªå­—èŠ‚çš„é€‰é¡¹é•¿åº¦å’ŒçœŸæ­£é€‰é¡¹æ•°æ®ã€‚

The option-length counts the two octets of option-kind and option-length as well as the option-data octets.  
é€‰é¡¹é•¿åº¦åŒ…æ‹¬é€‰é¡¹ç§ç±»å’Œé€‰é¡¹é•¿åº¦çš„ä¸¤ä¸ªå­—èŠ‚ï¼Œä»¥åŠé€‰é¡¹æ•°æ®çš„å­—èŠ‚æ•°ã€‚

Note that the list of options may be shorter than the Data Offset field might imply.  
æ³¨æ„ï¼šé€‰é¡¹åˆ—è¡¨å¯èƒ½æ¯”æ•°æ®åç§»å­—æ®µè¦çŸ­ã€‚

The content of the header beyond the End of Option List Option MUST be header padding of zeros (MUST-69).  
é€‰é¡¹åˆ—è¡¨é€‰é¡¹ç»“æŸåçš„å¤´éƒ¨å†…å®¹å¿…é¡»ç”¨é›¶å¡«å……ï¼ˆMUST-69ï¼‰ã€‚

The list of all currently defined options is managed by IANA [62], and each option is defined in other RFCs, as indicated there.  
æ‰€æœ‰å½“å‰å®šä¹‰çš„é€‰é¡¹åˆ—è¡¨ç”± IANA [62] ç®¡ç†ï¼Œæ¯ä¸ªé€‰é¡¹éƒ½åœ¨å…¶ä»– RFC ä¸­å®šä¹‰ï¼Œå¦‚æ­¤å¤„æ‰€ç¤ºã€‚

That set includes experimental options that can be extended to support multiple concurrent usages [45].  
è¯¥åˆ—è¡¨åŒ…æ‹¬å¯ä»¥æ‰©å±•ä»¥æ”¯æŒå¤šä¸ªå¹¶å‘ä½¿ç”¨çš„å®éªŒé€‰é¡¹ [45]ã€‚

A given TCP implementation can support any currently defined options, but the following options MUST be supported (MUST-4 -- note Maximum Segment Size Option support is also part of MUST-14 in Section 3.7.1):  
ç»™å®šçš„ TCP å®ç°å¯ä»¥æ”¯æŒä»»ä½•å½“å‰å®šä¹‰çš„é€‰é¡¹ï¼Œä½†å¿…é¡»æ”¯æŒä»¥ä¸‹é€‰é¡¹ï¼ˆMUST-4 â€”â€” æ³¨æ„æœ€å¤§æ®µå¤§å°é€‰é¡¹æ”¯æŒä¹Ÿæ˜¯ç¬¬ 3.7.1 èŠ‚ä¸­ MUST-14 çš„ä¸€éƒ¨åˆ†ï¼‰ï¼š

{{< /block-indent >}}
{{< center >}}

```
+======+========+============================+
| Kind | Length | Meaning                    |
+======+========+============================+
| 0    | -      | End of Option List Option. |
+------+--------+----------------------------+
| 1    | -      | No-Operation.              |
+------+--------+----------------------------+
| 2    | 4      | Maximum Segment Size.      |
+------+--------+----------------------------+
```

Table 1: Mandatory Option Set  
è¡¨ 1: å¼ºåˆ¶æ€§é€‰é¡¹åˆ—è¡¨
{{< /center >}}

{{< block-indent >}}
These options are specified in detail in Section 3.2.  
è¿™äº›é€‰é¡¹åœ¨ç¬¬ 3.2 èŠ‚ä¸­æœ‰è¯¦ç»†è¯´æ˜ã€‚

A TCP implementation MUST be able to receive a TCP Option in any segment (MUST-5).  
TCP å®ç°å¿…é¡»èƒ½å¤Ÿåœ¨ä»»ä½•æ®µä¸­æ¥æ”¶ TCP é€‰é¡¹ï¼ˆMUST-5ï¼‰ã€‚

A TCP implementation MUST (MUST-6) ignore without error any TCP Option it does not implement, assuming that the option has a length field.  
TCP å®ç°å¿…é¡»ï¼ˆMUST-6ï¼‰æ— è¯¯åœ°å¿½ç•¥å®ƒæ²¡æœ‰å®ç°çš„ä»»ä½• TCP é€‰é¡¹ï¼Œå‡è®¾è¯¥é€‰é¡¹æœ‰ä¸€ä¸ªé•¿åº¦å­—æ®µã€‚

All TCP Options except End of Option List Option (EOL) and No-Operation (NOP) MUST have length fields, including all future options (MUST-68).  
é™¤äº†é€‰é¡¹åˆ—è¡¨ç»“æŸé€‰é¡¹ï¼ˆEOLï¼‰å’Œæ— æ“ä½œï¼ˆNOPï¼‰ä¹‹å¤–çš„æ‰€æœ‰ TCP é€‰é¡¹å¿…é¡»æœ‰é•¿åº¦å­—æ®µï¼ŒåŒ…æ‹¬æ‰€æœ‰æœªæ¥é€‰é¡¹ï¼ˆMUST-68ï¼‰ã€‚

TCP implementations MUST be prepared to handle an illegal option length (e.g., zero); a suggested procedure is to reset the connection and log the error cause (MUST-7).  
TCP å®ç°å¿…é¡»å‡†å¤‡å¥½å¤„ç†éæ³•é€‰é¡¹é•¿åº¦ï¼ˆä¾‹å¦‚ï¼Œ0ï¼‰ï¼Œå»ºè®®çš„å¤„ç†æ˜¯é‡ç½®è¿æ¥å¹¶è®°å½•é”™è¯¯åŸå›  (MUST-7)ã€‚

Note: There is ongoing work to extend the space available for TCP Options, such as [65].  
æ³¨æ„ï¼šç›®å‰æ­£åœ¨è¿›è¡Œæ‰©å±• TCP é€‰é¡¹å¯ç”¨ç©ºé—´çš„å·¥ä½œï¼Œä¾‹å¦‚ [65]ã€‚

{{< /block-indent >}}

**Data**: variable length

{{< block-indent >}}
User data carried by the TCP segment.  
TCP æ®µä¸­æºå¸¦çš„ç”¨æˆ·æ•°æ®ã€‚
{{< /block-indent >}}

### å…·ä½“çš„é€‰é¡¹å®šä¹‰

**3.2. Specific Option Definitions**

A TCP Option, in the mandatory option set, is one of an End of Option List Option, a No-Operation Option, or a Maximum Segment Size Option.
TCP é€‰é¡¹ï¼Œåœ¨å¼ºåˆ¶æ€§é€‰é¡¹åˆ—è¡¨ä¸­ï¼Œæ˜¯é€‰é¡¹åˆ—è¡¨ç»“æŸé€‰é¡¹ã€æ— æ“ä½œé€‰é¡¹æˆ–æœ€å¤§æ®µå¤§å°é€‰é¡¹ä¸­çš„ä¸€ä¸ªã€‚

An End of Option List Option is formatted as follows:  
é€‰é¡¹åˆ—è¡¨ç»“æŸé€‰é¡¹çš„æ ¼å¼å¦‚ä¸‹ï¼š

```
 0
 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+
|       0       |
+-+-+-+-+-+-+-+-+
```

where:  
å…¶ä¸­ï¼š

Kind: 1 byte; Kind == 0.

This option code indicates the end of the option list.  
è¯¥é€‰é¡¹ä»£ç è¡¨ç¤ºé€‰é¡¹åˆ—è¡¨çš„ç»“å°¾ã€‚

This might not coincide with the end of the TCP header according to the Data Offset field.  
æ ¹æ®æ•°æ®åç§»å­—æ®µï¼Œè¿™å¯èƒ½ä¸ TCP å¤´éƒ¨çš„ç»“å°¾ä¸ä¸€è‡´ã€‚

This is used at the end of all options, not the end of each option, and need only be used if the end of the options would not otherwise coincide with the end of the TCP header.  
è¿™ç”¨äºæ‰€æœ‰é€‰é¡¹çš„æœ«å°¾ï¼Œè€Œä¸æ˜¯æ¯ä¸ªé€‰é¡¹çš„æœ«å°¾ï¼Œå¹¶ä¸”ä»…åœ¨é€‰é¡¹æœ«å°¾ä¸ TCP æ ‡å¤´æœ«å°¾ä¸ä¸€è‡´æ—¶æ‰éœ€è¦ä½¿ç”¨ã€‚

A No-Operation Option is formatted as follows:  
æ— æ“ä½œé€‰é¡¹çš„æ ¼å¼å¦‚ä¸‹ï¼š

```
 0
 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+
|       1       |
+-+-+-+-+-+-+-+-+
```

where:  
å…¶ä¸­ï¼š

Kind: 1 byte; Kind == 1.

This option code can be used between options, for example, to align the beginning of a subsequent option on a word boundary.  
è¯¥é€‰é¡¹ä»£ç å¯ç”¨äºé€‰é¡¹ä¹‹é—´ï¼Œä¾‹å¦‚ï¼Œå°†åç»­é€‰é¡¹çš„å¼€å¤´å¯¹é½åˆ°å­—è¾¹ç•Œä¸Šã€‚

There is no guarantee that senders will use this option, so receivers MUST be prepared to process options even if they do not begin on a word boundary (MUST-64).  
ä¸èƒ½ä¿è¯å‘é€æ–¹ä¼šä½¿ç”¨è¿™ä¸ªé€‰é¡¹ï¼Œå› æ­¤æ¥æ”¶æ–¹å¿…é¡»å‡†å¤‡å¥½å¤„ç†é€‰é¡¹ï¼Œå³ä½¿å®ƒä»¬ä¸æ˜¯ä»å­—è¾¹ç•Œå¼€å§‹çš„ï¼ˆMUST-64ï¼‰ã€‚

A Maximum Segment Size Option is formatted as follows:  
æœ€å¤§æ®µå¤§å°é€‰é¡¹çš„æ ¼å¼å¦‚ä¸‹ï¼š

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       2       |     Length    |   Maximum Segment Size (MSS)  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

where:  
å…¶ä¸­ï¼š

Kind: 1 byte; Kind == 2.

If this option is present, then it communicates the maximum receive segment size at the TCP endpoint that sends this segment.  
å¦‚æœå­˜åœ¨æ­¤é€‰é¡¹ï¼Œåˆ™å®ƒä¼šåœ¨å‘é€æ­¤æ®µçš„ TCP ç«¯ä¼ è¾¾æœ€å¤§æ¥æ”¶æ®µå¤§å°ã€‚

This value is limited by the IP reassembly limit.  
è¯¥å€¼å— IP é‡ç»„é™åˆ¶ã€‚

This field may be sent in the initial connection request (i.e., in segments with the SYN control bit set) and MUST NOT be sent in other segments (MUST-65).  
è¯¥å­—æ®µå¯ä»¥åœ¨åˆå§‹è¿æ¥è¯·æ±‚ä¸­å‘é€ï¼ˆå³ï¼Œåœ¨è®¾ç½®äº† SYN æ§åˆ¶ä½çš„æ®µä¸­ï¼‰å¹¶ä¸”ä¸å¾—åœ¨å…¶ä»–æ®µä¸­å‘é€ï¼ˆMUST-65ï¼‰ã€‚

If this option is not used, any segment size is allowed.  
å¦‚æœä¸ä½¿ç”¨æ­¤é€‰é¡¹ï¼Œåˆ™å…è®¸ä»»ä½•æ®µå¤§å°ã€‚

A more complete description of this option is provided in Section 3.7.1.  
ç¬¬ 3.7.1 èŠ‚æä¾›äº†æ­¤é€‰é¡¹çš„æ›´å®Œæ•´æè¿°ã€‚

Length: 1 byte; Length == 4.

Length of the option in bytes.  
é€‰é¡¹çš„é•¿åº¦ï¼ˆä»¥å­—èŠ‚ä¸ºå•ä½ï¼‰ã€‚

Maximum Segment Size (MSS): 2 bytes.

The maximum receive segment size at the TCP endpoint that sends this segment.  
å‘é€è¯¥æ®µçš„ TCP ç«¯çš„æœ€å¤§æ¥æ”¶æ®µå¤§å°ã€‚

#### å…¶ä»–å¸¸ç”¨é€‰é¡¹

**3.2.1. Other Common Options**

Additional RFCs define some other commonly used options that are recommended to implement for high performance but are not necessary for basic TCP interoperability.  
å…¶ä»– RFC å®šä¹‰äº†ä¸€äº›å…¶ä»–å»ºè®®ä¸ºå®ç°é«˜æ€§èƒ½è€Œå®ç°çš„å¸¸ç”¨é€‰é¡¹ï¼Œä½†å¯¹äºåŸºæœ¬ TCP äº’æ“ä½œæ€§è€Œè¨€ä¸æ˜¯å¿…éœ€çš„ã€‚

These are the TCP Selective Acknowledgment (SACK) Option [22] [26], TCP Timestamp (TS) Option [47], and TCP Window Scale (WS) Option [47].  
è¿™äº›æ˜¯ TCP é€‰æ‹©æ€§ç¡®è®¤ (SACK) é€‰é¡¹ [22] [26]ã€TCP æ—¶é—´æˆ³ (TS) é€‰é¡¹ [47] å’Œ TCP çª—å£æ¯”ä¾‹ (WS) é€‰é¡¹ [47]ã€‚

#### å®éªŒæ€§ TCP é€‰é¡¹

**3.2.2. Experimental TCP Options**

Experimental TCP Option values are defined in [30], and [45] describes the current recommended usage for these experimental values.  
å®éªŒæ€§ TCP é€‰é¡¹å€¼åœ¨ [30] ä¸­å®šä¹‰ï¼Œ[45] æè¿°äº†è¿™äº›å®éªŒå€¼çš„å½“å‰æ¨èç”¨æ³•ã€‚

### æœ¯è¯­æ¦‚è¿°

**3.3. TCP Terminology Overview**

This section includes an overview of key terms needed to understand the detailed protocol operation in the rest of the document.  
æœ¬èŠ‚æ¦‚è¿°äº†ç†è§£æ–‡æ¡£å…¶ä½™éƒ¨åˆ†è¯¦ç»†åè®®æ“ä½œæ‰€éœ€çš„å…³é”®æœ¯è¯­ã€‚

There is a glossary of terms in Section 4.  
ç¬¬ 4 èŠ‚ä¸­æœ‰æœ¯è¯­è¡¨ã€‚

#### å…³é”®è¿æ¥çŠ¶æ€å˜é‡

**3.3.1. Key Connection State Variables**

Before we can discuss the operation of the TCP implementation in detail, we need to introduce some detailed terminology.  
åœ¨æˆ‘ä»¬è¯¦ç»†è®¨è®º TCP å®ç°çš„æ“ä½œä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦ä»‹ç»ä¸€äº›è¯¦ç»†çš„æœ¯è¯­ã€‚

The maintenance of a TCP connection requires maintaining state for several variables.  
TCP è¿æ¥çš„ç»´æŠ¤éœ€è¦ç»´æŠ¤å¤šä¸ªå˜é‡çš„çŠ¶æ€ã€‚

We conceive of these variables being stored in a connection record called a Transmission Control Block or TCB.  
æˆ‘ä»¬è®¾æƒ³å°†è¿™äº›å˜é‡å­˜å‚¨åœ¨ç§°ä¸ºä¼ è¾“æ§åˆ¶å—æˆ– TCB çš„è¿æ¥è®°å½•ä¸­ã€‚

Among the variables stored in the TCB are the local and remote IP addresses and port numbers, the IP security level, and compartment of the connection (see Appendix A.1), pointers to the user's send and receive buffers, pointers to the retransmit queue and to the current segment.  
å­˜å‚¨åœ¨ TCB ä¸­çš„å˜é‡åŒ…æ‹¬æœ¬åœ°å’Œè¿œç¨‹ IP åœ°å€å’Œç«¯å£å·ã€IP å®‰å…¨çº§åˆ«å’Œè¿æ¥åŒºæ®µï¼ˆå‚è§é™„å½• A.1ï¼‰ã€æŒ‡å‘ç”¨æˆ·å‘é€å’Œæ¥æ”¶ç¼“å†²åŒºçš„æŒ‡é’ˆã€æŒ‡å‘é‡ä¼ é˜Ÿåˆ—çš„æŒ‡é’ˆå’Œå½“å‰æ®µã€‚

In addition, several variables relating to the send and receive sequence numbers are stored in the TCB.  
æ­¤å¤–ï¼Œå‡ ä¸ªä¸å‘é€å’Œæ¥æ”¶åºåˆ—å·ç›¸å…³çš„å˜é‡å­˜å‚¨åœ¨ TCB ä¸­ã€‚

{{< center >}}

```
+==========+=====================================================+
| Variable | Description                                         |
+==========+=====================================================+
| SND.UNA  | send unacknowledged                                 |
+----------+-----------------------------------------------------+
| SND.NXT  | send next                                           |
+----------+-----------------------------------------------------+
| SND.WND  | send window                                         |
+----------+-----------------------------------------------------+
| SND.UP   | send urgent pointer                                 |
+----------+-----------------------------------------------------+
| SND.WL1  | segment sequence number used for last window update |
+----------+-----------------------------------------------------+
| SND.WL2  | segment acknowledgment number used for last window  |
|          | update                                              |
+----------+-----------------------------------------------------+
| ISS      | initial send sequence number                        |
+----------+-----------------------------------------------------+
```

Table 2: Send Sequence Variables  
è¡¨ 2: å‘é€åºåˆ—å˜é‡

```
+==========+=================================+
| Variable | Description                     |
+==========+=================================+
| RCV.NXT  | receive next                    |
+----------+---------------------------------+
| RCV.WND  | receive window                  |
+----------+---------------------------------+
| RCV.UP   | receive urgent pointer          |
+----------+---------------------------------+
| IRS      | initial receive sequence number |
+----------+---------------------------------+
```

Table 3: Receive Sequence Variables  
è¡¨ 3: æ¥æ”¶åºåˆ—å˜é‡
{{< /center >}}

The following diagrams may help to relate some of these variables to the sequence space.  
ä¸‹å›¾å¯èƒ½æœ‰åŠ©äºå°†å…¶ä¸­ä¸€äº›å˜é‡ä¸åºåˆ—ç©ºé—´è”ç³»èµ·æ¥ã€‚

{{< center >}}

```
    1         2          3          4
----------|----------|----------|----------
SND.UNA    SND.NXT    SND.UNA
                     +SND.WND

1 - old sequence numbers which have been acknowledged
2 - sequence numbers of unacknowledged data
3 - sequence numbers allowed for new data transmission
4 - future sequence numbers which are not yet allowed
```

Figure 3: Send Sequence Space  
å›¾ 3ï¼šå‘é€åºåˆ—å˜é‡

{{< /center >}}

The send window is the portion of the sequence space labeled 3 in figure 3.  
å‘é€çª—å£æ˜¯å›¾ 3 ä¸­æ ‡è®°ä¸º 3 çš„åºåˆ—ç©ºé—´çš„ä¸€éƒ¨åˆ†ã€‚

{{< center >}}

```
  1          2          3
----------|----------|----------
RCV.NXT    RCV.NXT
          +RCV.WND

1 - old sequence numbers which have been acknowledged
2 - sequence numbers allowed for new reception
3 - future sequence numbers which are not yet allowed
```

Figure 4: Receive Sequence Space  
å›¾ 4ï¼šæ¥æ”¶åºåˆ—å˜é‡

{{< /center >}}

The receive window is the portion of the sequence space labeled 2 in figure 4.  
æ¥æ”¶çª—å£æ˜¯å›¾ 4 ä¸­æ ‡è®°ä¸º 2 çš„åºåˆ—ç©ºé—´çš„ä¸€éƒ¨åˆ†ã€‚

There are also some variables used frequently in the discussion that take their values from the fields of the current segment.  
è¿˜æœ‰ä¸€äº›åœ¨è®¨è®ºä¸­ç»å¸¸ä½¿ç”¨çš„å˜é‡ï¼Œå®ƒä»¬çš„å€¼æ¥è‡ªå½“å‰æ®µçš„å­—æ®µã€‚

{{< center >}}

```
+==========+===============================+
| Variable | Description                   |
+==========+===============================+
| SEG.SEQ  | segment sequence number       |
+----------+-------------------------------+
| SEG.ACK  | segment acknowledgment number |
+----------+-------------------------------+
| SEG.LEN  | segment length                |
+----------+-------------------------------+
| SEG.WND  | segment window                |
+----------+-------------------------------+
| SEG.UP   | segment urgent pointer        |
+----------+-------------------------------+
```

Table 4: Current Segment Variables  
è¡¨ 4ï¼šå½“å‰æ®µå˜é‡

{{< /center >}}

#### çŠ¶æ€æœºæ¦‚è¿°

**3.3.2. State Machine Overview**

A connection progresses through a series of states during its lifetime.  
ä¸€ä¸ªè¿æ¥åœ¨å…¶ç”Ÿå‘½å‘¨æœŸä¸­ä¼šç»å†ä¸€ç³»åˆ—çš„çŠ¶æ€ã€‚

The states are: LISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT, and the fictional state CLOSED.  
è¿™äº›çŠ¶æ€æ˜¯ï¼šLISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT ä»¥åŠè™šæ„çš„çŠ¶æ€ CLOSEDã€‚

CLOSED is fictional because it represents the state when there is no TCB, and therefore, no connection.  
CLOSED æ˜¯è™šæ„çš„ï¼Œå› ä¸ºå®ƒä»£è¡¨äº†æ²¡æœ‰ TCB çš„çŠ¶æ€ï¼Œä¹Ÿå°±æ˜¯æ²¡æœ‰è¿æ¥ã€‚

Briefly the meanings of the states are:  
ç®€è€Œè¨€ä¹‹ï¼Œè¿™äº›çŠ¶æ€çš„å«ä¹‰æ˜¯ï¼š

**LISTEN** - represents waiting for a connection request from any remote TCP peer and port.  
**LISTEN** - è¡¨ç¤ºç­‰å¾…æ¥è‡ªä»»ä½•è¿œç¨‹å¯¹ç­‰ TCP å’Œç«¯å£çš„è¿æ¥è¯·æ±‚ã€‚

**SYN-SENT** - represents waiting for a matching connection request after having sent a connection request.  
**SYN-SENT** - è¡¨ç¤ºåœ¨å‘é€äº†ä¸€ä¸ªè¿æ¥è¯·æ±‚åç­‰å¾…ä¸€ä¸ªåŒ¹é…çš„è¿æ¥è¯·æ±‚ã€‚

**SYN-RECEIVED** - represents waiting for a confirming connection request acknowledgment after having both received and sent a connection request.  
**SYN-RECEIVED** - è¡¨ç¤ºåœ¨æ”¶åˆ°å’Œå‘é€è¿æ¥è¯·æ±‚åï¼Œç­‰å¾…ç¡®è®¤è¿æ¥è¯·æ±‚çš„ç¡®è®¤ã€‚

**ESTABLISHED** - represents an open connection, data received can be delivered to the user. The normal state for the data transfer phase of the connection.  
**ESTABLISHED** - ä»£è¡¨ä¸€ä¸ªå·²å»ºç«‹çš„è¿æ¥ï¼Œæ”¶åˆ°çš„æ•°æ®å¯ä»¥ä¼ é€’ç»™ç”¨æˆ·ï¼Œæ˜¯è¿æ¥æ•°æ®ä¼ è¾“é˜¶æ®µçš„æ­£å¸¸çŠ¶æ€ã€‚

**FIN-WAIT-1** - represents waiting for a connection termination request from the remote TCP peer, or an acknowledgment of the connection termination request previously sent.  
**FIN-WAIT-1** - è¡¨ç¤ºç­‰å¾…æ¥è‡ªè¿œç¨‹å¯¹ç­‰ TCP çš„è¿æ¥ç»ˆæ­¢è¯·æ±‚ï¼Œæˆ–ç­‰å¾…ä¹‹å‰å‘é€çš„ç»ˆæ­¢è¿æ¥è¯·æ±‚çš„ç¡®è®¤ã€‚

**FIN-WAIT-2** - represents waiting for a connection termination request from the remote TCP peer.  
**FIN-WAIT-2** - è¡¨ç¤ºç­‰å¾…æ¥è‡ªè¿œç¨‹å¯¹ç­‰ TCP çš„è¿æ¥ç»ˆæ­¢è¯·æ±‚ã€‚

**CLOSE-WAIT** - represents waiting for a connection termination request from the local user.  
**CLOSE-WAIT** - è¡¨ç¤ºç­‰å¾…æœ¬ç«¯ç”¨æˆ·çš„è¿æ¥ç»ˆæ­¢è¯·æ±‚ã€‚

**CLOSING** - represents waiting for a connection termination request acknowledgment from the remote TCP peer.  
**CLOSING** - è¡¨ç¤ºç­‰å¾…æ¥è‡ªè¿œç¨‹å¯¹ç­‰ TCP çš„è¿æ¥ç»ˆæ­¢è¯·æ±‚ç¡®è®¤ã€‚

**LAST-ACK** - represents waiting for an acknowledgment of the connection termination request previously sent to the remote TCP peer(this termination request sent to the remote TCP peer already included an acknowledgment of the termination request sent from the remote TCP peer).
**LAST-ACK** - è¡¨ç¤ºç­‰å¾…å¯¹å…ˆå‰å‘é€åˆ°è¿œç¨‹å¯¹ç­‰ TCP çš„è¿æ¥ç»ˆæ­¢è¯·æ±‚çš„ç¡®è®¤ï¼ˆå‘é€ç»™è¿œç¨‹å¯¹ç­‰ TCP çš„è¿™ä¸ªç»ˆæ­¢è¯·æ±‚å·²ç»åŒ…æ‹¬äº†è¿œç¨‹å¯¹ç­‰ TCP å‘é€çš„ç»ˆæ­¢è¯·æ±‚çš„ç¡®è®¤ï¼‰ã€‚

**TIME-WAIT** - represents waiting for enough time to pass to be sure the remote TCP peer received the acknowledgment of its connection termination request and to avoid new connections being impacted by delayed segments from previous connections.  
**TIME-WAIT** - è¡¨ç¤ºç­‰å¾…è¶³å¤Ÿçš„æ—¶é—´é€šè¿‡ä»¥ç¡®ä¿è¿œç¨‹å¯¹ç­‰ TCP æ”¶åˆ°å…¶è¿æ¥ç»ˆæ­¢è¯·æ±‚çš„ç¡®è®¤ï¼Œå¹¶é¿å…æ–°è¿æ¥å—åˆ°å…ˆå‰è¿æ¥çš„å»¶è¿Ÿæ®µçš„å½±å“ã€‚

**CLOSED** - represents no connection state at all.  
**CLOSED** - è¡¨ç¤ºæ²¡æœ‰è¿æ¥çš„çŠ¶æ€ã€‚

A TCP connection progresses from one state to another in response to events.  
TCP è¿æ¥æ ¹æ®äº‹ä»¶ä»ä¸€ä¸ªçŠ¶æ€è½¬æ¢åˆ°å¦ä¸€ä¸ªçŠ¶æ€ã€‚

The events are the user calls, OPEN, SEND, RECEIVE, CLOSE, ABORT, and STATUS; the incoming segments, particularly those containing the SYN and FIN flags; and timeouts.  
è¿™äº›äº‹ä»¶æ˜¯ç”¨æˆ·è°ƒç”¨ OPENã€SENDã€RECEIVEã€CLOSEã€ABORT å’Œ STATUSï¼›æ”¶åˆ° TCP æ®µï¼Œç‰¹åˆ«æ˜¯åŒ…å« SYN å’Œ FIN æ ‡å¿—çš„æ®µï¼›ä»¥åŠè¶…æ—¶ã€‚

The OPEN call specifies whether connection establishment is to be actively pursued, or to be passively waited for.  
OPEN è°ƒç”¨æŒ‡å®šæ˜¯ä¸»åŠ¨è¦æ±‚è¿æ¥å»ºç«‹ï¼Œè¿˜æ˜¯è¢«åŠ¨ç­‰å¾…ã€‚

A passive OPEN request means that the process wants to accept incoming connection requests, in contrast to an active OPEN attempting to initiate a connection.  
è¢«åŠ¨ OPEN è¯·æ±‚æ„å‘³ç€è¿›ç¨‹æƒ³è¦æ¥å—ä¼ å…¥çš„è¿æ¥è¯·æ±‚ï¼Œè¿™ä¸ä¸»åŠ¨ OPEN å°è¯•å¯åŠ¨è¿æ¥ç›¸åã€‚

The state diagram in Figure 5 illustrates only state changes, together with the causing events and resulting actions, but addresses neither error conditions nor actions that are not connected with state changes.  
å›¾ 5 ä¸­çš„çŠ¶æ€å›¾åªè¯´æ˜äº†çŠ¶æ€çš„å˜åŒ–ï¼Œä»¥åŠå¼•èµ·çš„äº‹ä»¶å’Œè§¦å‘çš„è¡Œä¸ºï¼Œä½†æ—¢æ²¡æœ‰æ¶‰åŠé”™è¯¯æ¡ä»¶ï¼Œä¹Ÿæ²¡æœ‰æ¶‰åŠä¸çŠ¶æ€å˜åŒ–æ— å…³çš„è¡Œä¸ºã€‚

In a later section, more detail is offered with respect to the reaction of the TCP implementation to events.  
åœ¨åé¢çš„ç« èŠ‚ä¸­ï¼Œå°†æä¾›å…³äº TCP å¯¹äº‹ä»¶å“åº”çš„æ›´å¤šç»†èŠ‚ã€‚

Some state names are abbreviated or hyphenated differently in the diagram from how they appear elsewhere in the document.

NOTA BENE: This diagram is only a summary and must not be taken as the total specification. Many details are not included.  
æ³¨æ„ï¼šæ­¤å›¾åªæ˜¯ä¸€ä¸ªæ‘˜è¦ï¼Œä¸èƒ½ä½œä¸ºå…¨éƒ¨è§„èŒƒï¼Œè®¸å¤šç»†èŠ‚æœªåŒ…æ‹¬åœ¨å†…ã€‚

```
                               +---------+ ---------\      active OPEN
                               |  CLOSED |            \    -----------
                               +---------+<---------\   \   create TCB
                                 |     ^              \   \  snd SYN
                    passive OPEN |     |   CLOSE        \   \
                    ------------ |     | ----------       \   \
                     create TCB  |     | delete TCB         \   \
                                 V     |                      \   \
             rcv RST (note 1)  +---------+            CLOSE    |    \
          -------------------->|  LISTEN |          ---------- |     |
         /                     +---------+          delete TCB |     |
        /           rcv SYN      |     |     SEND              |     |
       /           -----------   |     |    -------            |     V
   +--------+      snd SYN,ACK  /       \   snd SYN          +--------+
   |        |<-----------------           ------------------>|        |
   |  SYN   |                    rcv SYN                     |  SYN   |
   |  RCVD  |<-----------------------------------------------|  SENT  |
   |        |                  snd SYN,ACK                   |        |
   |        |------------------           -------------------|        |
   +--------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +--------+
      |         --------------   |     |   -----------
      |                x         |     |     snd ACK
      |                          V     V
      |  CLOSE                 +---------+
      | -------                |  ESTAB  |
      | snd FIN                +---------+
      |                 CLOSE    |     |    rcv FIN
      V                -------   |     |    -------
   +---------+         snd FIN  /       \   snd ACK         +---------+
   |  FIN    |<----------------          ------------------>|  CLOSE  |
   | WAIT-1  |------------------                            |   WAIT  |
   +---------+          rcv FIN  \                          +---------+
     | rcv ACK of FIN   -------   |                          CLOSE  |
     | --------------   snd ACK   |                         ------- |
     V        x                   V                         snd FIN V
   +---------+               +---------+                    +---------+
   |FINWAIT-2|               | CLOSING |                    | LAST-ACK|
   +---------+               +---------+                    +---------+
     |              rcv ACK of FIN |                 rcv ACK of FIN |
     |  rcv FIN     -------------- |    Timeout=2MSL -------------- |
     |  -------            x       V    ------------        x       V
      \ snd ACK              +---------+delete TCB          +---------+
        -------------------->|TIME-WAIT|------------------->| CLOSED  |
                             +---------+                    +---------+
```

{{< center >}}
Figure 5: TCP Connection State Diagram  
å›¾ 5ï¼šTCP è¿æ¥çŠ¶æ€å›¾
{{< /center >}}

The following notes apply to Figure 5:  
ä»¥ä¸‹æ³¨é‡Šé€‚ç”¨äºå›¾ 5ï¼š

- Note 1: The transition from SYN-RECEIVED to LISTEN on receiving a RST is conditional on having reached SYN-RECEIVED after a passive OPEN.  
  åœ¨æ¥æ”¶åˆ° RST æ—¶ä» SYN-RECEIVED åˆ° LISTEN çš„è½¬æ¢ä»¥åœ¨è¢«åŠ¨ OPEN ä¹‹åè¾¾åˆ° SYN-RECEIVED ä¸ºæ¡ä»¶ã€‚

- Note 2: The figure omits a transition from FIN-WAIT-1 to TIME-WAIT if a FIN is received and the local FIN is also acknowledged.  
  å¦‚æœæ”¶åˆ° FIN å¹¶ä¸”æœ¬åœ° FIN ä¹Ÿå¾—åˆ°ç¡®è®¤ï¼Œåˆ™å›¾ä¸­çœç•¥äº†ä» FIN-WAIT-1 åˆ° TIME-WAIT çš„è½¬æ¢ã€‚

- Note 3: A RST can be sent from any state with a corresponding transition to TIME-WAIT (see [70] for rationale).  
  RST å¯ä»¥ä»ä»»ä½•çŠ¶æ€å‘é€ï¼Œå¹¶ç›¸åº”åœ°è½¬æ¢ä¸º TIME-WAITï¼ˆåŸºæœ¬åŸç†å‚è§ [70]ï¼‰ã€‚

  These transitions are not explicitly shown; otherwise, the diagram would become very difficult to read.  
  è¿™äº›è½¬æ¢æ²¡æœ‰æ˜ç¡®æ˜¾ç¤ºï¼›å¦åˆ™ï¼Œå›¾è¡¨å°†å˜å¾—å¾ˆéš¾é˜…è¯»ã€‚

  Similarly, receipt of a RST from any state results in a transition to LISTEN or CLOSED, though this is also omitted from the diagram for legibility.  
  ç±»ä¼¼åœ°ï¼Œä»ä»»ä½•çŠ¶æ€æ¥æ”¶åˆ° RST éƒ½ä¼šå¯¼è‡´è½¬æ¢ä¸º LISTEN æˆ– CLOSEDï¼Œå°½ç®¡ä¸ºäº†ä¾¿äºé˜…è¯»ï¼Œå›¾ä¸­ä¹Ÿçœç•¥äº†è¿™ä¸€ç‚¹ã€‚

### åºåˆ—å·

**3.4. Sequence Numbers**

A fundamental notion in the design is that every octet of data sent over a TCP connection has a sequence number.  
TCP è®¾è®¡ä¸­çš„ä¸€ä¸ªåŸºæœ¬æ¦‚å¿µæ˜¯ï¼Œé€šè¿‡ TCP è¿æ¥å‘é€çš„æ¯ä¸ªå­—èŠ‚çš„æ•°æ®éƒ½æœ‰ä¸€ä¸ªåºåˆ—å·ã€‚

Since every octet is sequenced, each of them can be acknowledged.  
ç”±äºæ¯ä¸ªå­—èŠ‚éƒ½æ˜¯æœ‰é¡ºåºçš„ï¼Œæ‰€ä»¥æ¯ä¸ªå­—èŠ‚éƒ½å¯ä»¥è¢«ç¡®è®¤ã€‚

The acknowledgment mechanism employed is cumulative so that an acknowledgment of sequence number X indicates that all octets up to but not including X have been received.  
TCP æ‰€é‡‡ç”¨çš„ç¡®è®¤æœºåˆ¶æ˜¯ç´¯ç§¯æ€§çš„ï¼Œå› æ­¤åºåˆ—å·ä¸º X çš„ç¡®è®¤è¡¨ç¤ºå·²ç»æ”¶åˆ°äº†ä¹‹å‰ä½†ä¸åŒ…æ‹¬ X çš„æ‰€æœ‰å­—èŠ‚ã€‚

This mechanism allows for straightforward duplicate detection in the presence of retransmission.  
è¿™ç§æœºåˆ¶ä½¿å¾—åœ¨å­˜åœ¨é‡ä¼ çš„æƒ…å†µä¸‹å¯ä»¥ç›´æ¥è¿›è¡Œé‡å¤æ£€æµ‹ã€‚

The numbering scheme of octets within a segment is as follows: the first data octet immediately following the header is the lowest numbered, and the following octets are numbered consecutively.  
æ®µå†…å­—èŠ‚çš„ç¼–å·æ–¹æ¡ˆå¦‚ä¸‹ï¼šç´§è·Ÿåœ¨å¤´éƒ¨ä¹‹åçš„ç¬¬ä¸€ä¸ªå­—èŠ‚æ•°æ®ç¼–å·æœ€å°ï¼Œéšåçš„å­—èŠ‚è¿ç»­ç¼–å·ã€‚

It is essential to remember that the actual sequence number space is finite, though large.  
éœ€è¦è®°ä½ï¼Œå®é™…çš„åºåˆ—å·èŒƒå›´æ˜¯æœ‰é™çš„ï¼Œå°½ç®¡å¾ˆå¤§ã€‚

This space ranges from 0 to 2\*\*32 - 1.  
è¿™ä¸ªèŒƒå›´æ˜¯ä» 0 åˆ° 2\*\*32-1 ã€‚

Since the space is finite, all arithmetic dealing with sequence numbers must be performed modulo 2\*\*32.  
ç”±äºèŒƒå›´æ˜¯æœ‰é™çš„ï¼Œæ‰€æœ‰å¤„ç†åºåˆ—å·çš„è¿ç®—éƒ½å¿…é¡»æ¨¡ 2\*\*32ã€‚

This unsigned arithmetic preserves the relationship of sequence numbers as they cycle from 2\*\*32 - 1 to 0 again.  
è¿™ç§æ— ç¬¦å·ç®—æœ¯ä¿ç•™äº†åºåˆ—å·ä¹‹é—´çš„å…³ç³»ï¼Œå› ä¸ºå®ƒä»¬ä» 2\*\*32-1 å†é‡æ–°åˆ° 0ã€‚

There are some subtleties to computer modulo arithmetic, so great care should be taken in programming the comparison of such values.  
è®¡ç®—æœºæ¨¡è¿ç®—æœ‰ä¸€äº›ç»†å¾®çš„å·®å¼‚ï¼Œæ‰€ä»¥åœ¨ç¼–ç¨‹æ¯”è¾ƒè¿™äº›å€¼æ—¶åº”è¯¥éå¸¸å°å¿ƒã€‚

The symbol "=<" means "less than or equal" (modulo 2\*\*32).  
ç¬¦å· "=<" è¡¨ç¤º "å°äºæˆ–ç­‰äº" (æ¨¡ 2\*\*32)ã€‚

The typical kinds of sequence number comparisons that the TCP implementation must perform include:  
TCP å®ç°ä¸­éœ€è¦æ“ä½œçš„å…¸å‹çš„åºåˆ—å·æ¯”è¾ƒåŒ…æ‹¬ï¼š

(a) Determining that an acknowledgment refers to some sequence number sent but not yet acknowledged.  
(a) ç¡®å®šä¸€ä¸ªç¡®è®¤æ˜¯å¯¹åº”æŸä¸ªå·²å‘é€ä½†å°šæœªç¡®è®¤çš„åºåˆ—å·ã€‚

(b) Determining that all sequence numbers occupied by a segment have been acknowledged (e.g., to remove the segment from a retransmission queue).  
(b) ç¡®å®š TCP æ®µæ‰€å ç”¨çš„æ‰€æœ‰åºåˆ—å·éƒ½å·²è¢«ç¡®è®¤ï¼ˆä¾‹å¦‚ï¼Œä»é‡ä¼ é˜Ÿåˆ—ä¸­åˆ é™¤è¯¥ TCP æ®µï¼‰ã€‚

(c) Determining that an incoming segment contains sequence numbers which are expected (i.e., that the segment "overlaps" the receive window).  
(c) ç¡®å®šä¸€ä¸ªæ”¶åˆ°çš„ TCP æ®µåŒ…å«é¢„æœŸçš„åºåˆ—å·ï¼ˆå³è¯¥ TCP æ®µä¸æ¥æ”¶çª—å£"é‡å "ï¼‰ã€‚

In response to sending data, the TCP endpoint will receive acknowledgments.  
TCP å°†æ”¶åˆ°ç¡®è®¤ä½œä¸ºå¯¹å‘é€æ•°æ®çš„å“åº”ã€‚

The following comparisons are needed to process the acknowledgments.  
åœ¨å¤„ç†ç¡®è®¤æ—¶éœ€è¦è¿›è¡Œä»¥ä¸‹æ¯”è¾ƒã€‚

SND.UNA = oldest unacknowledged sequence number  
SND.UNA = æœ€æ—©çš„æœªç¡®è®¤çš„åºåˆ—å·

SND.NXT = next sequence number to be sent  
SND.NXT = ä¸‹ä¸€ä¸ªè¦å‘é€çš„åºåˆ—å·

SEG.ACK = acknowledgment from the receiving TCP peer (next sequence number expected by the receiving TCP)  
SEG.ACK = æ¥è‡ªæ¥æ”¶ TCP çš„ç¡®è®¤ï¼ˆæ¥æ”¶ TCP æ‰€æœŸæœ›çš„ä¸‹ä¸€ä¸ªåºåˆ—å·ï¼‰ã€‚

SEG.SEQ = first sequence number of a segment  
SEG.SEQ = TCP æ®µçš„ç¬¬ä¸€ä¸ªåºåˆ—å·

SEG.LEN = the number of octets occupied by the data in the segment (counting SYN and FIN)  
SEG.LEN = æ®µè½ä¸­çš„æ•°æ®æ‰€å çš„å­—èŠ‚æ•° (åŒ…æ‹¬ SYN å’Œ FIN)

SEG.SEQ+SEG.LEN-1 = last sequence number of a segment  
SEG.SEQ+SEG.LEN-1 = TCP æ®µçš„æœ€åä¸€ä¸ªåºåˆ—å·

A new acknowledgment (called an "acceptable ack"), is one for which the inequality below holds:  
ä¸€ä¸ªæ–°çš„ç¡®è®¤ï¼ˆå³ "å¯æ¥å—çš„ç¡®è®¤"ï¼‰ï¼Œä¼šæ»¡è¶³ä»¥ä¸‹ä¸ç­‰å¼ã€‚  
SND.UNA < SEG.ACK =< SND.NXT

A segment on the retransmission queue is fully acknowledged if the sum of its sequence number and length is less than the acknowledgment value in the incoming segment.  
å¦‚æœé‡ä¼ é˜Ÿåˆ—ä¸­çš„ä¸€ä¸ª TCP æ®µçš„åºåˆ—å·å’Œé•¿åº¦ä¹‹å’Œå°äºæ”¶åˆ°æ®µçš„ç¡®è®¤å€¼ï¼Œåˆ™è¯¥æ®µè¢«å®Œå…¨ç¡®è®¤ã€‚

When data is received the following comparisons are needed:  
å½“æ”¶åˆ°æ•°æ®æ—¶ï¼Œéœ€è¦è¿›è¡Œä»¥ä¸‹æ¯”è¾ƒï¼š

RCV.NXT = next sequence number expected on an incoming segments, and is the left or lower edge of the receive window  
RCV.NXT = ä¸‹ä¸€ä¸ªé¢„æœŸæ”¶åˆ° TCP æ®µçš„åºåˆ—å·ï¼Œä¹Ÿæ˜¯æ¥æ”¶çª—å£çš„å·¦è¾¹ç•Œæˆ–ä¸‹é™ã€‚

RCV.NXT+RCV.WND-1 = last sequence number expected on an incoming segment, and is the right or upper edge of the receive window  
RCV.NXT+RCV.WND-1 = æœ€åä¸€ä¸ªé¢„æœŸæ”¶åˆ° TCP æ®µçš„åºåˆ—å·ï¼Œä¹Ÿæ˜¯æ¥æ”¶çª—å£çš„å³è¾¹ç•Œæˆ–ä¸Šé™ã€‚

SEG.SEQ = first sequence number occupied by the incoming segment  
SEG.SEQ = æ”¶åˆ° TCP æ®µçš„ç¬¬ä¸€ä¸ªåºåˆ—å·

SEG.SEQ+SEG.LEN-1 = last sequence number occupied by the incoming segment  
SEG.SEQ+SEG.LEN-1 = æ”¶åˆ° TCP æ®µçš„æœ€åä¸€ä¸ªåºåˆ—å·

A segment is judged to occupy a portion of valid receive sequence space if  
åœ¨ä¸‹åˆ—æƒ…å†µä¸‹ï¼Œä¸€ä¸ª TCP æ®µè¢«åˆ¤æ–­ä¸ºå æ®äº†æœ‰æ•ˆæ¥æ”¶åºåˆ—èŒƒå›´çš„ä¸€éƒ¨åˆ†

RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND

or  
æˆ–

RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND

The first part of this test checks to see if the beginning of the segment falls in the window, the second part of the test checks to see if the end of the segment falls in the window; if the segment passes either part of the test it contains data in the window.  
è¯¥æµ‹è¯•çš„ç¬¬ä¸€éƒ¨åˆ†æ£€æŸ¥æ®µçš„å¼€å¤´æ˜¯å¦è½åœ¨çª—å£ä¸­ï¼Œæµ‹è¯•çš„ç¬¬äºŒéƒ¨åˆ†æ£€æŸ¥æ®µçš„ç»“å°¾æ˜¯å¦è½åœ¨çª—å£ä¸­ï¼›å¦‚æœè¯¥æ®µé€šè¿‡äº†æµ‹è¯•çš„ä»»ä½•ä¸€éƒ¨åˆ†ï¼Œåˆ™å®ƒåœ¨çª—å£ä¸­åŒ…å«æ•°æ®ã€‚

Actually, it is a little more complicated than this. Due to zero windows and zero-length segments, we have four cases for the acceptability of an incoming segment:  
å®é™…ä¸Šï¼Œæƒ…å†µæ¯”è¿™æ›´å¤æ‚ä¸€äº›ã€‚ç”±äºé›¶çª—å£å’Œé›¶é•¿åº¦çš„ TCP æ®µï¼Œæˆ‘ä»¬æœ‰å››ç§æƒ…å†µæ¥åˆ¤æ–­ä¸€ä¸ªæ”¶åˆ°çš„ TCP æ®µæ˜¯å¦å¯æ¥å—ï¼š

{{< center >}}

```
+=========+=========+======================================+
| Segment | Receive | Test                                 |
| Length  | Window  |                                      |
+=========+=========+======================================+
| 0       | 0       | SEG.SEQ = RCV.NXT                    |
+---------+---------+--------------------------------------+
| 0       | >0      | RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND |
+---------+---------+--------------------------------------+
| >0      | 0       | not acceptable                       |
+---------+---------+--------------------------------------+
| >0      | >0      | RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND |
|         |         |                                      |
|         |         | or                                   |
|         |         |                                      |
|         |         | RCV.NXT =< SEG.SEQ+SEG.LEN-1 <       |
|         |         | RCV.NXT+RCV.WND                      |
+---------+---------+--------------------------------------+
```

Table 5: Segment Acceptability Tests  
è¡¨ 5ï¼šæ®µå¯æ¥å—æ€§æµ‹è¯•
{{< /center >}}

Note that when the receive window is zero no segments should be acceptable except ACK segments.  
è¯·æ³¨æ„ï¼Œå½“æ¥æ”¶çª—å£ä¸ºé›¶æ—¶ï¼Œé™¤äº† ACK æ®µå¤–ï¼Œä¸åº”æ¥å—å…¶ä»– TCP æ®µã€‚

Thus, it is possible for a TCP implementation to maintain a zero receive window while transmitting data and receiving ACKs.  
å› æ­¤ï¼ŒTCP å®ç°åº”è¯¥æœ‰å¯èƒ½åœ¨ä¼ è¾“æ•°æ®å’Œæ¥æ”¶ ACK çš„åŒæ—¶ä¿æŒä¸€ä¸ªé›¶æ¥æ”¶çª—å£ã€‚

A TCP receiver MUST process the RST and URG fields of all incoming segments, even when the receive window is zero (MUST-66).
å³ä½¿æ¥æ”¶çª—å£ä¸ºé›¶ï¼ŒTCP ä¹Ÿå¿…é¡»å¤„ç†æ‰€æœ‰æ¥æ”¶æ®µçš„ RST å’Œ URG å­—æ®µ (MUST-66)ã€‚

We have taken advantage of the numbering scheme to protect certain control information as well.
æˆ‘ä»¬è¿˜åˆ©ç”¨äº†ç¼–å·æ–¹æ¡ˆæ¥ä¿æŠ¤æŸäº›æ§åˆ¶ä¿¡æ¯ã€‚

This is achieved by implicitly including some control flags in the sequence space so they can be retransmitted and acknowledged without confusion (i.e., one and only one copy of the control will be acted upon).  
è¿™æ˜¯é€šè¿‡åœ¨åºåˆ—ç©ºé—´ä¸­éšå«åœ°åŒ…æ‹¬ä¸€äº›æ§åˆ¶æ ‡å¿—æ¥å®ç°çš„ï¼Œä½¿å¾—å®ƒä»¬å¯ä»¥è¢«é‡å‘å’Œç¡®è®¤è€Œä¸ä¼šäº§ç”Ÿæ··æ·†(å³ï¼Œå°†å¯¹æ§åˆ¶çš„ä¸€ä¸ªä¸”ä»…ä¸€ä¸ªå‰¯æœ¬è¿›è¡Œæ“ä½œ)ã€‚

Control information is not physically carried in the segment data space.  
æ§åˆ¶ä¿¡æ¯ä¸å®é™…åœ¨ TCP æ®µæ•°æ®ç©ºé—´ä¸­æºå¸¦ã€‚

Consequently, we must adopt rules for implicitly assigning sequence numbers to control.
å› æ­¤ï¼Œæˆ‘ä»¬å¿…é¡»é‡‡ç”¨éšå¼åˆ†é…åºåˆ—å·çš„è§„åˆ™æ¥æ§åˆ¶ã€‚

The SYN and FIN are the only controls requiring this protection, and these controls are used only at connection opening and closing.  
SYN å’Œ FIN æ˜¯å”¯ä¸€éœ€è¦è¿™ç§ä¿æŠ¤çš„æ§åˆ¶ï¼Œè€Œä¸”è¿™äº›æ§åˆ¶åªåœ¨è¿æ¥æ‰“å¼€å’Œå…³é—­æ—¶ä½¿ç”¨ã€‚

For sequence number purposes, the SYN is considered to occur before the first actual data octet of the segment in which it occurs, while the FIN is considered to occur after the last actual data octet in a segment in which it occurs.  
å°±åºåˆ—å·è€Œè¨€ï¼ŒSYN è¢«è®¤ä¸ºå‘ç”Ÿåœ¨å…¶æ‰€åœ¨ TCP æ®µçš„å®é™…æ•°æ®ç¬¬ä¸€ä¸ªå­—èŠ‚ä¹‹å‰ï¼Œè€Œ FIN è¢«è®¤ä¸ºå‘ç”Ÿåœ¨å…¶æ‰€åœ¨æ®µçš„å®é™…æ•°æ®çš„æœ€åä¸€ä¸ªå­—èŠ‚ä¹‹åã€‚

The segment length (SEG.LEN) includes both data and sequence space-occupying controls.  
TCP æ®µçš„é•¿åº¦åŒ…æ‹¬æ•°æ®å’Œå ç”¨åºåˆ—ç©ºé—´çš„æ§åˆ¶ä¿¡æ¯ã€‚

When a SYN is present then SEG.SEQ is the sequence number of the SYN.  
å½“å­˜åœ¨ SYN æ—¶ï¼ŒSEG.SEQ æ˜¯ SYN çš„åºåˆ—å·ã€‚

#### åˆå§‹åºåˆ—å·çš„é€‰æ‹©

**3.4.1. Initial Sequence Number Selection**

A connection is defined by a pair of sockets. Connections can be reused.  
ä¸€ä¸ªè¿æ¥æ˜¯ç”±ä¸€å¯¹å¥—æ¥å­—ç¡®å®šçš„ï¼Œè¿æ¥å¯ä»¥é‡å¤ä½¿ç”¨ã€‚

New instances of a connection will be referred to as incarnations of the connection.  
è¿æ¥çš„æ–°å®ä¾‹ä¼šç”¨æ¥è¡¨ç¤ºè¿æ¥ã€‚

The problem that arises from this is -- "how does the TCP implementation identify duplicate segments from previous incarnations of the connection?"  
ç”±æ­¤äº§ç”Ÿçš„é—®é¢˜æ˜¯ -- "TCP å®ç°å¦‚ä½•è¯†åˆ«æ¥è‡ªä»¥å‰è¿æ¥ä¸­çš„é‡å¤æ®µï¼Ÿ"

This problem becomes apparent if the connection is being opened and closed in quick succession, or if the connection breaks with loss of memory and is then reestablished.  
å¦‚æœå¿«é€Ÿè¿ç»­åœ°æ‰“å¼€å’Œå…³é—­è¿æ¥ï¼Œæˆ–è€…å¦‚æœè¿æ¥å› å†…å­˜ä¸¢å¤±è€Œæ–­å¼€ï¼Œç„¶åé‡æ–°å»ºç«‹ï¼Œåˆ™æ­¤é—®é¢˜ä¼šå˜å¾—æ˜æ˜¾ã€‚

To support this, the TIME-WAIT state limits the rate of connection reuse, while the initial sequence number selection described below further protects against ambiguity about which incarnation of a connection an incoming packet corresponds to.  
ä¸ºäº†æ”¯æŒè¿™ä¸€ç‚¹ï¼ŒTIME-WAIT çŠ¶æ€é™åˆ¶äº†è¿æ¥é‡ç”¨çš„é€Ÿåº¦ï¼Œè€Œä¸‹é¢æè¿°çš„åˆå§‹åºåˆ—å·é€‰æ‹©è¿›ä¸€æ­¥é˜²æ­¢å…³äºæ¥æ”¶æ•°æ®åŒ…å¯¹åº”äºå“ªä¸ªè¿æ¥å®ä¾‹çš„æ­§ä¹‰ã€‚

To avoid confusion, we must prevent segments from one incarnation of a connection from being used while the same sequence numbers may still be present in the network from an earlier incarnation.  
ä¸ºäº†é˜²æ­¢å‡ºç°æ··ä¹±ï¼Œæˆ‘ä»¬å¿…é¡»é˜²æ­¢ä½¿ç”¨æ¥è‡ªå…ˆå‰è¿æ¥ä¸­æœ‰ç›¸åŒåºåˆ—å·çš„æ•°æ®æ®µã€‚

We want to assure this even if a TCP endpoint crashes and loses all knowledge of the sequence numbers it has been using.  
æˆ‘ä»¬è¦ä¿è¯è¿™ä¸€ç‚¹ï¼Œå³ä½¿ TCP å´©æºƒå¹¶å¤±å»äº†å®ƒä½¿ç”¨çš„åºåˆ—å·çš„æ‰€æœ‰ä¿¡æ¯ã€‚

When new connections are created, an initial sequence number (ISN) generator is employed which selects a new 32 bit ISN.  
å½“åˆ›å»ºæ–°è¿æ¥æ—¶ï¼Œä½¿ç”¨åˆå§‹åºåˆ—å·(ISN)ç”Ÿæˆå™¨é€‰æ‹©æ–°çš„ 32 ä½ ISNã€‚

There are security issues that result if an off-path attacker is able to predict or guess ISN values [42].  
å¦‚æœ off-path attacker èƒ½å¤Ÿé¢„æµ‹æˆ–çŒœæµ‹ ISN å€¼ï¼Œåˆ™ä¼šå‡ºç°å®‰å…¨é—®é¢˜ [42]ã€‚

TCP initial sequence numbers are generated from a number sequence that monotonically increases until it wraps, known loosely as a "clock".  
TCP åˆå§‹åºåˆ—å·æ˜¯ç”±ä¸€ä¸ªæ•°å­—åºåˆ—ç”Ÿæˆçš„ï¼Œè¯¥æ•°å­—åºåˆ—å•è°ƒé€’å¢ï¼Œç›´åˆ°å®ƒå›ç»•ï¼Œå¹¿æ³›åœ°ç§°ä¸º "æ—¶é’Ÿ"ã€‚

This clock is a 32-bit counter that typically increments at least once every roughly 4 microseconds, although it is neither assumed to be realtime nor precise, and need not persist across reboots.  
è¿™ä¸ªæ—¶é’Ÿæ˜¯ä¸€ä¸ª 32 ä½è®¡æ•°å™¨ï¼Œé€šå¸¸å¤§çº¦æ¯ 4 å¾®ç§’è‡³å°‘é€’å¢ä¸€æ¬¡ï¼Œå°½ç®¡å®ƒæ—¢ä¸å‡å®šæ˜¯å®æ—¶çš„ä¹Ÿä¸ç²¾ç¡®ï¼Œå¹¶ä¸”ä¸éœ€è¦åœ¨é‡æ–°å¯åŠ¨åæŒç»­å­˜åœ¨ã€‚

The clock component is intended to ensure that with a Maximum Segment Lifetime (MSL), generated ISNs will be unique since it cycles approximately every 4.55 hours, which is much longer than the MSL.  
æ—¶é’Ÿç»„ä»¶æ—¨åœ¨ç¡®ä¿ä½¿ç”¨æœ€å¤§æ®µå¯¿å‘½ (MSL) ç”Ÿæˆçš„ ISN å°†æ˜¯å”¯ä¸€çš„ï¼Œå› ä¸ºå®ƒå¤§çº¦æ¯ 4.55 å°æ—¶å¾ªç¯ä¸€æ¬¡ï¼Œè¿™æ¯” MSL é•¿å¾—å¤šã€‚

Please note that for modern networks that support high data rates where the connection might start and quickly advance sequence numbers to overlap within the MSL, it is recommended to implement the Timestamp Option as mentioned later in Section 3.4.3.  
è¯·æ³¨æ„ï¼Œå¯¹äºæ”¯æŒé«˜æ•°æ®ç‡çš„ç°ä»£ç½‘ç»œï¼Œè¿æ¥å¯èƒ½å¼€å§‹å¹¶å¿«é€Ÿæ¨è¿›åºåˆ—å·ï¼Œåœ¨ MSL å†…é‡å ï¼Œå»ºè®®å®ç° 3.4.3 èŠ‚åé¢æåˆ°çš„æ—¶é—´æˆ³é€‰é¡¹ã€‚

A TCP implementation MUST use the above type of "clock" for clock-driven selection of initial sequence numbers (MUST-8), and SHOULD generate its initial sequence numbers with the expression:  
å¯¹äºåˆå§‹åºåˆ—å·(MUST-8)çš„æ—¶é’Ÿé©±åŠ¨é€‰æ‹©ï¼ŒTCP å®ç°å¿…é¡»ä½¿ç”¨ä¸Šè¿°ç±»å‹çš„ "æ—¶é’Ÿ"ï¼Œå¹¶ä¸”åº”ä½¿ç”¨ä»¥ä¸‹è¡¨è¾¾å¼ç”Ÿæˆå…¶åˆå§‹åºåˆ—å·ï¼š

ISN = M + F(localip, localport, remoteip, remoteport, secretkey)

where M is the 4 microsecond timer, and F() is a pseudorandom function (PRF) of the connection's identifying parameters ("localip, localport, remoteip, remoteport") and a secret key ("secretkey") (SHLD-1).  
å…¶ä¸­ï¼ŒM æ˜¯ 4 å¾®ç§’è®¡æ—¶å™¨ï¼ŒF()æ˜¯è¿æ¥çš„æ ‡è¯†å‚æ•°("localip, localport, remoteip, remoteport")å’Œå¯†é’¥("seckkey")(SHLD-1)çš„ä¼ªéšæœºå‡½æ•°(PRF)ã€‚

F() MUST NOT be computable from the outside (MUST-9), or an attacker could still guess at sequence numbers from the ISN used for some other connection.  
F()ä¸èƒ½ä»å¤–éƒ¨è®¡ç®—å‡ºæ¥(MUST-9)ï¼Œå¦åˆ™æ”»å‡»è€…ä»ç„¶å¯ä»¥ä»ç”¨äºå…¶ä»–è¿æ¥çš„ ISN ä¸­çŒœæµ‹åºåˆ—å·ã€‚

The PRF could be implemented as a cryptographic hash of the concatenation of the TCP connection parameters and some secret data.  
PRF å¯ä»¥è¢«å®ç°ä¸º TCP è¿æ¥å‚æ•°å’Œä¸€äº›ç§˜å¯†æ•°æ®çš„çº§è”çš„å¯†ç æ•£åˆ—ã€‚

For discussion of the selection of a specific hash algorithm and management of the secret key data, please see Section 3 of [42].  
å…³äºç‰¹å®šæ•£åˆ—ç®—æ³•çš„é€‰æ‹©å’Œå¯†é’¥æ•°æ®çš„ç®¡ç†çš„è®¨è®ºï¼Œè¯·å‚è§[42]çš„ç¬¬ 3 èŠ‚ã€‚

For each connection there is a send sequence number and a receive sequence number.  
å¯¹äºæ¯ä¸ªè¿æ¥ï¼Œéƒ½æœ‰ä¸€ä¸ªå‘é€åºåˆ—å·å’Œä¸€ä¸ªæ¥æ”¶åºåˆ—å·ã€‚

The initial send sequence number (ISS) is chosen by the data sending TCP peer, and the initial receive sequence number (IRS) is learned during the connection-establishing procedure.  
åˆå§‹å‘é€åºåˆ—å·(ISS)ç”±æ•°æ®å‘é€ TCP é€‰æ‹©ï¼Œè€Œåˆå§‹æ¥æ”¶åºåˆ—å·(IRS)åœ¨è¿æ¥å»ºç«‹è¿‡ç¨‹ä¸­å¾—åˆ°ã€‚

For a connection to be established or initialized, the two TCP peers must synchronize on each other's initial sequence numbers.  
å¦‚æœè¦å»ºç«‹æˆ–åˆå§‹åŒ–çš„è¿æ¥ï¼Œä¸¤ä¸ª TCP å¿…é¡»åŒæ­¥å¯¹æ–¹çš„åˆå§‹åºåˆ—å·ã€‚

This is done in an exchange of connection-establishing segments carrying a control bit called "SYN" (for synchronize) and the initial sequence numbers.  
è¿™æ˜¯é€šè¿‡äº¤æ¢å»ºç«‹è¿æ¥çš„ä¿¡æ¯æ¥å®Œæˆçš„ï¼Œè¿™äº›ä¿¡æ¯å¸¦æœ‰ä¸€ä¸ªç§°ä¸º "SYN"ï¼ˆç”¨äºåŒæ­¥ï¼‰çš„æ§åˆ¶ä½å’Œåˆå§‹åºåˆ—å·ã€‚

As a shorthand, segments carrying the SYN bit are also called "SYNs".  
ç®€è€Œè¨€ä¹‹ï¼Œæºå¸¦ SYN ä½çš„æ¶ˆæ¯ä¹Ÿç§°ä¸º "SYNs"ã€‚

Hence, the solution requires a suitable mechanism for picking an initial sequence number and a slightly involved handshake to exchange the ISNs.  
å› æ­¤ï¼Œè¯¥è§£å†³æ–¹æ¡ˆéœ€è¦ä¸€ä¸ªåˆé€‚çš„æœºåˆ¶æ¥æŒ‘é€‰åˆå§‹åºåˆ—å·ï¼Œå¹¶éœ€è¦ä¸€ä¸ªç¨å¾®å¤æ‚çš„æ¡æ‰‹æ¥äº¤æ¢ ISNã€‚

The synchronization requires each side to send its own initial sequence number and to receive a confirmation of it in acknowledgment from the remote TCP peer.  
åŒæ­¥éœ€è¦æ¯ä¸€æ–¹å‘é€è‡ªå·±çš„åˆå§‹åºåˆ—å·ï¼Œå¹¶ä»è¿œç«¯çš„ ACK ä¸­å¾—åˆ°ç¡®è®¤ã€‚

Each side must also receive the remote peer's initial sequence number and send a confirming acknowledgment.  
æ¯ä¸€æ–¹è¿˜å¿…é¡»æ”¶åˆ°è¿œç«¯çš„åˆå§‹åºåˆ—å·ï¼Œå¹¶å‘é€ç¡®è®¤çš„ ACKã€‚

(1) A --> B SYN my sequence number is X  
(1) A --> B åŒæ­¥è‡ªå·±çš„åºåˆ—å· X

(2) A <-- B ACK your sequence number is X  
(2) A <-- B ç¡®è®¤ä½ çš„åºåˆ—å·æ˜¯ X

(3) A <-- B SYN my sequence number is Y  
(3) A <-- B åŒæ­¥è‡ªå·±çš„åºåˆ—å· Y

(4) A --> B ACK your sequence number is Y  
(4) A --> B ç¡®è®¤ä½ çš„åºåˆ—å·æ˜¯ Y

Because steps 2 and 3 can be combined in a single message this is called the three-way (or three message) handshake (3WHS).  
ç”±äºç¬¬ 2 å’Œç¬¬ 3 æ­¥å¯ä»¥ç»“åˆåœ¨ä¸€ä¸ªæ¶ˆæ¯ä¸­ï¼Œè¿™è¢«ç§°ä¸ºä¸‰æ¬¡ï¼ˆæˆ–ä¸‰æ¬¡ä¿¡æ¯ï¼‰æ¡æ‰‹(3WHS)ã€‚

A 3WHS is necessary because sequence numbers are not tied to a global clock in the network, and TCP implementations may have different mechanisms for picking the ISNs.  
"ä¸‰æ¬¡æ¡æ‰‹" æ˜¯å¿…è¦çš„ï¼Œå› ä¸ºåºåˆ—å·æ²¡æœ‰ç»‘å®šåˆ°ç½‘ç»œä¸­çš„å…¨å±€æ—¶é’Ÿï¼Œå¹¶ä¸” TCP å¯èƒ½æœ‰ä¸åŒçš„æœºåˆ¶æ¥æŒ‘é€‰ ISNã€‚

The receiver of the first SYN has no way of knowing whether the segment was an old one or not, unless it remembers the last sequence number used on the connection (which is not always possible), and so it must ask the sender to verify this SYN.  
ç¬¬ä¸€ä¸ª SYN çš„æ¥æ”¶è€…æ²¡æœ‰åŠæ³•çŸ¥é“è¿™ä¸ª TCP æ®µæ˜¯å¦æ˜¯ä¸€ä¸ªæ—§çš„å»¶è¿Ÿæ®µï¼Œé™¤éå®ƒè®°å¾—è¿æ¥ä¸Šä½¿ç”¨çš„æœ€åä¸€ä¸ªåºåˆ—å·ï¼ˆè¿™å¹¶ä¸æ€»æ˜¯å¯èƒ½çš„ï¼‰ï¼Œæ‰€ä»¥å®ƒå¿…é¡»è¦æ±‚å‘é€è€…éªŒè¯è¿™ä¸ª SYNã€‚

The three-way handshake and the advantages of a clock-driven scheme for ISN selection are discussed in [69].  
åœ¨[3]ä¸­è®¨è®ºäº† "ä¸‰æ¬¡æ¡æ‰‹" å’Œ ISN é€‰æ‹© "æ—¶é’Ÿé©±åŠ¨" æ–¹æ¡ˆçš„ä¼˜åŠ¿ã€‚

#### çŸ¥é“ä»€ä¹ˆæ—¶å€™è¯¥ä¿æŒé™é»˜

**3.4.2. Knowing When to Keep Quiet**

A theoretical problem exists where data could be corrupted due to confusion between old segments in the network and new ones after a host reboots if the same port numbers and sequence space are reused.  
å¦‚æœé‡å¤ä½¿ç”¨ç›¸åŒçš„ç«¯å£å·å’Œåºåˆ—ç©ºé—´ï¼Œåˆ™åœ¨ä¸»æœºé‡æ–°å¯åŠ¨åï¼Œç”±äºç½‘ç»œä¸­çš„æ—§ç½‘æ®µå’Œæ–°ç½‘æ®µä¹‹é—´çš„æ··æ·†ï¼Œç†è®ºä¸Šå­˜åœ¨å¯èƒ½å¯¼è‡´æ•°æ®æŸåçš„é—®é¢˜ã€‚

The "quiet time" concept discussed below addresses this, and the discussion of it is included for situations where it might be relevant, although it is not felt to be necessary in most current implementations.  
ä¸‹é¢è®¨è®ºçš„ "é™é»˜æ—¶é—´" æ¦‚å¿µè§£å†³äº†è¿™ä¸€é—®é¢˜ï¼Œå¹¶å°†å®ƒçš„è®¨è®ºåŒ…æ‹¬åœ¨å¯èƒ½ä¸ä¹‹ç›¸å…³çš„æƒ…å†µä¸‹ï¼Œå°½ç®¡å®ƒåœ¨å¤§å¤šæ•°å½“å‰å®ç°ä¸­å¹¶ä¸æ˜¯å¿…è¦çš„ã€‚

The problem was more relevant earlier in the history of TCP.  
åœ¨ TCP å†å²çš„æ—©æœŸï¼Œè¿™ä¸ªé—®é¢˜æ›´ä¸ºç›¸å…³ã€‚

In practical use on the Internet today, the error-prone conditions are sufficiently unlikely that it is safe to ignore.  
åœ¨ä»Šå¤©äº’è”ç½‘çš„å®é™…ä½¿ç”¨ä¸­ï¼Œå®¹æ˜“å‡ºé”™çš„æƒ…å†µä¸å¤ªå¯èƒ½å‘ç”Ÿï¼Œå› æ­¤å¯ä»¥æ”¾å¿ƒåœ°å¿½ç•¥ã€‚

Reasons why it is now negligible include: (a) ISS and ephemeral port randomization have reduced likelihood of reuse of port numbers and sequence numbers after reboots, (b) the effective MSL of the Internet has declined as links have become faster, and (c) reboots often taking longer than an MSL anyways.  
å®ƒç°åœ¨å¯ä»¥å¿½ç•¥ä¸è®¡çš„åŸå› åŒ…æ‹¬ï¼š  
(a) ISS å’Œä¸´æ—¶ç«¯å£éšæœºåŒ–é™ä½äº†é‡æ–°å¯åŠ¨åé‡ç”¨ç«¯å£å·å’Œåºåˆ—å·çš„å¯èƒ½æ€§ã€‚  
(b) éšç€é“¾æ¥å˜å¾—æ›´å¿«ï¼Œäº’è”ç½‘çš„æœ‰æ•ˆ MSL å·²ç»ä¸‹é™ã€‚  
(c) æ— è®ºå¦‚ä½•ï¼Œé‡æ–°å¯åŠ¨é€šå¸¸æ¯” MSL èŠ±è´¹çš„æ—¶é—´æ›´é•¿ã€‚

To be sure that a TCP implementation does not create a segment carries a sequence number that may be duplicated by an old segment remaining in the network, the TCP endpoint must keep quiet for a MSL before assigning any sequence numbers upon starting up or recovering from a situation where memory of sequence numbers in use was lost.  
ä¸ºäº†ç¡®ä¿ TCP å®ç°ä¸ä¼šåˆ›å»ºä¸€ä¸ªæºå¸¦ä¸ç½‘ç»œä¸­æ—§ TCP æ®µä¸­åºåˆ—å·é‡å¤çš„ TCP æ®µï¼ŒTCP åœ¨å¯åŠ¨æ—¶æˆ–ä»ä¸¢å¤±å½“å‰ä½¿ç”¨åºåˆ—å·å†…å­˜çš„å´©æºƒä¸­æ¢å¤æ—¶ï¼Œåœ¨åˆ†é…ä»»ä½•åºåˆ—å·ä¹‹å‰ä¿æŒæœ€å¤§æ®µå­˜æ´»æ—¶é—´ï¼ˆMSLï¼‰çš„é™é»˜æ—¶é—´ã€‚

For this specification the MSL is taken to be 2 minutes.  
åœ¨æœ¬è§„èŒƒä¸­ï¼ŒMSL æ˜¯ 2 åˆ†é’Ÿã€‚

This is an engineering choice, and may be changed if experience indicates it is desirable to do so.  
è¿™æ˜¯ä¸€ä¸ªå·¥ç¨‹é€‰æ‹©ï¼Œå®ƒå¯èƒ½ä¼šæ ¹æ®ç»éªŒæ”¹å˜ã€‚

Note that if a TCP endpoint is reinitialized in some sense, yet retains its memory of sequence numbers in use, then it need not wait at all; it must only be sure to use sequence numbers larger than those recently used.  
æ³¨æ„ï¼Œå¦‚æœä¸€ä¸ª TCP åœ¨æŸç§æƒ…å†µè¢«é‡æ–°åˆå§‹åŒ–ï¼Œä½†ä¿ç•™äº†å…¶æ­£åœ¨ä½¿ç”¨çš„åºåˆ—å·çš„å†…å­˜ï¼Œé‚£ä¹ˆå®ƒä¸éœ€è¦ç­‰å¾…ï¼›å®ƒåªéœ€è¦ç¡®ä¿ä½¿ç”¨æ¯”æœ€è¿‘ä½¿ç”¨çš„åºåˆ—å·å¤§çš„åºåˆ—å·ã€‚

#### TCP é™é»˜æ—¶é—´çš„æ¦‚å¿µ

**3.4.3. The TCP Quiet Time Concept**

Hosts that for any reason lose knowledge of the last sequence numbers transmitted on each active (i.e., not closed) connection shall delay emitting any TCP segments for at least the agreed MSL in the internet system of which the host is a part.  
å¦‚æœä¸»æœºå› ä¸ºä»»ä½•åŸå› æ²¡æœ‰ä¿ç•™åœ¨æ¯ä¸ªæ´»åŠ¨ï¼ˆå³æœªå…³é—­ï¼‰è¿æ¥ä¸Šä¼ è¾“çš„æœ€åä¸€ä¸ªåºåˆ—å·çš„ä»»ä½•ä¿¡æ¯ï¼Œåˆ™åº”è‡³å°‘å»¶è¿Ÿå•†å®šçš„æœ€å¤§æ®µç”Ÿå‘½å‘¨æœŸï¼ˆMSLï¼‰åï¼Œå†å‘é€ä»»ä½• TCP æ®µåˆ°ä¸»æœºæ‰€å¤„çš„ internet ç³»ç»Ÿä¸­ã€‚

In the paragraphs below, an explanation for this specification is given.  
åœ¨ä¸‹é¢çš„æ®µè½ä¸­ï¼Œç»™å‡ºäº†å¯¹è¯¥è§„èŒƒçš„è§£é‡Šã€‚

TCP implementors may violate the "quiet time" restriction, but only at the risk of causing some old data to be accepted as new or new data rejected as old duplicated by some receivers in the internet system.  
TCP å®ç°è€…å¯ä»¥ä¼šè¿å "quiet time" é™åˆ¶ï¼Œä½†æ˜¯å¯èƒ½å­˜åœ¨å¯¼è‡´æŸäº›æ—§æ•°æ®è¢«æ¥å—ä¸ºæ–°æ•°æ®æˆ–æ–°æ•°æ®è¢« internet ç³»ç»Ÿä¸­çš„æŸäº›æ¥æ”¶æ–¹è®¤ä¸ºæ˜¯æ—§çš„é‡å¤æ•°æ®è€Œæ‹’æ”¶çš„é£é™©ã€‚

TCP endpoints consume sequence number space each time a segment is formed and entered into the network output queue at a source host.  
æ¯æ¬¡ç”Ÿæˆæ®µå¹¶åŠ å…¥åˆ°æºä¸»æœºçš„ç½‘ç»œè¾“å‡ºé˜Ÿåˆ—æ—¶ï¼ŒTCP éƒ½ä¼šæ¶ˆè€—åºåˆ—å·ç©ºé—´ã€‚

The duplicate detection and sequencing algorithm in the TCP protocol relies on the unique binding of segment data to sequence space to the extent that sequence numbers will not cycle through all 2\*\*32 values before the segment data bound to those sequence numbers has been delivered and acknowledged by the receiver and all duplicate copies of the segments have "drained" from the internet.  
TCP åè®®ä¸­çš„é‡å¤æ£€æµ‹å’Œæ’åºç®—æ³•ä¾èµ–äºæ®µæ•°æ®ä¸åºåˆ—ç©ºé—´çš„å”¯ä¸€ç»‘å®šï¼Œå› æ­¤ä¸è¿™äº›åºåˆ—å·ç»‘å®šçš„æ®µæ•°æ®è¢«é€è¾¾å¹¶è¢«æ¥æ”¶æ–¹ç¡®è®¤ä»¥åŠæ®µçš„æ‰€æœ‰å‰¯æœ¬ä»äº’è”ç½‘ä¸Š "è€—å°½" ä¹‹å‰ï¼Œåºåˆ—å·ä¸ä¼šåœ¨æ‰€æœ‰ 2\*\*32 å€¼ä¸­å¾ªç¯ã€‚

Without such an assumption, two distinct TCP segments could conceivably be assigned the same or overlapping sequence numbers, causing confusion at the receiver as to which data is new and which is old.  
å¦‚æœæ²¡æœ‰è¿™æ ·çš„å‡è®¾ï¼Œä¸¤ä¸ªä¸åŒçš„ TCP æ®µå¯èƒ½ä¼šè¢«åˆ†é…ç›¸åŒæˆ–é‡å çš„åºåˆ—å·ï¼Œä»è€Œå¯¼è‡´æ¥æ”¶æ–¹æ— æ³•åŒºåˆ†å“ªäº›æ•°æ®æ˜¯æ–°æ•°æ®ï¼Œå“ªäº›æ˜¯æ—§æ•°æ®ã€‚

Remember that each segment is bound to as many consecutive sequence numbers as there are octets of data and SYN or FIN flags in the segment.  
è®°ä½ï¼Œæ¯ä¸ªæ®µéƒ½ç»‘å®šåˆ°ä¸æ®µä¸­æ•°æ®å’Œ SYN æˆ– FIN æ ‡å¿—çš„å­—èŠ‚ä¸€æ ·å¤šçš„è¿ç»­åºåˆ—å·ã€‚

Under normal conditions, TCP implementations keep track of the next sequence number to emit and the oldest awaiting acknowledgment so as to avoid mistakenly reusing a sequence number over before its first use has been acknowledged.  
åœ¨æ­£å¸¸æƒ…å†µä¸‹ï¼ŒTCP ä¼šè·Ÿè¸ªä¸‹ä¸€ä¸ªè¦å‘å‡ºçš„åºåˆ—å·å’Œæœ€æ—§çš„ç­‰å¾…ç¡®è®¤çš„åºåˆ—å·ï¼Œä»¥é¿å…åœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨å¾—åˆ°ç¡®è®¤ä¹‹å‰é”™è¯¯åœ°é‡ç”¨è¯¥åºåˆ—å·ã€‚

This alone does not guarantee that old duplicate data is drained from the net, so the sequence space has been made very large to reduce the probability that a wandering duplicate will cause trouble upon arrival.  
ä»…ä»…è¿™æ ·å¹¶ä¸èƒ½ä¿è¯æ—§çš„é‡å¤æ•°æ®ä»ç½‘ç»œä¸­æ¶ˆå¤±ï¼Œæ‰€ä»¥åºåˆ—ç©ºé—´è¢«åšå¾—éå¸¸å¤§ï¼Œä»¥å‡å°‘æ¼«æ¸¸çš„é‡å¤æ•°æ®åˆ°è¾¾åé€ æˆéº»çƒ¦çš„å¯èƒ½æ€§ã€‚

At 2 megabits/sec. it takes 4.5 hours to use up 2\*\*32 octets of sequence space.  
åœ¨ 2 å…†æ¯”ç‰¹/ç§’çš„æƒ…å†µä¸‹ï¼Œéœ€è¦ 4.5 å°æ—¶æ‰èƒ½ç”¨å®Œ 2\*\*32 ä¸ªå­—èŠ‚çš„åºåˆ—ç©ºé—´ã€‚

Since the maximum segment lifetime in the net is not likely to exceed a few tens of seconds, this is deemed ample protection for foreseeable nets, even if data rates escalate to 10's of megabits/sec.  
ç”±äºç½‘ç»œä¸­çš„æ®µçš„æœ€å¤§å­˜æ´»æ—¶é—´ä¸å¤ªå¯èƒ½è¶…è¿‡å‡ åç§’ï¼Œè¿™è¢«è®¤ä¸ºæ˜¯å¯¹å¯é¢„è§ç½‘ç»œçš„å……åˆ†ä¿æŠ¤ï¼Œå³ä½¿æ•°æ®é€Ÿç‡å‡çº§åˆ° 10 å…†æ¯”ç‰¹/ç§’ã€‚

At 100 megabits/sec, the cycle time is 5.4 minutes which may be a little short, but still within reason.  
åœ¨ 100 å…†æ¯”ç‰¹/ç§’æ—¶ï¼Œå¾ªç¯æ—¶é—´ä¸º 5.4 åˆ†é’Ÿï¼Œè¿™å¯èƒ½æœ‰ç‚¹çŸ­ï¼Œä½†ä»åœ¨åˆç†èŒƒå›´å†…ã€‚

Much higher data rates are possible today, with implications described in the final paragraph of this subsection.  
ä»Šå¤©ï¼Œæ›´é«˜çš„æ•°æ®é€Ÿç‡æ˜¯å¯èƒ½çš„ï¼Œå…¶å½±å“åœ¨æœ¬å°èŠ‚çš„æœ€åä¸€æ®µä¸­æè¿°ã€‚

The basic duplicate detection and sequencing algorithm in TCP can be defeated, however, if a source TCP endpoint does not have any memory of the sequence numbers it last used on a given connection.  
ç„¶è€Œï¼Œå¦‚æœæº TCP æ²¡æœ‰ä»»ä½•å…³äºå®ƒåœ¨ç»™å®šè¿æ¥ä¸Šæœ€åä½¿ç”¨çš„åºåˆ—å·çš„å†…å­˜ï¼Œåˆ™ TCP ä¸­çš„åŸºç¡€é‡å¤æ£€æµ‹å’Œæ’åºç®—æ³•å¯èƒ½ä¼šå¤±æ•ˆã€‚

For example, if the TCP implementation were to start all connections with sequence number 0, then upon the host rebooting, a TCP peer might re-form an earlier connection (possibly after half-open connection resolution) and emit packets with sequence numbers identical to or overlapping with packets still in the network which were emitted on an earlier incarnation of the same connection.  
ä¾‹å¦‚ï¼Œå¦‚æœ TCP ä»¥åºåˆ—å· 0 å¼€å§‹æ‰€æœ‰è¿æ¥ï¼Œé‚£ä¹ˆåœ¨é‡æ–°å¯åŠ¨æ—¶ï¼ŒTCP å¯èƒ½ä¼šé‡æ–°å»ºç«‹è¾ƒæ—©çš„è¿æ¥ï¼ˆå¯èƒ½åœ¨åŠå¼€è¿æ¥è§£æä¹‹åï¼‰å¹¶å‘å‡ºåºåˆ—å·ä¸ç½‘ç»œä¸­çš„æ•°æ®åŒ…ç›¸åŒæˆ–é‡å çš„æ•°æ®åŒ…ï¼Œè¿™äº›æ•°æ®åŒ…æ˜¯åœ¨åŒä¸€è¿æ¥çš„æ—©æœŸå®ä¾‹ä¸‹å‘å‡ºçš„ã€‚

In the absence of knowledge about the sequence numbers used on a particular connection, the TCP specification recommends that the source delay for MSL seconds before emitting segments on the connection, to allow time for segments from the earlier connection incarnation to drain from the system.  
åœ¨ä¸çŸ¥é“ç‰¹å®šè¿æ¥ä¸Šä½¿ç”¨çš„åºåˆ—å·çš„æƒ…å†µä¸‹ï¼ŒTCP è§„èŒƒå»ºè®®æº TCP åœ¨è¿æ¥ä¸Šå‘é€æ®µä¹‹å‰å»¶è¿Ÿ MSL ç§’ï¼Œä»¥ä¾¿è®©æ¥è‡ªæ—©æœŸè¿æ¥å®ä¾‹çš„æ®µæœ‰æ—¶é—´ä»ç³»ç»Ÿä¸­æ¶ˆå¤±ã€‚

Even hosts which can remember the time of day and used it to select initial sequence number values are not immune from this problem (i.e., even if time of day is used to select an initial sequence number for each new connection incarnation).  
å³ä½¿æ˜¯å¯ä»¥è®°ä½ä¸€å¤©ä¸­çš„æ—¶é—´å¹¶ä½¿ç”¨å®ƒæ¥é€‰æ‹©åˆå§‹åºåˆ—å·å€¼çš„ä¸»æœºä¹Ÿä¸èƒ½é¿å…è¿™ä¸ªé—®é¢˜ï¼ˆå³ï¼Œå³ä½¿ä¸€å¤©ä¸­çš„æ—¶é—´ç”¨äºä¸ºæ¯ä¸ªæ–°è¿æ¥åŒ–èº«é€‰æ‹©ä¸€ä¸ªåˆå§‹åºåˆ—å·ï¼‰ã€‚

Suppose, for example, that a connection is opened starting with sequence number S.  
ä¾‹å¦‚ï¼Œå‡è®¾ä¸€ä¸ªè¿æ¥ä»¥åºåˆ—å· S å¼€å§‹æ‰“å¼€ã€‚

Suppose that this connection is not used much and that eventually the initial sequence number function (ISN(t)) takes on a value equal to the sequence number, say S1, of the last segment sent by this TCP on a particular connection.  
å‡è®¾è¿™ä¸ªè¿æ¥ä½¿ç”¨ä¸å¤šï¼Œæœ€ç»ˆåˆå§‹åºåˆ—å·å‡½æ•°ï¼ˆISN(t)ï¼‰çš„å€¼ç­‰äºè¿™ä¸ª TCP åœ¨ç‰¹å®šè¿æ¥ä¸Šå‘é€çš„æœ€åä¸€ä¸ªæ®µçš„åºåˆ—å·ï¼Œä¾‹å¦‚ S1ã€‚

Now suppose, at this instant, the host reboots and establishes a new incarnation of the connection.  
ç°åœ¨ï¼Œå‡è®¾åœ¨è¿™ä¸ªæ—¶åˆ»ï¼Œä¸»æœºé‡å¯å¹¶å»ºç«‹äº†ä¸€ä¸ªæ–°çš„è¿æ¥çš„å®ä¾‹ã€‚

The initial sequence number chosen is S1 = ISN(t) -- last used sequence number on old incarnation of connection!  
é€‰æ‹©çš„åˆå§‹åºåˆ—å·æ˜¯ S1 = ISN(t) -- æ—§çš„è¿æ¥çš„æœ€åä½¿ç”¨çš„åºåˆ—å·!

If the recovery occurs quickly enough, any old duplicates in the net bearing sequence numbers in the neighborhood of S1 may arrive and be treated as new packets by the receiver of the new incarnation of the connection.  
å¦‚æœæ¢å¤å‘ç”Ÿå¾—è¶³å¤Ÿå¿«ï¼Œç½‘ç»œä¸­ä»»ä½•å¸¦æœ‰ S1 é™„è¿‘åºåˆ—å·çš„æ—§é‡å¤æ•°æ®éƒ½å¯èƒ½åˆ°è¾¾ï¼Œå¹¶è¢«æ–°çš„è¿æ¥å®ä¾‹çš„æ¥æ”¶è€…è§†ä¸ºæ–°çš„æ•°æ®åŒ…ã€‚

The problem is that the recovering host may not know for how long it was down between rebooting nor does it know whether there are still old duplicates in the system from earlier connection incarnations.  
é—®é¢˜æ˜¯æ­£åœ¨æ¢å¤çš„ä¸»æœºå¯èƒ½ä¸çŸ¥é“å®ƒé‡å¯äº†å¤šé•¿æ—¶é—´ï¼Œä¹Ÿä¸çŸ¥é“ç³»ç»Ÿä¸­æ˜¯å¦ä»ç„¶å­˜åœ¨æ¥è‡ªæ—©æœŸè¿æ¥å®ä¾‹çš„æ—§çš„é‡å¤æ•°æ®ã€‚

One way to deal with this problem is to deliberately delay emitting segments for one MSL after recovery from a crash- this is the "quiet time" specification.  
è§£å†³è¿™ä¸ªé—®é¢˜çš„ä¸€ç§æ–¹æ³•æ˜¯åœ¨ä»å´©æºƒä¸­æ¢å¤åæ•…æ„å»¶è¿Ÿä¸€ä¸ª MSL å†å‘é€æ®µï¼Œè¿™æ˜¯ "é™é»˜æ—¶é—´" è§„èŒƒã€‚

Hosts that prefer to avoid waiting are willing to risk possible confusion of old and new packets at a given destination may choose not to wait for the "quie t time".  
å–œæ¬¢é¿å…ç­‰å¾…çš„ä¸»æœºï¼Œæ„¿æ„å†’ç€åœ¨ç›®çš„åœ°å¯èƒ½å‡ºç°æ–°æ—§æ•°æ®åŒ…æ··æ·†çš„é£é™©ï¼Œå¯ä»¥é€‰æ‹©ä¸ç­‰å¾… "é™é»˜æ—¶é—´"ã€‚

Implementors may provide TCP users with the ability to select on a connection-by-connection basis whether to wait after a reboot, or may informally implement the "quiet time" for all connections.  
å®ç°è€…å¯ä»¥ä¸º TCP ç”¨æˆ·æä¾›åœ¨è¿æ¥åŸºç¡€ä¸Šé€‰æ‹©æ˜¯å¦åœ¨å´©æºƒåç­‰å¾…çš„èƒ½åŠ›ï¼Œæˆ–è€…å¯ä»¥éæ­£å¼åœ°ä¸ºæ‰€æœ‰è¿æ¥å®ç° "é™é»˜æ—¶é—´"ã€‚

Obviously, even where a user selects to "wait", this is not necessary after the host has been "up" for at least MSL seconds.  
å¾ˆæ˜æ˜¾ï¼Œå³ä½¿ç”¨æˆ·é€‰æ‹©äº† "ç­‰å¾…"ï¼Œåœ¨ä¸»æœºè‡³å°‘ "å¯åŠ¨" äº† MSL ç§’ä¹‹åï¼Œä¹Ÿæ²¡æœ‰å¿…è¦è¿™æ ·åšã€‚

To summarize: every segment emitted occupies one or more sequence numbers in the sequence space, the numbers occupied by a segment are "busy" or "in use" until MSL seconds have passed.  
æ€»ç»“ä¸€ä¸‹ï¼šæ¯ä¸ªå‘å‡ºçš„æ®µåœ¨åºåˆ—ç©ºé—´ä¸­å æ®ä¸€ä¸ªæˆ–å¤šä¸ªåºåˆ—å·ï¼Œæ®µæ‰€å æ®çš„åºåˆ—å·æ˜¯ "å¿™" æˆ– "ä½¿ç”¨ä¸­"ï¼Œç›´åˆ° MSL ç§’è¿‡å»ã€‚

Upon rebooting, a block of space-time is occupied by the octets and SYN or FIN flags of any potentially still in-flight segments.  
é‡å¯æ—¶ï¼Œä¸€ä¸ªæ—¶ç©ºå—è¢«ä»»ä½•ä»åœ¨ç½‘ç»œä¸­çš„æ®µçš„æ•°æ®å’Œ SYN æˆ– FIN æ ‡å¿—å æ®ã€‚

If a new connection is started too soon and uses any of the sequence numbers in the space-time footprint of those potentially still in-flight segment of the previous connection incarnation, there is a potential sequence number overlap area which could cause confusion at the receiver.  
å¦‚æœæ–°è¿æ¥å¯åŠ¨å¾—å¤ªæ—©ï¼Œå¹¶ä¸”ä½¿ç”¨äº†å‰ä¸€ä¸ªè¿æ¥å®ä¾‹çš„ä»åœ¨ç½‘ç»œä¸­çš„æ®µçš„æ—¶ç©ºè¶³è¿¹ä¸­çš„ä»»ä½•åºåˆ—å·ï¼Œåˆ™å­˜åœ¨æ½œåœ¨çš„åºåˆ—å·é‡å åŒºåŸŸï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´æ¥æ”¶æ–¹æ··æ·†ã€‚

High-performance cases will have shorter cycle times than those in the megabits per second that the base TCP design described above considers.  
é«˜æ€§èƒ½æƒ…å†µä¸‹çš„å‘¨æœŸæ—¶é—´å°†æ¯”ä¸Šè¿°åŸºæœ¬ TCP è®¾è®¡è€ƒè™‘çš„å…†æ¯”ç‰¹æ¯ç§’çš„å‘¨æœŸæ—¶é—´æ›´çŸ­ã€‚

At 1 Gbps, the cycle time is 34 seconds, only 3 seconds at 10 Gbps, and around a third of a second at 100 Gbps.  
åœ¨ 1 Gbps æ—¶ï¼Œå‘¨æœŸæ—¶é—´ä¸º 34 ç§’ï¼Œåœ¨ 10 Gbps æ—¶ä»…ä¸º 3 ç§’ï¼Œåœ¨ 100 Gbps æ—¶çº¦ä¸ºä¸‰åˆ†ä¹‹ä¸€ç§’ã€‚

In these higher-performance cases, TCP Timestamp Options and Protection Against Wrapped Sequences (PAWS) [47] provide the needed capability to detect and discard old duplicates.  
åœ¨è¿™äº›æ›´é«˜æ€§èƒ½çš„æƒ…å†µä¸‹ï¼ŒTCP æ—¶é—´æˆ³é€‰é¡¹å’Œé’ˆå¯¹åŒ…è£…åºåˆ—çš„ä¿æŠ¤(PAWS)[47]æä¾›äº†æ£€æµ‹å’Œä¸¢å¼ƒæ—§å‰¯æœ¬æ‰€éœ€çš„èƒ½åŠ›ã€‚

### å»ºç«‹è¿æ¥

**3.5. Establishing a Connection**
