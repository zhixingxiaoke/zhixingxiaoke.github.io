---
title: RFC9293 TCP 协议
weight: 3
draft: true
# bookFlatSection: false
# bookToc: true
# bookHidden: false
# bookCollapseSection: false
# bookComments: false
# bookSearchExclude: false
---

# RFC9293 TCP 协议中文翻译

这是 RFC 上最新（截止到 2023 年 3 月）完整描述了 TCP 协议标准的文档，它整合了 RFC793 提出的 TCP 规范以及后来提出的多项优化 ，如果对 RFC793 感兴趣可以参考[RFC793 TCP 协议中文翻译](../translations/rfc793)。

原文：[Transmission Control Protocol (TCP)](https://datatracker.ietf.org/doc/rfc9293/)

## 封面

Internet Engineering Task Force (IETF)  
STD: 7  
Request for Comments: 9293  
Obsoletes: 793, 879, 2873, 6093, 6429, 6528, 6691  
Updates: 1011, 1122, 5961  
Category: Standards Track  
ISSN: 2070-1721

{{< right >}}
W. Eddy, Ed.  
MTI Systems  
August 2022
{{< /right >}}

{{< center >}}
Transmission Control Protocol (TCP)  
传输控制协议（TCP）
{{< /center >}}

## 摘要

**Abstract**

This document specifies the Transmission Control Protocol (TCP).  
本文档规定了传输控制协议（TCP）。

TCP is an important transport-layer protocol in the Internet protocol stack, and it has continuously evolved over decades of use and growth of the Internet.  
TCP 是 Internet 协议栈中重要的传输层协议，在互联网数十年的使用和发展过程中不断改进。

Over this time, a number of changes have been made to TCP as it was specified in RFC 793, though these have only been documented in a piecemeal fashion.  
在这段时间里，已经对 RFC 793 中规定的 TCP 进行了一些修改，尽管这些修改只是以零散的方式被记录下来。

This document collects and brings those changes together with the protocol specification from RFC 793.  
本文件收集了这些变化，并将其与 RFC 793 的协议规范结合在一起。

This document obsoletes RFC 793, as well as RFCs 879, 2873, 6093, 6429, 6528, and 6691 that updated parts of RFC 793.  
本文档废弃了 RFC 793，以及更新了 RFC 793 部分内容的 RFC 879、2873、6093、6429、6528 和 6691。

It updates RFCs 1011 and 1122, and it should be considered as a replacement for the portions of those documents dealing with TCP requirements.  
它更新了 RFC 1011 和 1122，它可以被视为那些文档中涉及 TCP 要求的部分的替代品。

It also updates RFC 5961 by adding a small clarification in reset handling while in the SYN-RECEIVED state.  
它还更新了 RFC 5961，在 SYN-RECEIVED 状态下在重置处理中添加了一个小的说明。

The TCP header control bits from RFC 793 have also been updated based on RFC 3168.  
RFC 793 中的 TCP 头控制位也根据 RFC 3168 进行了更新。

**Status of This Memo**

This is an Internet Standards Track document.  
这是一份互联网标准追踪文件。

This document is a product of the Internet Engineering Task Force (IETF).  
本文档是 Internet 工程任务组 (IETF) 的产品。

It represents the consensus of the IETF community.  
它代表了 IETF 社区的共识。

It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG).  
它已经接受了公众审阅，并已被互联网工程指导小组 (IESG) 批准发布。

Further information on Internet Standards is available in Section 2 of RFC 7841.  
有关 Internet 标准的更多信息，请参阅 RFC 7841 的第 2 节。

Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9293.  
有关本文档的当前状态、任何勘误表以及如何提供反馈的信息，请访问 [🔗](https://www.rfc-editor.org/info/rfc9293)。

## 版权声明

**Copyright Notice**

Copyright (c) 2022 IETF Trust and the persons identified as the document authors.  
Copyright (c) 2022 IETF Trust 和被认定为本文档作者的人员。

All rights reserved.  
保留所有权利。

This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  
本文档受 BCP 78 和 IETF 信托与 IETF 文档相关的法律规定 [🔗](https://trustee.ietf.org/license-info) 的约束，这些条款在本文档发布之日生效。

Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  
请仔细阅读这些文件，因为它们描述了您对本文件的权利和限制。

Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.  
从本文件中提取的代码组件必须包括信托法律条款第 4.e 节中描述的修订版 BSD 许可文本，并且不提供修订版 BSD 许可中描述的保证。

This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008.  
本文档可能包含 2008 年 11 月 10 日之前发布或公开提供的 IETF 文档或 IETF 文稿中的材料。

The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process.  
控制本材料某些版权的人可能未授予 IETF 信托允许在 IETF 标准流程之外修改此类材料的权利。

Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.  
如果没有从控制此类材料的版权的人那里获得足够的许可，则不得在 IETF 标准流程之外修改本文档，并且不得在 IETF 标准流程之外创建其衍生作品，除非将其格式化为 RFC 出版或将其翻译成英语以外的其他语言。

## 目录

{{< center >}}
Table of Contents
{{< /center >}}

1.Purpose and Scope 目的和范围

2.Introduction 介绍  
&emsp;2.1. Requirements Language 需求语言  
&emsp;2.2. Key TCP Concepts 关键的 TCP 概念

3.Functional Specification 功能规范  
&emsp;3.1. Header Format 头部格式  
&emsp;3.2. Specific Option Definitions 具体选项定义  
&emsp;&emsp;3.2.1. Other Common Options 其他常用选项  
&emsp;&emsp;3.2.2. Experimental TCP Options 实验性 TCP 选项  
&emsp;3.3. TCP Terminology Overview TCP 术语概述  
&emsp;&emsp;3.3.1. Key Connection State Variables 关键连接状态变量  
&emsp;&emsp;3.3.2. State Machine Overview 状态机概述  
&emsp;3.4. Sequence Numbers 序列号  
&emsp;&emsp;3.4.1. Initial Sequence Number Selection 初始序列号选择  
&emsp;&emsp;3.4.2. Knowing When to Keep Quiet 知道什么时候该保持静默  
&emsp;&emsp;3.4.3. The TCP Quiet Time Concept TCP 静默时间概念  
&emsp;3.5. Establishing a Connection 建立连接  
&emsp;&emsp;3.5.1. Half-Open Connections and Other Anomalies 半开连接和其他异常  
&emsp;&emsp;3.5.2. Reset Generation 重置生成  
&emsp;&emsp;3.5.3. Reset Processing 重置处理  
&emsp;3.6. Closing a Connection 关闭连接  
&emsp;&emsp;3.6.1. Half-Closed Connections 半闭连接  
&emsp;3.7. Segmentation 分段  
&emsp;&emsp;3.7.1. Maximum Segment Size Option 最大段长度选项  
&emsp;&emsp;3.7.2. Path MTU Discovery 路径 MTU 发现  
&emsp;&emsp;3.7.3. Interfaces with Variable MTU Values 可变 MTU 值的接口  
&emsp;&emsp;3.7.4. Nagle Algorithm Nagle 算法  
&emsp;&emsp;3.7.5. IPv6 Jumbograms  
&emsp;3.8. Data Communication 数据通信  
&emsp;&emsp;3.8.1. Retransmission Timeout 重传超时  
&emsp;&emsp;3.8.2. TCP Congestion Control TCP 拥塞控制  
&emsp;&emsp;3.8.3. TCP Connection Failures TCP 连接故障  
&emsp;&emsp;3.8.4. TCP Keep-Alives  
&emsp;&emsp;3.8.5. The Communication of Urgent Information 紧急信息的通信  
&emsp;&emsp;3.8.6. Managing the Window 管理窗口  
&emsp;3.9. Interfaces 接口  
&emsp;&emsp;3.9.1. User/TCP Interface 用户/TCP 接口  
&emsp;&emsp;3.9.2. TCP/Lower-Level Interface TCP/下层协议接口  
&emsp;3.10. Event Processing 事件处理  
&emsp;&emsp;3.10.1. OPEN Call OPEN 调用  
&emsp;&emsp;3.10.2. SEND Call SEND 调用  
&emsp;&emsp;3.10.3. RECEIVE Call RECEIVE 调用  
&emsp;&emsp;3.10.4. CLOSE Call CLOSE 调用  
&emsp;&emsp;3.10.5. ABORT Call ABORT 调用  
&emsp;&emsp;3.10.6. STATUS Call STATUS 调用  
&emsp;&emsp;3.10.7. SEGMENT ARRIVES 收到段  
&emsp;&emsp;3.10.8. Timeouts 超时

4.Glossary 词汇表

5.Changes from RFC 793 与 RFC 793 相比的改动

6.IANA Considerations IANA 的注意事项

7.Security and Privacy Considerations 安全和隐私注意事项

8.References 参考文献  
&emsp;8.1. Normative References 规范性参考文献  
&emsp;8.2. Informative References 非规范性参考文献

Appendix A. Other Implementation Notes 其他实现说明  
&emsp;A.1. IP Security Compartment and Precedence IP 安全部分和优先级  
&emsp;&emsp;A.1.1. Precedence 优先级  
&emsp;&emsp;A.1.2. MLS Systems MLS 系统  
&emsp;A.2. Sequence Number Validation 序列号验证  
&emsp;A.3. Nagle Modification Nagle 修改  
&emsp;A.4. Low Watermark Settings 低水印设置

Appendix B. TCP Requirement Summary TCP 要求概述

Acknowledgments 致谢

Author's Address 作者的地址

## 目的和范围

**1.Purpose and Scope**

In 1981, RFC 793 [16] was released, documenting the Transmission Control Protocol (TCP) and replacing earlier published specifications for TCP.  
1981 年，RFC 793 [16] 发布，记录了传输控制协议 (TCP) 并取代了早期发布的 TCP 规范。

Since then, TCP has been widely implemented, and it has been used as a transport protocol for numerous applications on the Internet.  
从那时起，TCP 得到了广泛的应用，并被用作 Internet 上众多应用程序的传输协议。

For several decades, RFC 793 plus a number of other documents have combined to serve as the core specification for TCP [49].  
几十年来，RFC 793 加上许多其他文档已合并为 TCP 的核心规范[49]。

Over time, a number of errata have been filed against RFC 793.  
随着时间的流逝，已经针对 RFC 793 提出了许多勘误表。

There have also been deficiencies found and resolved in security, performance, and many other aspects.  
在安全、性能和其他许多方面也发现和解决了一些缺陷。

The number of enhancements has grown over time across many separate documents.  
随着时间的推移，改进的数量在许多独立的文件中不断增加。

These were never accumulated together into a comprehensive update to the base specification.  
这些改进还没有被整合到一起，整体更新基本规范。

The purpose of this document is to bring together all of the IETF Standards Track changes and other clarifications that have been made to the base TCP functional specification (RFC 793) and to unify them into an updated version of the specification.  
本文档的目的是将所有 IETF 标准轨道的修改和其他对基础 TCP 功能规范（RFC 793）的说明汇集在一起，并将它们统一到规范的更新版本中。

Some companion documents are referenced for important algorithms that are used by TCP (e.g., for congestion control) but have not been completely included in this document.  
但是一些用于 TCP 使用的重要算法（例如，用于拥塞控制）的相关文档，还没有完全包括在本文档中。

This is a conscious choice, as this base specification can be used with multiple additional algorithms that are developed and incorporated separately.  
这是一个有意识的选择，因为该基本规范可以与多种额外的算法一起使用，这些算法是单独开发和合并的。

This document focuses on the common basis that all TCP implementations must support in order to interoperate.  
本文档重点关注所有 TCP 实现必须支持的共同基础，以实现互操作。

Since some additional TCP features have become quite complicated themselves (e.g., advanced loss recovery and congestion control), future companion documents may attempt to similarly bring these together.  
因为一些额外的 TCP 功能本身已经变得相当复杂（例如，高级损失恢复和拥塞控制），未来的配套文档可能会试图类似地将这些功能集中起来。

In addition to the protocol specification that describes the TCP segment format, generation, and processing rules that are to be implemented in code, RFC 793 and other updates also contain informative and descriptive text for readers to understand aspects of the protocol design and operation.  
除了描述要在代码中实现的 TCP 段格式、生成和处理规则的协议规范外，RFC 793 和其他更新还包含信息和描述性内容，以便读者了解协议设计和运行的各个方面。

This document does not attempt to alter or update this informative text and is focused only on updating the normative protocol specification.  
本文件并不试图改变或更新这些信息性的内容，而只是专注于更新标准化的协议规范。

This document preserves references to the documentation containing the important explanations and rationale, where appropriate.  
本文档保留了对包含重要解释和基本原理的文档的引用。

This document is intended to be useful both in checking existing TCP implementations for conformance purposes, as well as in writing new implementations.  
该文档旨在帮助检查现有的 TCP 实现以及编写新实现。

## 介绍

**2.Introduction**

RFC 793 contains a discussion of the TCP design goals and provides examples of its operation, including examples of connection establishment, connection termination, and packet retransmission to repair losses.  
RFC 793 包含了对 TCP 设计目标的讨论，并提供了其操作的示例，包括建立连接、关闭连接以及弥补丢失的数据包重传。

This document describes the basic functionality expected in modern TCP implementations and replaces the protocol specification in RFC 793.  
本文档描述了现代 TCP 实现中预期的基本功能，并替换了 RFC 793 中的协议规范。

It does not replicate or attempt to update the introduction and philosophy content in Sections 1 and 2 of RFC 793.  
它不会复制或尝试更新 RFC 793 第 1 和 2 节中的简介和理念内容。

Other documents are referenced to provide explanations of the theory of operation, rationale, and detailed discussion of design decisions.  
还参考了其他文件，以提供对操作理论、原理的解释，以及对设计决策的详细讨论。

This document only focuses on the normative behavior of the protocol.  
本文档只关注协议的标准行为。

The "TCP Roadmap" [49] provides a more extensive guide to the RFCs that define TCP and describe various important algorithms.
"TCP 路线图" [49] 为定义 TCP 和描述各种重要算法的 RFC 提供了更广泛的指南。

The TCP Roadmap contains sections on strongly encouraged enhancements that improve performance and other aspects of TCP beyond the basic operation specified in this document.  
TCP 路线图包含强烈推荐的增强功能，这些增强功能可以提高 TCP 的性能和其他超出本文档中规定的基本操作的方面。

As one example, implementing congestion control (e.g., [8]) is a TCP requirement, but it is a complex topic on its own and not described in detail in this document, as there are many options and possibilities that do not impact basic interoperability.  
举个例子，实现拥塞控制（例如，[8]）是一项 TCP 要求，但它本身就是一个复杂的主题，并且在本文档中没有详细描述，因为有许多不会影响基本的互操作性的选项和可能性 .

Similarly, most TCP implementations today include the high-performance extensions in [47], but these are not strictly required or discussed in this document.  
类似地，今天的大多数 TCP 实现都包括 [47] 中的高性能扩展，但这些在本文档中并不是严格要求或讨论的。

Multipath considerations for TCP are also specified separately in [59].  
TCP 的多路径注意事项也在 [59] 中单独指定。

A list of changes from RFC 793 is contained in Section 5.  
与 RFC 793 相比的改动清单包含在第 5 节。

### 需求语言

**2.1. Requirements Language**

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 [3] [12] when, and only when, they appear in all capitals, as shown here.  
本文中的关键词 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", 和 "OPTIONAL"，当且仅当它们以大写字母出现时，应按照 BCP 14 [3] [12] 中的描述进行解释，如这里所示。

Each use of RFC 2119 keywords in the document is individually labeled and referenced in Appendix B, which summarizes implementation requirements.  
文档中每次使用 RFC 2119 关键字都在附录 B 中单独标记和引用，附录 B 总结了实现要求。

Sentences using "MUST" are labeled as "MUST-X" with X being a numeric identifier enabling the requirement to be located easily when referenced from Appendix B.  
使用 "MUST" 的句子被标记为 "MUST-X"，X 是一个数字标识符，可以很容易地从附录 B 找到引用的要求。

Similarly, sentences using "SHOULD" are labeled with "SHLD-X", "MAY" with "MAY-X", and "RECOMMENDED" with "REC-X".  
同样地，使用 "SHOULD" 的句子被标记为 "SHLD-X"，"MAY" 被标记为 "MAY-X"，"RECOMMENDED" 被标记为 "REC-X"。

For the purposes of this labeling, "SHOULD NOT" and "MUST NOT" are labeled the same as "SHOULD" and "MUST" instances.  
出于此标签的目的，"SHOULD NOT" 和 "MUST NOT" 的标签与 "SHOULD" 和 "MUST" 实例的标签相同。

### 关键的 TCP 概念

**2.2. Key TCP Concepts**

TCP provides a reliable, in-order, byte-stream service to applications.  
TCP 为应用程序提供可靠、有序的字节流服务。

The application byte-stream is conveyed over the network via TCP segments, with each TCP segment sent as an Internet Protocol (IP) datagram.  
应用程序的字节流通过 TCP 段在网络上传输，每个 TCP 段作为互联网协议 (IP) 数据报发送。

TCP reliability consists of detecting packet losses (via sequence numbers) and errors (via per-segment checksums), as well as correction via retransmission.  
TCP 可靠性包括检测数据包丢失（通过序列号）和错误（通过段校验和），以及通过重传进行纠正。

TCP supports unicast delivery of data.  
TCP 支持单播传输数据。

There are anycast applications that can successfully use TCP without modifications, though there is some risk of instability due to changes of lower-layer forwarding behavior [46].  
有一些任播应用程序可以在不修改的情况下成功地使用 TCP，尽管由于下层转发行为的变化存在一些不稳定的风险 [46]。

TCP is connection oriented, though it does not inherently include a liveness detection capability.  
TCP 是面向连接的，尽管它本身并不包括活跃性检测功能。

Data flow is supported bidirectionally over TCP connections, though applications are free to send data only unidirectionally, if they so choose.  
通过 TCP 连接双向支持数据流，但如果应用程序愿意，它们可以自由地仅单向发送数据。

TCP uses port numbers to identify application services and to multiplex distinct flows between hosts.  
TCP 使用端口号来识别应用程序服务并在主机之间复用不同的流。

A more detailed description of TCP features compared to other transport protocols can be found in Section 3.1 of [52].  
与其他传输协议相比，TCP 功能的更详细描述可以在 [52] 的第 3.1 节中找到。

Further description of the motivations for developing TCP and its role in the Internet protocol stack can be found in Section 2 of [16] and earlier versions of the TCP specification.  
关于开发 TCP 的动机和它在互联网协议栈中的作用的更多描述，可以在[16]的第 2 节和早期版本的 TCP 规范中找到。

## 功能规范

**3.Functional Specification**

### 头部格式

**3.1. Header Format**

TCP segments are sent as internet datagrams.  
TCP 段作为网络数据报发送。

The Internet Protocol (IP) header carries several information fields, including the source and destination host addresses [1] [13].
网际互联协议 (IP) 报头携带多个信息字段，包括源和目标主机地址 [1] [13]。

A TCP header follows the IP headers, supplying information specific to TCP.  
TCP 头部跟在 IP 头部之后，提供特定于 TCP 的信息。

This division allows for the existence of host-level protocols other than TCP.  
这种划分允许存在除 TCP 之外的主机级协议。

In the early development of the Internet suite of protocols, the IP header fields had been a part of TCP.  
在 Internet 协议套件的早期开发中，IP 报头字段一直是 TCP 的一部分。

This document describes TCP, which uses TCP headers.  
本文档描述了使用 TCP 头部的 TCP。

A TCP header, followed by any user data in the segment, is formatted as follows, using the style from [66]:  
在段中，TCP 头部后面是任意用户数据，格式如下，使用 [66] 中的样式：

{{< center >}}

```
 0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |       Destination Port        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data |       |C|E|U|A|P|R|S|F|                               |
   | Offset| Rsrvd |W|C|R|C|S|S|Y|I|            Window             |
   |       |       |R|E|G|K|H|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           [Options]                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               :
   :                             Data                              :
   :                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

Note that one tick mark represents one bit position.  
注意：一个刻度线代表一个比特位。

Figure 1: TCP Header Format  
图 1：TCP 头部格式

{{< /center >}}

where:  
其中：

**Source Port**: 16 bits  
{{< block-indent >}}
The source port number.  
源端口号
{{< /block-indent >}}

**Destination Port**: 16 bits  
{{< block-indent >}}
The destination port number.  
目标端口号
{{< /block-indent >}}

**Sequence Number**: 32 bits  
{{< block-indent >}}
The sequence number of the first data octet in this segment (except when SYN is present).  
该段数据中第一个字节的序列号（有 SYN 标志除外）。  
If SYN is set, the sequence number is the initial sequence number (ISN) and the first data octet is ISN+1.  
如果设置了 SYN，则序列号是初始序列号 (ISN)，第一个字节数据是 ISN+1。
{{< /block-indent >}}

**Acknowledgment Number**: 32 bits
{{< block-indent >}}
If the ACK control bit is set, this field contains the value of the next sequence number the sender of the segment is expecting to receive. Once a connection is established, this is always sent.  
如果设置了 ACK 标志，这个字段表示发送者期望收到的下一个序列号的值。一旦建立了连接，一直会发送这个字段。
{{< /block-indent >}}

**Data Offset (DOffset)**: 4 bits  
{{< block-indent >}}  
The number of 32 bit words in the TCP Header. This indicates where the data begins. The TCP header (even one including options) is an integer multiple of 32 bits long.  
这个数表示 TCP 头部的长度有多少个 32 bit，表示真正数据开始的位置。TCP 头部（即使包括选项部分）的长度是 32 bit 的整数倍。
{{< /block-indent >}}

**Reserved (Rsrvd)**: 4 bits  
{{< block-indent >}}
A set of control bits reserved for future use. Must be zero in generated segments and must be ignored in received segments if the corresponding future features are not implemented by the sending or receiving host.  
为将来使用而保留的一组控制位。如果发送或接收主机未实现相应的未来功能，则在生成的段中必须为零，并且在接收的段中必须忽略。
{{< /block-indent >}}

**Control bits**:  
{{< block-indent >}}
The control bits are also known as "flags".  
控制位也称为 "标志"。

Assignment is managed by IANA from the "TCP Header Flags" registry [62].  
由 IANA 从 "TCP Header Flags" 注册表 [62] 中管理分配。

The currently assigned control bits are CWR, ECE, URG, ACK, PSH, RST, SYN, and FIN.  
目前分配的控制位是 CWR、ECE、URG、ACK、PSH、RST、SYN 和 FIN。

CWR: 1 bit

Congestion Window Reduced (see [6]).  
减少拥塞窗口（参见 [6]）。

ECE: 1 bit

ECN-Echo (see [6]).  
显式拥塞通知回应(参见 [6]).

URG: 1 bit

Urgent pointer field is significant.  
紧急指针字段很重要。

ACK: 1 bit

Acknowledgment field is significant.  
确认字段很重要。

PSH: 1 bit

Push function (see the Send Call description in Section 3.9.1).  
推送功能（参见第 3.9.1 节中的 Send 调用说明）。

RST: 1 bit

Reset the connection.  
重置连接。

SYN: 1 bit

Synchronize sequence numbers.  
同步序列号。

FIN: 1 bit

No more data from sender.  
发送者没有更多数据。

{{< /block-indent >}}

**Window**: 16 bits
{{< block-indent >}}
The number of data octets beginning with the one indicated in the acknowledgment field which the sender of this segment is willing to accept.  
从确认序号开始，发送方可以接收的字节数。

The value is shifted when the window scaling extension is used [47].  
当使用窗口缩放扩展时，该值会发生变化 [47]。

The window size MUST be treated as an unsigned number, or else large window sizes will appear like negative windows and TCP will not work (MUST-1).  
窗口大小必须被视为无符号的数字，否则大的窗口大小将出现负窗口，TCP 将无法工作（MUST-1）。

It is RECOMMENDED that implementations will reserve 32-bit fields for the send and receive window sizes in the connection record and do all window computations with 32 bits (REC-1).  
建议实现在连接记录中为发送和接收窗口大小保留 32 位字段，并以 32 位进行所有窗口计算（REC-1）。
{{< /block-indent >}}

**Checksum**: 16 bits  
{{< block-indent >}}
The checksum field is the 16 bit one's complement of the one's complement sum of all 16 bit words in the header and text.  
检验和是头部和数据部分所有分割成 16 bit 数的经过二进制反码求和得到的数。

The checksum computation needs to ensure the 16-bit alignment of the data being summed.  
校验和计算需要确保求和的数据 16 位对齐。

If a segment contains an odd number of header and text octets, alignment can be achieved by padding the last octet with zeros on its right to form a 16-bit word for checksum purposes.  
如果段的头部和内容是奇数个字节，可以通过在最后一个字节的右侧填充零来对齐，以组成一个 16 位字来实现校验和。

The pad is not transmitted as part of the segment.  
填充不会作为 TCP 段的一部分进行传输。

While computing the checksum, the checksum field itself is replaced with zeros.  
在计算校验和时，校验和字段本身用零替换。

The checksum also covers a pseudo-header (Figure 2) conceptually prefixed to the TCP header.  
校验和还包括了一个伪头部（图 2），在概念上作为 TCP 头部的前缀。

The pseudo-header is 96 bits for IPv4 and 320 bits for IPv6.  
伪头部在 IPv4 下是 96 位，在 IPv6 下是 320 位。

Including the pseudo-header in the checksum gives the TCP connection protection against misrouted segments.  
在校验和中包含伪标头可以避免 TCP 连接错误路由的段。

This information is carried in IP headers and is transferred across the TCP/network interface in the arguments or results of calls by the TCP implementation on the IP layer.  
这些信息包含在 IP 头部中，并在 TCP/网络 接口上通过 TCP 对 IP 层的调用的参数或结果进行传输。

{{< /block-indent >}}

{{< center >}}

```
+--------+--------+--------+--------+
|           Source Address          |
+--------+--------+--------+--------+
|         Destination Address       |
+--------+--------+--------+--------+
|  zero  |  PTCL  |    TCP Length   |
+--------+--------+--------+--------+
```

Figure 2: IPv4 Pseudo-header  
图 2：IPv4 伪头部

{{< /center >}}

{{< block-indent >}}
Pseudo-header components for IPv4:  
IPv4 的伪头组成:

Source Address: the IPv4 source address in network byte order  
Source Address: 网络字节序的 IPv4 源地址

Destination Address: the IPv4 destination address in network byte order  
Destination Address: 网络字节序的 IPv4 目的地址

zero: bits set to zero  
zero: 全部设置为 0

PTCL: the protocol number from the IP header  
PTCL: 来自 IP 头部的协议号

TCP Length: the TCP header length plus the data length in octets (this is not an explicitly transmitted quantity but is computed), and it does not count the 12 octets of the pseudo-header.
TCP Length: TCP 报头加上数据部分的长度，单位是字节（这不是一个明确的传输量，而是计算出来的），并且不包括 12 字节的伪头部。

For IPv6, the pseudo-header is defined in Section 8.1 of RFC 8200 [13] and contains the IPv6 Source Address and Destination Address, an Upper-Layer Packet Length (a 32-bit value otherwise equivalent to TCP Length in the IPv4 pseudo-header), three bytes of zero padding, and a Next Header value, which differs from the IPv6 header value if there are extension headers present between IPv6 and TCP.  
对于 IPv6，伪标头在 RFC 8200 [13] 的第 8.1 节中定义，包含 IPv6 源地址和目标地址、上层数据包长度（一个 32 位值，否则等同于 IPv4 伪标头中的 TCP 长度） header），三个字节的零填充和一个 Next Header 值，如果 IPv6 和 TCP 之间存在扩展头部，则该值与 IPv6 头部值不同。

The TCP checksum is never optional. The sender MUST generate it (MUST-2) and the receiver MUST check it (MUST-3).  
TCP 校验和永远不是可选的，发送方必须生成它（MUST-2）并且接收方必须检查它（MUST-3）。

{{< /block-indent >}}

**Urgent Pointer**: 16 bits  
{{< block-indent >}}
This field communicates the current value of the urgent pointer as a positive offset from the sequence number in this segment.  
这个字段表示当前紧急指针距离本段中序列号的正偏移。

The urgent pointer points to the sequence number of the octet following the urgent data.  
紧急指针指向紧急数据后的字节的序列号。

This field should only be interpreted in segments with the URG control bit set.  
这个字段只应在设置了 URG 标志的 TCP 段中使用。
{{< /block-indent >}}

**Options**:  
{{< block-indent >}}
[TCP Option]; size(Options) == (DOffset-5)\*32; present only when DOffset > 5.  
[TCP Option]; size(Options) == (DOffset-5)\*32; 只有在 DOffset > 5 时存在.

Note that this size expression also includes any padding trailing the actual options present.  
注意，这个大小表达式还包括在实际选项后面的任何填充。

Options may occupy space at the end of the TCP header and are a multiple of 8 bits in length.  
选项部分可能占用 TCP 头的末尾的空间，长度为 8bit 的倍数。

All options are included in the checksum.  
选项部分也包括在检验和的计算中。

An option may begin on any octet boundary.  
选项部分可以从任何字节边界上开始。

There are two cases for the format of an option:  
选项的格式有两种情况：

- Case 1: A single octet of option-kind.  
  情况 1: 一个字节的选项类型。
- Case 2: An octet of option-kind (Kind), an octet of option-length, and the actual option-data octets.  
  情况 2: 一个字节的选项类型(Kind)、一个字节的选项长度和真正选项数据。

The option-length counts the two octets of option-kind and option-length as well as the option-data octets.  
选项长度包括选项种类和选项长度的两个字节，以及选项数据的字节数。

Note that the list of options may be shorter than the Data Offset field might imply.  
注意：选项列表可能比数据偏移字段要短。

The content of the header beyond the End of Option List Option MUST be header padding of zeros (MUST-69).  
选项列表选项结束后的头部内容必须用零填充（MUST-69）。

The list of all currently defined options is managed by IANA [62], and each option is defined in other RFCs, as indicated there.  
所有当前定义的选项列表由 IANA [62] 管理，每个选项都在其他 RFC 中定义，如此处所示。

That set includes experimental options that can be extended to support multiple concurrent usages [45].  
该列表包括可以扩展以支持多个并发使用的实验选项 [45]。

A given TCP implementation can support any currently defined options, but the following options MUST be supported (MUST-4 -- note Maximum Segment Size Option support is also part of MUST-14 in Section 3.7.1):  
给定的 TCP 实现可以支持任何当前定义的选项，但必须支持以下选项（MUST-4 —— 注意最大段大小选项支持也是第 3.7.1 节中 MUST-14 的一部分）：

{{< /block-indent >}}
{{< center >}}

```
+======+========+============================+
| Kind | Length | Meaning                    |
+======+========+============================+
| 0    | -      | End of Option List Option. |
+------+--------+----------------------------+
| 1    | -      | No-Operation.              |
+------+--------+----------------------------+
| 2    | 4      | Maximum Segment Size.      |
+------+--------+----------------------------+
```

Table 1: Mandatory Option Set  
表 1: 强制性选项列表
{{< /center >}}

{{< block-indent >}}
These options are specified in detail in Section 3.2.  
这些选项在第 3.2 节中有详细说明。

A TCP implementation MUST be able to receive a TCP Option in any segment (MUST-5).  
TCP 实现必须能够在任何段中接收 TCP 选项（MUST-5）。

A TCP implementation MUST (MUST-6) ignore without error any TCP Option it does not implement, assuming that the option has a length field.  
TCP 实现必须（MUST-6）无误地忽略它没有实现的任何 TCP 选项，假设该选项有一个长度字段。

All TCP Options except End of Option List Option (EOL) and No-Operation (NOP) MUST have length fields, including all future options (MUST-68).  
除了选项列表结束选项（EOL）和无操作（NOP）之外的所有 TCP 选项必须有长度字段，包括所有未来选项（MUST-68）。

TCP implementations MUST be prepared to handle an illegal option length (e.g., zero); a suggested procedure is to reset the connection and log the error cause (MUST-7).  
TCP 实现必须准备好处理非法选项长度（例如，0），建议的处理是重置连接并记录错误原因 (MUST-7)。

Note: There is ongoing work to extend the space available for TCP Options, such as [65].  
注意：目前正在进行扩展 TCP 选项可用空间的工作，例如 [65]。

{{< /block-indent >}}

**Data**: variable length

{{< block-indent >}}
User data carried by the TCP segment.  
TCP 段中携带的用户数据。
{{< /block-indent >}}

### 具体的选项定义

**3.2. Specific Option Definitions**

A TCP Option, in the mandatory option set, is one of an End of Option List Option, a No-Operation Option, or a Maximum Segment Size Option.
TCP 选项，在强制性选项列表中，是选项列表结束选项、无操作选项或最大段大小选项中的一个。

An End of Option List Option is formatted as follows:  
选项列表结束选项的格式如下：

```
 0
 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+
|       0       |
+-+-+-+-+-+-+-+-+
```

where:  
其中：

Kind: 1 byte; Kind == 0.

This option code indicates the end of the option list.  
该选项代码表示选项列表的结尾。

This might not coincide with the end of the TCP header according to the Data Offset field.  
根据数据偏移字段，这可能与 TCP 头部的结尾不一致。

This is used at the end of all options, not the end of each option, and need only be used if the end of the options would not otherwise coincide with the end of the TCP header.  
这用于所有选项的末尾，而不是每个选项的末尾，并且仅在选项末尾与 TCP 标头末尾不一致时才需要使用。

A No-Operation Option is formatted as follows:  
无操作选项的格式如下：

```
 0
 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+
|       1       |
+-+-+-+-+-+-+-+-+
```

where:  
其中：

Kind: 1 byte; Kind == 1.

This option code can be used between options, for example, to align the beginning of a subsequent option on a word boundary.  
该选项代码可用于选项之间，例如，将后续选项的开头对齐到字边界上。

There is no guarantee that senders will use this option, so receivers MUST be prepared to process options even if they do not begin on a word boundary (MUST-64).  
不能保证发送方会使用这个选项，因此接收方必须准备好处理选项，即使它们不是从字边界开始的（MUST-64）。

A Maximum Segment Size Option is formatted as follows:  
最大段大小选项的格式如下：

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       2       |     Length    |   Maximum Segment Size (MSS)  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

where:  
其中：

Kind: 1 byte; Kind == 2.

If this option is present, then it communicates the maximum receive segment size at the TCP endpoint that sends this segment.  
如果存在此选项，则它会在发送此段的 TCP 端传达最大接收段大小。

This value is limited by the IP reassembly limit.  
该值受 IP 重组限制。

This field may be sent in the initial connection request (i.e., in segments with the SYN control bit set) and MUST NOT be sent in other segments (MUST-65).  
该字段可以在初始连接请求中发送（即，在设置了 SYN 控制位的段中）并且不得在其他段中发送（MUST-65）。

If this option is not used, any segment size is allowed.  
如果不使用此选项，则允许任何段大小。

A more complete description of this option is provided in Section 3.7.1.  
第 3.7.1 节提供了此选项的更完整描述。

Length: 1 byte; Length == 4.

Length of the option in bytes.  
选项的长度（以字节为单位）。

Maximum Segment Size (MSS): 2 bytes.

The maximum receive segment size at the TCP endpoint that sends this segment.  
发送该段的 TCP 端的最大接收段大小。

#### 其他常用选项

**3.2.1. Other Common Options**

Additional RFCs define some other commonly used options that are recommended to implement for high performance but are not necessary for basic TCP interoperability.  
其他 RFC 定义了一些其他建议为实现高性能而实现的常用选项，但对于基本 TCP 互操作性而言不是必需的。

These are the TCP Selective Acknowledgment (SACK) Option [22] [26], TCP Timestamp (TS) Option [47], and TCP Window Scale (WS) Option [47].  
这些是 TCP 选择性确认 (SACK) 选项 [22] [26]、TCP 时间戳 (TS) 选项 [47] 和 TCP 窗口比例 (WS) 选项 [47]。

#### 实验性 TCP 选项

**3.2.2. Experimental TCP Options**

Experimental TCP Option values are defined in [30], and [45] describes the current recommended usage for these experimental values.  
实验性 TCP 选项值在 [30] 中定义，[45] 描述了这些实验值的当前推荐用法。

### 术语概述

**3.3. TCP Terminology Overview**

This section includes an overview of key terms needed to understand the detailed protocol operation in the rest of the document.  
本节概述了理解文档其余部分详细协议操作所需的关键术语。

There is a glossary of terms in Section 4.  
第 4 节中有术语表。

#### 关键连接状态变量

**3.3.1. Key Connection State Variables**

Before we can discuss the operation of the TCP implementation in detail, we need to introduce some detailed terminology.  
在我们详细讨论 TCP 实现的操作之前，我们需要介绍一些详细的术语。

The maintenance of a TCP connection requires maintaining state for several variables.  
TCP 连接的维护需要维护多个变量的状态。

We conceive of these variables being stored in a connection record called a Transmission Control Block or TCB.  
我们设想将这些变量存储在称为传输控制块或 TCB 的连接记录中。

Among the variables stored in the TCB are the local and remote IP addresses and port numbers, the IP security level, and compartment of the connection (see Appendix A.1), pointers to the user's send and receive buffers, pointers to the retransmit queue and to the current segment.  
存储在 TCB 中的变量包括本地和远程 IP 地址和端口号、IP 安全级别和连接区段（参见附录 A.1）、指向用户发送和接收缓冲区的指针、指向重传队列的指针和当前段。

In addition, several variables relating to the send and receive sequence numbers are stored in the TCB.  
此外，几个与发送和接收序列号相关的变量存储在 TCB 中。

{{< center >}}

```
+==========+=====================================================+
| Variable | Description                                         |
+==========+=====================================================+
| SND.UNA  | send unacknowledged                                 |
+----------+-----------------------------------------------------+
| SND.NXT  | send next                                           |
+----------+-----------------------------------------------------+
| SND.WND  | send window                                         |
+----------+-----------------------------------------------------+
| SND.UP   | send urgent pointer                                 |
+----------+-----------------------------------------------------+
| SND.WL1  | segment sequence number used for last window update |
+----------+-----------------------------------------------------+
| SND.WL2  | segment acknowledgment number used for last window  |
|          | update                                              |
+----------+-----------------------------------------------------+
| ISS      | initial send sequence number                        |
+----------+-----------------------------------------------------+
```

Table 2: Send Sequence Variables  
表 2: 发送序列变量

```
+==========+=================================+
| Variable | Description                     |
+==========+=================================+
| RCV.NXT  | receive next                    |
+----------+---------------------------------+
| RCV.WND  | receive window                  |
+----------+---------------------------------+
| RCV.UP   | receive urgent pointer          |
+----------+---------------------------------+
| IRS      | initial receive sequence number |
+----------+---------------------------------+
```

Table 3: Receive Sequence Variables  
表 3: 接收序列变量
{{< /center >}}

The following diagrams may help to relate some of these variables to the sequence space.  
下图可能有助于将其中一些变量与序列空间联系起来。

{{< center >}}

```
    1         2          3          4
----------|----------|----------|----------
SND.UNA    SND.NXT    SND.UNA
                     +SND.WND

1 - old sequence numbers which have been acknowledged
2 - sequence numbers of unacknowledged data
3 - sequence numbers allowed for new data transmission
4 - future sequence numbers which are not yet allowed
```

Figure 3: Send Sequence Space  
图 3：发送序列变量

{{< /center >}}

The send window is the portion of the sequence space labeled 3 in figure 3.  
发送窗口是图 3 中标记为 3 的序列空间的一部分。

{{< center >}}

```
  1          2          3
----------|----------|----------
RCV.NXT    RCV.NXT
          +RCV.WND

1 - old sequence numbers which have been acknowledged
2 - sequence numbers allowed for new reception
3 - future sequence numbers which are not yet allowed
```

Figure 4: Receive Sequence Space  
图 4：接收序列变量

{{< /center >}}

The receive window is the portion of the sequence space labeled 2 in figure 4.  
接收窗口是图 4 中标记为 2 的序列空间的一部分。

There are also some variables used frequently in the discussion that take their values from the fields of the current segment.  
还有一些在讨论中经常使用的变量，它们的值来自当前段的字段。

{{< center >}}

```
+==========+===============================+
| Variable | Description                   |
+==========+===============================+
| SEG.SEQ  | segment sequence number       |
+----------+-------------------------------+
| SEG.ACK  | segment acknowledgment number |
+----------+-------------------------------+
| SEG.LEN  | segment length                |
+----------+-------------------------------+
| SEG.WND  | segment window                |
+----------+-------------------------------+
| SEG.UP   | segment urgent pointer        |
+----------+-------------------------------+
```

Table 4: Current Segment Variables  
表 4：当前段变量

{{< /center >}}

#### 状态机概述

**3.3.2. State Machine Overview**

A connection progresses through a series of states during its lifetime.  
一个连接在其生命周期中会经历一系列的状态。

The states are: LISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT, and the fictional state CLOSED.  
这些状态是：LISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT 以及虚构的状态 CLOSED。

CLOSED is fictional because it represents the state when there is no TCB, and therefore, no connection.  
CLOSED 是虚构的，因为它代表了没有 TCB 的状态，也就是没有连接。

Briefly the meanings of the states are:  
简而言之，这些状态的含义是：

**LISTEN** - represents waiting for a connection request from any remote TCP peer and port.  
**LISTEN** - 表示等待来自任何远程对等 TCP 和端口的连接请求。

**SYN-SENT** - represents waiting for a matching connection request after having sent a connection request.  
**SYN-SENT** - 表示在发送了一个连接请求后等待一个匹配的连接请求。

**SYN-RECEIVED** - represents waiting for a confirming connection request acknowledgment after having both received and sent a connection request.  
**SYN-RECEIVED** - 表示在收到和发送连接请求后，等待确认连接请求的确认。

**ESTABLISHED** - represents an open connection, data received can be delivered to the user. The normal state for the data transfer phase of the connection.  
**ESTABLISHED** - 代表一个已建立的连接，收到的数据可以传递给用户，是连接数据传输阶段的正常状态。

**FIN-WAIT-1** - represents waiting for a connection termination request from the remote TCP peer, or an acknowledgment of the connection termination request previously sent.  
**FIN-WAIT-1** - 表示等待来自远程对等 TCP 的连接终止请求，或等待之前发送的终止连接请求的确认。

**FIN-WAIT-2** - represents waiting for a connection termination request from the remote TCP peer.  
**FIN-WAIT-2** - 表示等待来自远程对等 TCP 的连接终止请求。

**CLOSE-WAIT** - represents waiting for a connection termination request from the local user.  
**CLOSE-WAIT** - 表示等待本端用户的连接终止请求。

**CLOSING** - represents waiting for a connection termination request acknowledgment from the remote TCP peer.  
**CLOSING** - 表示等待来自远程对等 TCP 的连接终止请求确认。

**LAST-ACK** - represents waiting for an acknowledgment of the connection termination request previously sent to the remote TCP peer(this termination request sent to the remote TCP peer already included an acknowledgment of the termination request sent from the remote TCP peer).
**LAST-ACK** - 表示等待对先前发送到远程对等 TCP 的连接终止请求的确认（发送给远程对等 TCP 的这个终止请求已经包括了远程对等 TCP 发送的终止请求的确认）。

**TIME-WAIT** - represents waiting for enough time to pass to be sure the remote TCP peer received the acknowledgment of its connection termination request and to avoid new connections being impacted by delayed segments from previous connections.  
**TIME-WAIT** - 表示等待足够的时间通过以确保远程对等 TCP 收到其连接终止请求的确认，并避免新连接受到先前连接的延迟段的影响。

**CLOSED** - represents no connection state at all.  
**CLOSED** - 表示没有连接的状态。

A TCP connection progresses from one state to another in response to events.  
TCP 连接根据事件从一个状态转换到另一个状态。

The events are the user calls, OPEN, SEND, RECEIVE, CLOSE, ABORT, and STATUS; the incoming segments, particularly those containing the SYN and FIN flags; and timeouts.  
这些事件是用户调用 OPEN、SEND、RECEIVE、CLOSE、ABORT 和 STATUS；收到 TCP 段，特别是包含 SYN 和 FIN 标志的段；以及超时。

The OPEN call specifies whether connection establishment is to be actively pursued, or to be passively waited for.  
OPEN 调用指定是主动要求连接建立，还是被动等待。

A passive OPEN request means that the process wants to accept incoming connection requests, in contrast to an active OPEN attempting to initiate a connection.  
被动 OPEN 请求意味着进程想要接受传入的连接请求，这与主动 OPEN 尝试启动连接相反。

The state diagram in Figure 5 illustrates only state changes, together with the causing events and resulting actions, but addresses neither error conditions nor actions that are not connected with state changes.  
图 5 中的状态图只说明了状态的变化，以及引起的事件和触发的行为，但既没有涉及错误条件，也没有涉及与状态变化无关的行为。

In a later section, more detail is offered with respect to the reaction of the TCP implementation to events.  
在后面的章节中，将提供关于 TCP 对事件响应的更多细节。

Some state names are abbreviated or hyphenated differently in the diagram from how they appear elsewhere in the document.

NOTA BENE: This diagram is only a summary and must not be taken as the total specification. Many details are not included.  
注意：此图只是一个摘要，不能作为全部规范，许多细节未包括在内。

```
                               +---------+ ---------\      active OPEN
                               |  CLOSED |            \    -----------
                               +---------+<---------\   \   create TCB
                                 |     ^              \   \  snd SYN
                    passive OPEN |     |   CLOSE        \   \
                    ------------ |     | ----------       \   \
                     create TCB  |     | delete TCB         \   \
                                 V     |                      \   \
             rcv RST (note 1)  +---------+            CLOSE    |    \
          -------------------->|  LISTEN |          ---------- |     |
         /                     +---------+          delete TCB |     |
        /           rcv SYN      |     |     SEND              |     |
       /           -----------   |     |    -------            |     V
   +--------+      snd SYN,ACK  /       \   snd SYN          +--------+
   |        |<-----------------           ------------------>|        |
   |  SYN   |                    rcv SYN                     |  SYN   |
   |  RCVD  |<-----------------------------------------------|  SENT  |
   |        |                  snd SYN,ACK                   |        |
   |        |------------------           -------------------|        |
   +--------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +--------+
      |         --------------   |     |   -----------
      |                x         |     |     snd ACK
      |                          V     V
      |  CLOSE                 +---------+
      | -------                |  ESTAB  |
      | snd FIN                +---------+
      |                 CLOSE    |     |    rcv FIN
      V                -------   |     |    -------
   +---------+         snd FIN  /       \   snd ACK         +---------+
   |  FIN    |<----------------          ------------------>|  CLOSE  |
   | WAIT-1  |------------------                            |   WAIT  |
   +---------+          rcv FIN  \                          +---------+
     | rcv ACK of FIN   -------   |                          CLOSE  |
     | --------------   snd ACK   |                         ------- |
     V        x                   V                         snd FIN V
   +---------+               +---------+                    +---------+
   |FINWAIT-2|               | CLOSING |                    | LAST-ACK|
   +---------+               +---------+                    +---------+
     |              rcv ACK of FIN |                 rcv ACK of FIN |
     |  rcv FIN     -------------- |    Timeout=2MSL -------------- |
     |  -------            x       V    ------------        x       V
      \ snd ACK              +---------+delete TCB          +---------+
        -------------------->|TIME-WAIT|------------------->| CLOSED  |
                             +---------+                    +---------+
```

{{< center >}}
Figure 5: TCP Connection State Diagram  
图 5：TCP 连接状态图
{{< /center >}}

The following notes apply to Figure 5:  
以下注释适用于图 5：

- Note 1: The transition from SYN-RECEIVED to LISTEN on receiving a RST is conditional on having reached SYN-RECEIVED after a passive OPEN.  
  在接收到 RST 时从 SYN-RECEIVED 到 LISTEN 的转换以在被动 OPEN 之后达到 SYN-RECEIVED 为条件。

- Note 2: The figure omits a transition from FIN-WAIT-1 to TIME-WAIT if a FIN is received and the local FIN is also acknowledged.  
  如果收到 FIN 并且本地 FIN 也得到确认，则图中省略了从 FIN-WAIT-1 到 TIME-WAIT 的转换。

- Note 3: A RST can be sent from any state with a corresponding transition to TIME-WAIT (see [70] for rationale).  
  RST 可以从任何状态发送，并相应地转换为 TIME-WAIT（基本原理参见 [70]）。

  These transitions are not explicitly shown; otherwise, the diagram would become very difficult to read.  
  这些转换没有明确显示；否则，图表将变得很难阅读。

  Similarly, receipt of a RST from any state results in a transition to LISTEN or CLOSED, though this is also omitted from the diagram for legibility.  
  类似地，从任何状态接收到 RST 都会导致转换为 LISTEN 或 CLOSED，尽管为了便于阅读，图中也省略了这一点。

### 序列号

**3.4. Sequence Numbers**

A fundamental notion in the design is that every octet of data sent over a TCP connection has a sequence number.  
TCP 设计中的一个基本概念是，通过 TCP 连接发送的每个字节的数据都有一个序列号。

Since every octet is sequenced, each of them can be acknowledged.  
由于每个字节都是有顺序的，所以每个字节都可以被确认。

The acknowledgment mechanism employed is cumulative so that an acknowledgment of sequence number X indicates that all octets up to but not including X have been received.  
TCP 所采用的确认机制是累积性的，因此序列号为 X 的确认表示已经收到了之前但不包括 X 的所有字节。

This mechanism allows for straightforward duplicate detection in the presence of retransmission.  
这种机制使得在存在重传的情况下可以直接进行重复检测。

The numbering scheme of octets within a segment is as follows: the first data octet immediately following the header is the lowest numbered, and the following octets are numbered consecutively.  
段内字节的编号方案如下：紧跟在头部之后的第一个字节数据编号最小，随后的字节连续编号。

It is essential to remember that the actual sequence number space is finite, though large.  
需要记住，实际的序列号范围是有限的，尽管很大。

This space ranges from 0 to 2\*\*32 - 1.  
这个范围是从 0 到 2\*\*32-1 。

Since the space is finite, all arithmetic dealing with sequence numbers must be performed modulo 2\*\*32.  
由于范围是有限的，所有处理序列号的运算都必须模 2\*\*32。

This unsigned arithmetic preserves the relationship of sequence numbers as they cycle from 2\*\*32 - 1 to 0 again.  
这种无符号算术保留了序列号之间的关系，因为它们从 2\*\*32-1 再重新到 0。

There are some subtleties to computer modulo arithmetic, so great care should be taken in programming the comparison of such values.  
计算机模运算有一些细微的差异，所以在编程比较这些值时应该非常小心。

The symbol "=<" means "less than or equal" (modulo 2\*\*32).  
符号 "=<" 表示 "小于或等于" (模 2\*\*32)。

The typical kinds of sequence number comparisons that the TCP implementation must perform include:  
TCP 实现中需要操作的典型的序列号比较包括：

(a) Determining that an acknowledgment refers to some sequence number sent but not yet acknowledged.  
(a) 确定一个确认是对应某个已发送但尚未确认的序列号。

(b) Determining that all sequence numbers occupied by a segment have been acknowledged (e.g., to remove the segment from a retransmission queue).  
(b) 确定 TCP 段所占用的所有序列号都已被确认（例如，从重传队列中删除该 TCP 段）。

(c) Determining that an incoming segment contains sequence numbers which are expected (i.e., that the segment "overlaps" the receive window).  
(c) 确定一个收到的 TCP 段包含预期的序列号（即该 TCP 段与接收窗口"重叠"）。

In response to sending data, the TCP endpoint will receive acknowledgments.  
TCP 将收到确认作为对发送数据的响应。

The following comparisons are needed to process the acknowledgments.  
在处理确认时需要进行以下比较。

SND.UNA = oldest unacknowledged sequence number  
SND.UNA = 最早的未确认的序列号

SND.NXT = next sequence number to be sent  
SND.NXT = 下一个要发送的序列号

SEG.ACK = acknowledgment from the receiving TCP peer (next sequence number expected by the receiving TCP)  
SEG.ACK = 来自接收 TCP 的确认（接收 TCP 所期望的下一个序列号）。

SEG.SEQ = first sequence number of a segment  
SEG.SEQ = TCP 段的第一个序列号

SEG.LEN = the number of octets occupied by the data in the segment (counting SYN and FIN)  
SEG.LEN = 段落中的数据所占的字节数 (包括 SYN 和 FIN)

SEG.SEQ+SEG.LEN-1 = last sequence number of a segment  
SEG.SEQ+SEG.LEN-1 = TCP 段的最后一个序列号

A new acknowledgment (called an "acceptable ack"), is one for which the inequality below holds:  
一个新的确认（即 "可接受的确认"），会满足以下不等式。  
SND.UNA < SEG.ACK =< SND.NXT

A segment on the retransmission queue is fully acknowledged if the sum of its sequence number and length is less than the acknowledgment value in the incoming segment.  
如果重传队列中的一个 TCP 段的序列号和长度之和小于收到段的确认值，则该段被完全确认。

When data is received the following comparisons are needed:  
当收到数据时，需要进行以下比较：

RCV.NXT = next sequence number expected on an incoming segments, and is the left or lower edge of the receive window  
RCV.NXT = 下一个预期收到 TCP 段的序列号，也是接收窗口的左边界或下限。

RCV.NXT+RCV.WND-1 = last sequence number expected on an incoming segment, and is the right or upper edge of the receive window  
RCV.NXT+RCV.WND-1 = 最后一个预期收到 TCP 段的序列号，也是接收窗口的右边界或上限。

SEG.SEQ = first sequence number occupied by the incoming segment  
SEG.SEQ = 收到 TCP 段的第一个序列号

SEG.SEQ+SEG.LEN-1 = last sequence number occupied by the incoming segment  
SEG.SEQ+SEG.LEN-1 = 收到 TCP 段的最后一个序列号

A segment is judged to occupy a portion of valid receive sequence space if  
在下列情况下，一个 TCP 段被判断为占据了有效接收序列范围的一部分

RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND

or  
或

RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND

The first part of this test checks to see if the beginning of the segment falls in the window, the second part of the test checks to see if the end of the segment falls in the window; if the segment passes either part of the test it contains data in the window.  
该测试的第一部分检查段的开头是否落在窗口中，测试的第二部分检查段的结尾是否落在窗口中；如果该段通过了测试的任何一部分，则它在窗口中包含数据。

Actually, it is a little more complicated than this. Due to zero windows and zero-length segments, we have four cases for the acceptability of an incoming segment:  
实际上，情况比这更复杂一些。由于零窗口和零长度的 TCP 段，我们有四种情况来判断一个收到的 TCP 段是否可接受：

{{< center >}}

```
+=========+=========+======================================+
| Segment | Receive | Test                                 |
| Length  | Window  |                                      |
+=========+=========+======================================+
| 0       | 0       | SEG.SEQ = RCV.NXT                    |
+---------+---------+--------------------------------------+
| 0       | >0      | RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND |
+---------+---------+--------------------------------------+
| >0      | 0       | not acceptable                       |
+---------+---------+--------------------------------------+
| >0      | >0      | RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND |
|         |         |                                      |
|         |         | or                                   |
|         |         |                                      |
|         |         | RCV.NXT =< SEG.SEQ+SEG.LEN-1 <       |
|         |         | RCV.NXT+RCV.WND                      |
+---------+---------+--------------------------------------+
```

Table 5: Segment Acceptability Tests  
表 5：段可接受性测试
{{< /center >}}

Note that when the receive window is zero no segments should be acceptable except ACK segments.  
请注意，当接收窗口为零时，除了 ACK 段外，不应接受其他 TCP 段。

Thus, it is possible for a TCP implementation to maintain a zero receive window while transmitting data and receiving ACKs.  
因此，TCP 实现应该有可能在传输数据和接收 ACK 的同时保持一个零接收窗口。

A TCP receiver MUST process the RST and URG fields of all incoming segments, even when the receive window is zero (MUST-66).
即使接收窗口为零，TCP 也必须处理所有接收段的 RST 和 URG 字段 (MUST-66)。

We have taken advantage of the numbering scheme to protect certain control information as well.
我们还利用了编号方案来保护某些控制信息。

This is achieved by implicitly including some control flags in the sequence space so they can be retransmitted and acknowledged without confusion (i.e., one and only one copy of the control will be acted upon).  
这是通过在序列空间中隐含地包括一些控制标志来实现的，使得它们可以被重发和确认而不会产生混淆(即，将对控制的一个且仅一个副本进行操作)。

Control information is not physically carried in the segment data space.  
控制信息不实际在 TCP 段数据空间中携带。

Consequently, we must adopt rules for implicitly assigning sequence numbers to control.
因此，我们必须采用隐式分配序列号的规则来控制。

The SYN and FIN are the only controls requiring this protection, and these controls are used only at connection opening and closing.  
SYN 和 FIN 是唯一需要这种保护的控制，而且这些控制只在连接打开和关闭时使用。

For sequence number purposes, the SYN is considered to occur before the first actual data octet of the segment in which it occurs, while the FIN is considered to occur after the last actual data octet in a segment in which it occurs.  
就序列号而言，SYN 被认为发生在其所在 TCP 段的实际数据第一个字节之前，而 FIN 被认为发生在其所在段的实际数据的最后一个字节之后。

The segment length (SEG.LEN) includes both data and sequence space-occupying controls.  
TCP 段的长度包括数据和占用序列空间的控制信息。

When a SYN is present then SEG.SEQ is the sequence number of the SYN.  
当存在 SYN 时，SEG.SEQ 是 SYN 的序列号。

#### 初始序列号的选择

**3.4.1. Initial Sequence Number Selection**

A connection is defined by a pair of sockets. Connections can be reused.  
一个连接是由一对套接字确定的，连接可以重复使用。

New instances of a connection will be referred to as incarnations of the connection.  
连接的新实例会用来表示连接。

The problem that arises from this is -- "how does the TCP implementation identify duplicate segments from previous incarnations of the connection?"  
由此产生的问题是 -- "TCP 实现如何识别来自以前连接中的重复段？"

This problem becomes apparent if the connection is being opened and closed in quick succession, or if the connection breaks with loss of memory and is then reestablished.  
如果快速连续地打开和关闭连接，或者如果连接因内存丢失而断开，然后重新建立，则此问题会变得明显。

To support this, the TIME-WAIT state limits the rate of connection reuse, while the initial sequence number selection described below further protects against ambiguity about which incarnation of a connection an incoming packet corresponds to.  
为了支持这一点，TIME-WAIT 状态限制了连接重用的速度，而下面描述的初始序列号选择进一步防止关于接收数据包对应于哪个连接实例的歧义。

To avoid confusion, we must prevent segments from one incarnation of a connection from being used while the same sequence numbers may still be present in the network from an earlier incarnation.  
为了防止出现混乱，我们必须防止使用来自先前连接中有相同序列号的数据段。

We want to assure this even if a TCP endpoint crashes and loses all knowledge of the sequence numbers it has been using.  
我们要保证这一点，即使 TCP 崩溃并失去了它使用的序列号的所有信息。

When new connections are created, an initial sequence number (ISN) generator is employed which selects a new 32 bit ISN.  
当创建新连接时，使用初始序列号(ISN)生成器选择新的 32 位 ISN。

There are security issues that result if an off-path attacker is able to predict or guess ISN values [42].  
如果 off-path attacker 能够预测或猜测 ISN 值，则会出现安全问题 [42]。

TCP initial sequence numbers are generated from a number sequence that monotonically increases until it wraps, known loosely as a "clock".  
TCP 初始序列号是由一个数字序列生成的，该数字序列单调递增，直到它回绕，广泛地称为 "时钟"。

This clock is a 32-bit counter that typically increments at least once every roughly 4 microseconds, although it is neither assumed to be realtime nor precise, and need not persist across reboots.  
这个时钟是一个 32 位计数器，通常大约每 4 微秒至少递增一次，尽管它既不假定是实时的也不精确，并且不需要在重新启动后持续存在。

The clock component is intended to ensure that with a Maximum Segment Lifetime (MSL), generated ISNs will be unique since it cycles approximately every 4.55 hours, which is much longer than the MSL.  
时钟组件旨在确保使用最大段寿命 (MSL) 生成的 ISN 将是唯一的，因为它大约每 4.55 小时循环一次，这比 MSL 长得多。

Please note that for modern networks that support high data rates where the connection might start and quickly advance sequence numbers to overlap within the MSL, it is recommended to implement the Timestamp Option as mentioned later in Section 3.4.3.  
请注意，对于支持高数据率的现代网络，连接可能开始并快速推进序列号，在 MSL 内重叠，建议实现 3.4.3 节后面提到的时间戳选项。

A TCP implementation MUST use the above type of "clock" for clock-driven selection of initial sequence numbers (MUST-8), and SHOULD generate its initial sequence numbers with the expression:  
对于初始序列号(MUST-8)的时钟驱动选择，TCP 实现必须使用上述类型的 "时钟"，并且应使用以下表达式生成其初始序列号：

ISN = M + F(localip, localport, remoteip, remoteport, secretkey)

where M is the 4 microsecond timer, and F() is a pseudorandom function (PRF) of the connection's identifying parameters ("localip, localport, remoteip, remoteport") and a secret key ("secretkey") (SHLD-1).  
其中，M 是 4 微秒计时器，F()是连接的标识参数("localip, localport, remoteip, remoteport")和密钥("seckkey")(SHLD-1)的伪随机函数(PRF)。

F() MUST NOT be computable from the outside (MUST-9), or an attacker could still guess at sequence numbers from the ISN used for some other connection.  
F()不能从外部计算出来(MUST-9)，否则攻击者仍然可以从用于其他连接的 ISN 中猜测序列号。

The PRF could be implemented as a cryptographic hash of the concatenation of the TCP connection parameters and some secret data.  
PRF 可以被实现为 TCP 连接参数和一些秘密数据的级联的密码散列。

For discussion of the selection of a specific hash algorithm and management of the secret key data, please see Section 3 of [42].  
关于特定散列算法的选择和密钥数据的管理的讨论，请参见[42]的第 3 节。

For each connection there is a send sequence number and a receive sequence number.  
对于每个连接，都有一个发送序列号和一个接收序列号。

The initial send sequence number (ISS) is chosen by the data sending TCP peer, and the initial receive sequence number (IRS) is learned during the connection-establishing procedure.  
初始发送序列号(ISS)由数据发送 TCP 选择，而初始接收序列号(IRS)在连接建立过程中得到。

For a connection to be established or initialized, the two TCP peers must synchronize on each other's initial sequence numbers.  
如果要建立或初始化的连接，两个 TCP 必须同步对方的初始序列号。

This is done in an exchange of connection-establishing segments carrying a control bit called "SYN" (for synchronize) and the initial sequence numbers.  
这是通过交换建立连接的信息来完成的，这些信息带有一个称为 "SYN"（用于同步）的控制位和初始序列号。

As a shorthand, segments carrying the SYN bit are also called "SYNs".  
简而言之，携带 SYN 位的消息也称为 "SYNs"。

Hence, the solution requires a suitable mechanism for picking an initial sequence number and a slightly involved handshake to exchange the ISNs.  
因此，该解决方案需要一个合适的机制来挑选初始序列号，并需要一个稍微复杂的握手来交换 ISN。

The synchronization requires each side to send its own initial sequence number and to receive a confirmation of it in acknowledgment from the remote TCP peer.  
同步需要每一方发送自己的初始序列号，并从远端的 ACK 中得到确认。

Each side must also receive the remote peer's initial sequence number and send a confirming acknowledgment.  
每一方还必须收到远端的初始序列号，并发送确认的 ACK。

(1) A --> B SYN my sequence number is X  
(1) A --> B 同步自己的序列号 X

(2) A <-- B ACK your sequence number is X  
(2) A <-- B 确认你的序列号是 X

(3) A <-- B SYN my sequence number is Y  
(3) A <-- B 同步自己的序列号 Y

(4) A --> B ACK your sequence number is Y  
(4) A --> B 确认你的序列号是 Y

Because steps 2 and 3 can be combined in a single message this is called the three-way (or three message) handshake (3WHS).  
由于第 2 和第 3 步可以结合在一个消息中，这被称为三次（或三次信息）握手(3WHS)。

A 3WHS is necessary because sequence numbers are not tied to a global clock in the network, and TCP implementations may have different mechanisms for picking the ISNs.  
"三次握手" 是必要的，因为序列号没有绑定到网络中的全局时钟，并且 TCP 可能有不同的机制来挑选 ISN。

The receiver of the first SYN has no way of knowing whether the segment was an old one or not, unless it remembers the last sequence number used on the connection (which is not always possible), and so it must ask the sender to verify this SYN.  
第一个 SYN 的接收者没有办法知道这个 TCP 段是否是一个旧的延迟段，除非它记得连接上使用的最后一个序列号（这并不总是可能的），所以它必须要求发送者验证这个 SYN。

The three-way handshake and the advantages of a clock-driven scheme for ISN selection are discussed in [69].  
在[3]中讨论了 "三次握手" 和 ISN 选择 "时钟驱动" 方案的优势。

#### 知道什么时候该保持静默

**3.4.2. Knowing When to Keep Quiet**

A theoretical problem exists where data could be corrupted due to confusion between old segments in the network and new ones after a host reboots if the same port numbers and sequence space are reused.  
如果重复使用相同的端口号和序列空间，则在主机重新启动后，由于网络中的旧网段和新网段之间的混淆，理论上存在可能导致数据损坏的问题。

The "quiet time" concept discussed below addresses this, and the discussion of it is included for situations where it might be relevant, although it is not felt to be necessary in most current implementations.  
下面讨论的 "静默时间" 概念解决了这一问题，并将它的讨论包括在可能与之相关的情况下，尽管它在大多数当前实现中并不是必要的。

The problem was more relevant earlier in the history of TCP.  
在 TCP 历史的早期，这个问题更为相关。

In practical use on the Internet today, the error-prone conditions are sufficiently unlikely that it is safe to ignore.  
在今天互联网的实际使用中，容易出错的情况不太可能发生，因此可以放心地忽略。

Reasons why it is now negligible include: (a) ISS and ephemeral port randomization have reduced likelihood of reuse of port numbers and sequence numbers after reboots, (b) the effective MSL of the Internet has declined as links have become faster, and (c) reboots often taking longer than an MSL anyways.  
它现在可以忽略不计的原因包括：  
(a) ISS 和临时端口随机化降低了重新启动后重用端口号和序列号的可能性。  
(b) 随着链接变得更快，互联网的有效 MSL 已经下降。  
(c) 无论如何，重新启动通常比 MSL 花费的时间更长。

To be sure that a TCP implementation does not create a segment carries a sequence number that may be duplicated by an old segment remaining in the network, the TCP endpoint must keep quiet for a MSL before assigning any sequence numbers upon starting up or recovering from a situation where memory of sequence numbers in use was lost.  
为了确保 TCP 实现不会创建一个携带与网络中旧 TCP 段中序列号重复的 TCP 段，TCP 在启动时或从丢失当前使用序列号内存的崩溃中恢复时，在分配任何序列号之前保持最大段存活时间（MSL）的静默时间。

For this specification the MSL is taken to be 2 minutes.  
在本规范中，MSL 是 2 分钟。

This is an engineering choice, and may be changed if experience indicates it is desirable to do so.  
这是一个工程选择，它可能会根据经验改变。

Note that if a TCP endpoint is reinitialized in some sense, yet retains its memory of sequence numbers in use, then it need not wait at all; it must only be sure to use sequence numbers larger than those recently used.  
注意，如果一个 TCP 在某种情况被重新初始化，但保留了其正在使用的序列号的内存，那么它不需要等待；它只需要确保使用比最近使用的序列号大的序列号。

#### TCP 静默时间的概念

**3.4.3. The TCP Quiet Time Concept**

Hosts that for any reason lose knowledge of the last sequence numbers transmitted on each active (i.e., not closed) connection shall delay emitting any TCP segments for at least the agreed MSL in the internet system of which the host is a part.  
如果主机因为任何原因没有保留在每个活动（即未关闭）连接上传输的最后一个序列号的任何信息，则应至少延迟商定的最大段生命周期（MSL）后，再发送任何 TCP 段到主机所处的 internet 系统中。

In the paragraphs below, an explanation for this specification is given.  
在下面的段落中，给出了对该规范的解释。

TCP implementors may violate the "quiet time" restriction, but only at the risk of causing some old data to be accepted as new or new data rejected as old duplicated by some receivers in the internet system.  
TCP 实现者可以会违反 "quiet time" 限制，但是可能存在导致某些旧数据被接受为新数据或新数据被 internet 系统中的某些接收方认为是旧的重复数据而拒收的风险。

TCP endpoints consume sequence number space each time a segment is formed and entered into the network output queue at a source host.  
每次生成段并加入到源主机的网络输出队列时，TCP 都会消耗序列号空间。

The duplicate detection and sequencing algorithm in the TCP protocol relies on the unique binding of segment data to sequence space to the extent that sequence numbers will not cycle through all 2\*\*32 values before the segment data bound to those sequence numbers has been delivered and acknowledged by the receiver and all duplicate copies of the segments have "drained" from the internet.  
TCP 协议中的重复检测和排序算法依赖于段数据与序列空间的唯一绑定，因此与这些序列号绑定的段数据被送达并被接收方确认以及段的所有副本从互联网上 "耗尽" 之前，序列号不会在所有 2\*\*32 值中循环。

Without such an assumption, two distinct TCP segments could conceivably be assigned the same or overlapping sequence numbers, causing confusion at the receiver as to which data is new and which is old.  
如果没有这样的假设，两个不同的 TCP 段可能会被分配相同或重叠的序列号，从而导致接收方无法区分哪些数据是新数据，哪些是旧数据。

Remember that each segment is bound to as many consecutive sequence numbers as there are octets of data and SYN or FIN flags in the segment.  
记住，每个段都绑定到与段中数据和 SYN 或 FIN 标志的字节一样多的连续序列号。

Under normal conditions, TCP implementations keep track of the next sequence number to emit and the oldest awaiting acknowledgment so as to avoid mistakenly reusing a sequence number over before its first use has been acknowledged.  
在正常情况下，TCP 会跟踪下一个要发出的序列号和最旧的等待确认的序列号，以避免在第一次使用得到确认之前错误地重用该序列号。

This alone does not guarantee that old duplicate data is drained from the net, so the sequence space has been made very large to reduce the probability that a wandering duplicate will cause trouble upon arrival.  
仅仅这样并不能保证旧的重复数据从网络中消失，所以序列空间被做得非常大，以减少漫游的重复数据到达后造成麻烦的可能性。

At 2 megabits/sec. it takes 4.5 hours to use up 2\*\*32 octets of sequence space.  
在 2 兆比特/秒的情况下，需要 4.5 小时才能用完 2\*\*32 个字节的序列空间。

Since the maximum segment lifetime in the net is not likely to exceed a few tens of seconds, this is deemed ample protection for foreseeable nets, even if data rates escalate to 10's of megabits/sec.  
由于网络中的段的最大存活时间不太可能超过几十秒，这被认为是对可预见网络的充分保护，即使数据速率升级到 10 兆比特/秒。

At 100 megabits/sec, the cycle time is 5.4 minutes which may be a little short, but still within reason.  
在 100 兆比特/秒时，循环时间为 5.4 分钟，这可能有点短，但仍在合理范围内。

Much higher data rates are possible today, with implications described in the final paragraph of this subsection.  
今天，更高的数据速率是可能的，其影响在本小节的最后一段中描述。

The basic duplicate detection and sequencing algorithm in TCP can be defeated, however, if a source TCP endpoint does not have any memory of the sequence numbers it last used on a given connection.  
然而，如果源 TCP 没有任何关于它在给定连接上最后使用的序列号的内存，则 TCP 中的基础重复检测和排序算法可能会失效。

For example, if the TCP implementation were to start all connections with sequence number 0, then upon the host rebooting, a TCP peer might re-form an earlier connection (possibly after half-open connection resolution) and emit packets with sequence numbers identical to or overlapping with packets still in the network which were emitted on an earlier incarnation of the same connection.  
例如，如果 TCP 以序列号 0 开始所有连接，那么在重新启动时，TCP 可能会重新建立较早的连接（可能在半开连接解析之后）并发出序列号与网络中的数据包相同或重叠的数据包，这些数据包是在同一连接的早期实例下发出的。

In the absence of knowledge about the sequence numbers used on a particular connection, the TCP specification recommends that the source delay for MSL seconds before emitting segments on the connection, to allow time for segments from the earlier connection incarnation to drain from the system.  
在不知道特定连接上使用的序列号的情况下，TCP 规范建议源 TCP 在连接上发送段之前延迟 MSL 秒，以便让来自早期连接实例的段有时间从系统中消失。

Even hosts which can remember the time of day and used it to select initial sequence number values are not immune from this problem (i.e., even if time of day is used to select an initial sequence number for each new connection incarnation).  
即使是可以记住一天中的时间并使用它来选择初始序列号值的主机也不能避免这个问题（即，即使一天中的时间用于为每个新连接化身选择一个初始序列号）。

Suppose, for example, that a connection is opened starting with sequence number S.  
例如，假设一个连接以序列号 S 开始打开。

Suppose that this connection is not used much and that eventually the initial sequence number function (ISN(t)) takes on a value equal to the sequence number, say S1, of the last segment sent by this TCP on a particular connection.  
假设这个连接使用不多，最终初始序列号函数（ISN(t)）的值等于这个 TCP 在特定连接上发送的最后一个段的序列号，例如 S1。

Now suppose, at this instant, the host reboots and establishes a new incarnation of the connection.  
现在，假设在这个时刻，主机重启并建立了一个新的连接的实例。

The initial sequence number chosen is S1 = ISN(t) -- last used sequence number on old incarnation of connection!  
选择的初始序列号是 S1 = ISN(t) -- 旧的连接的最后使用的序列号!

If the recovery occurs quickly enough, any old duplicates in the net bearing sequence numbers in the neighborhood of S1 may arrive and be treated as new packets by the receiver of the new incarnation of the connection.  
如果恢复发生得足够快，网络中任何带有 S1 附近序列号的旧重复数据都可能到达，并被新的连接实例的接收者视为新的数据包。

The problem is that the recovering host may not know for how long it was down between rebooting nor does it know whether there are still old duplicates in the system from earlier connection incarnations.  
问题是正在恢复的主机可能不知道它重启了多长时间，也不知道系统中是否仍然存在来自早期连接实例的旧的重复数据。

One way to deal with this problem is to deliberately delay emitting segments for one MSL after recovery from a crash- this is the "quiet time" specification.  
解决这个问题的一种方法是在从崩溃中恢复后故意延迟一个 MSL 再发送段，这是 "静默时间" 规范。

Hosts that prefer to avoid waiting are willing to risk possible confusion of old and new packets at a given destination may choose not to wait for the "quie t time".  
喜欢避免等待的主机，愿意冒着在目的地可能出现新旧数据包混淆的风险，可以选择不等待 "静默时间"。

Implementors may provide TCP users with the ability to select on a connection-by-connection basis whether to wait after a reboot, or may informally implement the "quiet time" for all connections.  
实现者可以为 TCP 用户提供在连接基础上选择是否在崩溃后等待的能力，或者可以非正式地为所有连接实现 "静默时间"。

Obviously, even where a user selects to "wait", this is not necessary after the host has been "up" for at least MSL seconds.  
很明显，即使用户选择了 "等待"，在主机至少 "启动" 了 MSL 秒之后，也没有必要这样做。

To summarize: every segment emitted occupies one or more sequence numbers in the sequence space, the numbers occupied by a segment are "busy" or "in use" until MSL seconds have passed.  
总结一下：每个发出的段在序列空间中占据一个或多个序列号，段所占据的序列号是 "忙" 或 "使用中"，直到 MSL 秒过去。

Upon rebooting, a block of space-time is occupied by the octets and SYN or FIN flags of any potentially still in-flight segments.  
重启时，一个时空块被任何仍在网络中的段的数据和 SYN 或 FIN 标志占据。

If a new connection is started too soon and uses any of the sequence numbers in the space-time footprint of those potentially still in-flight segment of the previous connection incarnation, there is a potential sequence number overlap area which could cause confusion at the receiver.  
如果新连接启动得太早，并且使用了前一个连接实例的仍在网络中的段的时空足迹中的任何序列号，则存在潜在的序列号重叠区域，这可能会导致接收方混淆。

High-performance cases will have shorter cycle times than those in the megabits per second that the base TCP design described above considers.  
高性能情况下的周期时间将比上述基本 TCP 设计考虑的兆比特每秒的周期时间更短。

At 1 Gbps, the cycle time is 34 seconds, only 3 seconds at 10 Gbps, and around a third of a second at 100 Gbps.  
在 1 Gbps 时，周期时间为 34 秒，在 10 Gbps 时仅为 3 秒，在 100 Gbps 时约为三分之一秒。

In these higher-performance cases, TCP Timestamp Options and Protection Against Wrapped Sequences (PAWS) [47] provide the needed capability to detect and discard old duplicates.  
在这些更高性能的情况下，TCP 时间戳选项和针对包装序列的保护(PAWS)[47]提供了检测和丢弃旧副本所需的能力。

### 建立连接

**3.5. Establishing a Connection**
