---
title: RFC9293 TCP 协议
weight: 3
draft: true
# bookFlatSection: false
# bookToc: true
# bookHidden: false
# bookCollapseSection: false
# bookComments: false
# bookSearchExclude: false
---

# RFC9293 TCP 协议中文翻译

这是 RFC 上最新（截止到 2023 年 3 月）完整描述了 TCP 协议标准的文档，它整合了 RFC793 提出的 TCP 规范以及后来提出的多项优化 ，如果对 RFC793 感兴趣可以参考[RFC793 TCP 协议中文翻译](../translations/rfc793)。

原文：[Transmission Control Protocol (TCP)](https://datatracker.ietf.org/doc/rfc9293/)

## 封面

Internet Engineering Task Force (IETF)  
STD: 7  
Request for Comments: 9293  
Obsoletes: 793, 879, 2873, 6093, 6429, 6528, 6691  
Updates: 1011, 1122, 5961  
Category: Standards Track  
ISSN: 2070-1721

{{< right >}}
W. Eddy, Ed.  
MTI Systems  
August 2022
{{< /right >}}

{{< center >}}
Transmission Control Protocol (TCP)  
传输控制协议（TCP）
{{< /center >}}

## 摘要

**Abstract**

This document specifies the Transmission Control Protocol (TCP).  
本文档规定了传输控制协议（TCP）。

TCP is an important transport-layer protocol in the Internet protocol stack, and it has continuously evolved over decades of use and growth of the Internet.  
TCP 是 Internet 协议栈中重要的传输层协议，在互联网数十年的使用和发展过程中不断改进。

Over this time, a number of changes have been made to TCP as it was specified in RFC 793, though these have only been documented in a piecemeal fashion.  
在这段时间里，已经对 RFC 793 中规定的 TCP 进行了一些修改，尽管这些修改只是以零散的方式被记录下来。

This document collects and brings those changes together with the protocol specification from RFC 793.  
本文件收集了这些变化，并将其与 RFC 793 的协议规范结合在一起。

This document obsoletes RFC 793, as well as RFCs 879, 2873, 6093, 6429, 6528, and 6691 that updated parts of RFC 793.  
本文档废弃了 RFC 793，以及更新了 RFC 793 部分内容的 RFC 879、2873、6093、6429、6528 和 6691。

It updates RFCs 1011 and 1122, and it should be considered as a replacement for the portions of those documents dealing with TCP requirements.  
它更新了 RFC 1011 和 1122，它可以被视为那些文档中涉及 TCP 要求的部分的替代品。

It also updates RFC 5961 by adding a small clarification in reset handling while in the SYN-RECEIVED state.  
它还更新了 RFC 5961，在 SYN-RECEIVED 状态下在重置处理中添加了一个小的说明。

The TCP header control bits from RFC 793 have also been updated based on RFC 3168.  
RFC 793 中的 TCP 头控制位也根据 RFC 3168 进行了更新。

**Status of This Memo**

This is an Internet Standards Track document.  
这是一份互联网标准追踪文件。

This document is a product of the Internet Engineering Task Force (IETF).  
本文档是 Internet 工程任务组 (IETF) 的产品。

It represents the consensus of the IETF community.  
它代表了 IETF 社区的共识。

It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG).  
它已经接受了公众审阅，并已被互联网工程指导小组 (IESG) 批准发布。

Further information on Internet Standards is available in Section 2 of RFC 7841.  
有关 Internet 标准的更多信息，请参阅 RFC 7841 的第 2 节。

Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9293.  
有关本文档的当前状态、任何勘误表以及如何提供反馈的信息，请访问 [🔗](https://www.rfc-editor.org/info/rfc9293)。

## 版权声明

**Copyright Notice**

Copyright (c) 2022 IETF Trust and the persons identified as the document authors.  
Copyright (c) 2022 IETF Trust 和被认定为本文档作者的人员。

All rights reserved.  
保留所有权利。

This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  
本文档受 BCP 78 和 IETF 信托与 IETF 文档相关的法律规定 [🔗](https://trustee.ietf.org/license-info) 的约束，这些条款在本文档发布之日生效。

Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  
请仔细阅读这些文件，因为它们描述了您对本文件的权利和限制。

Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.  
从本文件中提取的代码组件必须包括信托法律条款第 4.e 节中描述的修订版 BSD 许可文本，并且不提供修订版 BSD 许可中描述的保证。

This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008.  
本文档可能包含 2008 年 11 月 10 日之前发布或公开提供的 IETF 文档或 IETF 文稿中的材料。

The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process.  
控制本材料某些版权的人可能未授予 IETF 信托允许在 IETF 标准流程之外修改此类材料的权利。

Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.  
如果没有从控制此类材料的版权的人那里获得足够的许可，则不得在 IETF 标准流程之外修改本文档，并且不得在 IETF 标准流程之外创建其衍生作品，除非将其格式化为 RFC 出版或将其翻译成英语以外的其他语言。

## 目录

{{< center >}}
Table of Contents
{{< /center >}}

1.Purpose and Scope 目的和范围  
2.Introduction 介绍  
&emsp;2.1. Requirements Language 需求语言  
&emsp;2.2. Key TCP Concepts 关键的 TCP 概念  
3.Functional Specification 功能规范  
&emsp;3.1. Header Format 头部格式  
&emsp;3.2. Specific Option Definitions 具体选项定义  
&emsp;&emsp;3.2.1. Other Common Options 其他常用选项  
&emsp;&emsp;3.2.2. Experimental TCP Options 实验性 TCP 选项  
&emsp;3.3. TCP Terminology Overview TCP 术语概述  
&emsp;&emsp;3.3.1. Key Connection State Variables 关键连接状态变量  
&emsp;&emsp;3.3.2. State Machine Overview 状态机概述  
&emsp;3.4. Sequence Numbers 序列号  
&emsp;&emsp;3.4.1. Initial Sequence Number Selection 初始序列号选择  
&emsp;&emsp;3.4.2. Knowing When to Keep Quiet 知道什么时候该保持静默  
&emsp;&emsp;3.4.3. The TCP Quiet Time Concept TCP 静默时间概念  
&emsp;3.5. Establishing a Connection 建立连接  
&emsp;&emsp;3.5.1. Half-Open Connections and Other Anomalies 半开连接和其他异常  
&emsp;&emsp;3.5.2. Reset Generation 重置生成  
&emsp;&emsp;3.5.3. Reset Processing 重置处理  
&emsp;3.6. Closing a Connection 关闭连接  
&emsp;&emsp;3.6.1. Half-Closed Connections 半关闭连接  
&emsp;3.7. Segmentation 分段  
&emsp;&emsp;3.7.1. Maximum Segment Size Option 最大段长度选项  
&emsp;&emsp;3.7.2. Path MTU Discovery 路径 MTU 发现  
&emsp;&emsp;3.7.3. Interfaces with Variable MTU Values 可变 MTU 值的接口  
&emsp;&emsp;3.7.4. Nagle Algorithm Nagle 算法  
&emsp;&emsp;3.7.5. IPv6 Jumbograms  
&emsp;3.8. Data Communication 数据通信  
&emsp;&emsp;3.8.1. Retransmission Timeout 重传超时  
&emsp;&emsp;3.8.2. TCP Congestion Control TCP 拥塞控制  
&emsp;&emsp;3.8.3. TCP Connection Failures TCP 连接故障  
&emsp;&emsp;3.8.4. TCP Keep-Alives  
&emsp;&emsp;3.8.5. The Communication of Urgent Information 紧急信息的通信  
&emsp;&emsp;3.8.6. Managing the Window 管理窗口  
&emsp;3.9. Interfaces 接口  
&emsp;&emsp;3.9.1. User/TCP Interface 用户/TCP 接口  
&emsp;&emsp;3.9.2. TCP/Lower-Level Interface TCP/下层协议接口  
&emsp;3.10. Event Processing 事件处理  
&emsp;&emsp;3.10.1. OPEN Call OPEN 调用  
&emsp;&emsp;3.10.2. SEND Call SEND 调用  
&emsp;&emsp;3.10.3. RECEIVE Call RECEIVE 调用  
&emsp;&emsp;3.10.4. CLOSE Call CLOSE 调用  
&emsp;&emsp;3.10.5. ABORT Call ABORT 调用  
&emsp;&emsp;3.10.6. STATUS Call STATUS 调用  
&emsp;&emsp;3.10.7. SEGMENT ARRIVES 收到段  
&emsp;&emsp;3.10.8. Timeouts 超时  
4.Glossary 词汇表  
5.Changes from RFC 793 与 RFC 793 相比的改动  
6.IANA Considerations IANA 的注意事项  
7.Security and Privacy Considerations 安全和隐私注意事项  
8.References 参考文献  
&emsp;8.1. Normative References 规范性参考文献  
&emsp;8.2. Informative References 非规范性参考文献  
Appendix A. Other Implementation Notes 其他实现说明  
&emsp;A.1. IP Security Compartment and Precedence IP 安全部分和优先级  
&emsp;&emsp;A.1.1. Precedence 优先级  
&emsp;&emsp;A.1.2. MLS Systems MLS 系统  
&emsp;A.2. Sequence Number Validation 序列号验证  
&emsp;A.3. Nagle Modification Nagle 修改  
&emsp;A.4. Low Watermark Settings 低水印设置  
Appendix B. TCP Requirement Summary TCP 要求概述  
Acknowledgments 致谢  
Author's Address 作者的地址

## 目的和范围

**1.Purpose and Scope**

In 1981, RFC 793 [16] was released, documenting the Transmission Control Protocol (TCP) and replacing earlier published specifications for TCP.  
1981 年，RFC 793 [16] 发布，记录了传输控制协议 (TCP) 并取代了早期发布的 TCP 规范。

Since then, TCP has been widely implemented, and it has been used as a transport protocol for numerous applications on the Internet.  
从那时起，TCP 得到了广泛的应用，并被用作 Internet 上众多应用程序的传输协议。

For several decades, RFC 793 plus a number of other documents have combined to serve as the core specification for TCP [49].  
几十年来，RFC 793 加上许多其他文档已合并为 TCP 的核心规范[49]。

Over time, a number of errata have been filed against RFC 793.  
随着时间的流逝，已经针对 RFC 793 提出了许多勘误表。

There have also been deficiencies found and resolved in security, performance, and many other aspects.  
在安全、性能和其他许多方面也发现和解决了一些缺陷。

The number of enhancements has grown over time across many separate documents.  
随着时间的推移，改进的数量在许多独立的文件中不断增加。

These were never accumulated together into a comprehensive update to the base specification.  
这些改进还没有被整合到一起，整体更新基本规范。

The purpose of this document is to bring together all of the IETF Standards Track changes and other clarifications that have been made to the base TCP functional specification (RFC 793) and to unify them into an updated version of the specification.  
本文档的目的是将所有 IETF 标准轨道的修改和其他对基础 TCP 功能规范（RFC 793）的说明汇集在一起，并将它们统一到规范的更新版本中。

Some companion documents are referenced for important algorithms that are used by TCP (e.g., for congestion control) but have not been completely included in this document.  
但是一些用于 TCP 使用的重要算法（例如，用于拥塞控制）的相关文档，还没有完全包括在本文档中。

This is a conscious choice, as this base specification can be used with multiple additional algorithms that are developed and incorporated separately.  
这是一个有意识的选择，因为该基本规范可以与多种额外的算法一起使用，这些算法是单独开发和合并的。

This document focuses on the common basis that all TCP implementations must support in order to interoperate.  
本文档重点关注所有 TCP 实现必须支持的共同基础，以实现互操作。

Since some additional TCP features have become quite complicated themselves (e.g., advanced loss recovery and congestion control), future companion documents may attempt to similarly bring these together.  
因为一些额外的 TCP 功能本身已经变得相当复杂（例如，高级损失恢复和拥塞控制），未来的配套文档可能会试图类似地将这些功能集中起来。

In addition to the protocol specification that describes the TCP segment format, generation, and processing rules that are to be implemented in code, RFC 793 and other updates also contain informative and descriptive text for readers to understand aspects of the protocol design and operation.  
除了描述要在代码中实现的 TCP 段格式、生成和处理规则的协议规范外，RFC 793 和其他更新还包含信息和描述性内容，以便读者了解协议设计和运行的各个方面。

This document does not attempt to alter or update this informative text and is focused only on updating the normative protocol specification.  
本文件并不试图改变或更新这些信息性的内容，而只是专注于更新标准化的协议规范。

This document preserves references to the documentation containing the important explanations and rationale, where appropriate.  
本文档保留了对包含重要解释和基本原理的文档的引用。

This document is intended to be useful both in checking existing TCP implementations for conformance purposes, as well as in writing new implementations.  
该文档旨在帮助检查现有的 TCP 实现以及编写新实现。

## 介绍

**2.Introduction**

RFC 793 contains a discussion of the TCP design goals and provides examples of its operation, including examples of connection establishment, connection termination, and packet retransmission to repair losses.  
RFC 793 包含了对 TCP 设计目标的讨论，并提供了其操作的示例，包括建立连接、关闭连接以及弥补丢失的数据包重传。

This document describes the basic functionality expected in modern TCP implementations and replaces the protocol specification in RFC 793.  
本文档描述了现代 TCP 实现中预期的基本功能，并替换了 RFC 793 中的协议规范。

It does not replicate or attempt to update the introduction and philosophy content in Sections 1 and 2 of RFC 793.  
它不会复制或尝试更新 RFC 793 第 1 和 2 节中的简介和理念内容。

Other documents are referenced to provide explanations of the theory of operation, rationale, and detailed discussion of design decisions.  
还参考了其他文件，以提供对操作理论、原理的解释，以及对设计决策的详细讨论。

This document only focuses on the normative behavior of the protocol.  
本文档只关注协议的标准行为。

The "TCP Roadmap" [49] provides a more extensive guide to the RFCs that define TCP and describe various important algorithms.
"TCP 路线图" [49] 为定义 TCP 和描述各种重要算法的 RFC 提供了更广泛的指南。

The TCP Roadmap contains sections on strongly encouraged enhancements that improve performance and other aspects of TCP beyond the basic operation specified in this document.  
TCP 路线图包含强烈推荐的增强功能，这些增强功能可以提高 TCP 的性能和其他超出本文档中规定的基本操作的方面。

As one example, implementing congestion control (e.g., [8]) is a TCP requirement, but it is a complex topic on its own and not described in detail in this document, as there are many options and possibilities that do not impact basic interoperability.  
举个例子，实现拥塞控制（例如，[8]）是一项 TCP 要求，但它本身就是一个复杂的主题，并且在本文档中没有详细描述，因为有许多不会影响基本的互操作性的选项和可能性 .

Similarly, most TCP implementations today include the high-performance extensions in [47], but these are not strictly required or discussed in this document.  
类似地，今天的大多数 TCP 实现都包括 [47] 中的高性能扩展，但这些在本文档中并不是严格要求或讨论的。

Multipath considerations for TCP are also specified separately in [59].  
TCP 的多路径注意事项也在 [59] 中单独指定。

A list of changes from RFC 793 is contained in Section 5.  
与 RFC 793 相比的改动清单包含在第 5 节。

### 需求语言

**2.1. Requirements Language**

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 [3] [12] when, and only when, they appear in all capitals, as shown here.  
本文中的关键词 "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", 和 "OPTIONAL"，当且仅当它们以大写字母出现时，应按照 BCP 14 [3] [12] 中的描述进行解释，如这里所示。

Each use of RFC 2119 keywords in the document is individually labeled and referenced in Appendix B, which summarizes implementation requirements.  
文档中每次使用 RFC 2119 关键字都在附录 B 中单独标记和引用，附录 B 总结了实现要求。

Sentences using "MUST" are labeled as "MUST-X" with X being a numeric identifier enabling the requirement to be located easily when referenced from Appendix B.  
使用 "MUST" 的句子被标记为 "MUST-X"，X 是一个数字标识符，可以很容易地从附录 B 找到引用的要求。

Similarly, sentences using "SHOULD" are labeled with "SHLD-X", "MAY" with "MAY-X", and "RECOMMENDED" with "REC-X".  
同样地，使用 "SHOULD" 的句子被标记为 "SHLD-X"，"MAY" 被标记为 "MAY-X"，"RECOMMENDED" 被标记为 "REC-X"。

For the purposes of this labeling, "SHOULD NOT" and "MUST NOT" are labeled the same as "SHOULD" and "MUST" instances.  
出于此标签的目的，"SHOULD NOT" 和 "MUST NOT" 的标签与 "SHOULD" 和 "MUST" 实例的标签相同。

### 关键的 TCP 概念

**2.2. Key TCP Concepts**

TCP provides a reliable, in-order, byte-stream service to applications.  
TCP 为应用程序提供可靠、有序的字节流服务。

The application byte-stream is conveyed over the network via TCP segments, with each TCP segment sent as an Internet Protocol (IP) datagram.  
应用程序的字节流通过 TCP 段在网络上传输，每个 TCP 段作为互联网协议 (IP) 数据报发送。

TCP reliability consists of detecting packet losses (via sequence numbers) and errors (via per-segment checksums), as well as correction via retransmission.  
TCP 可靠性包括检测数据包丢失（通过序列号）和错误（通过段校验和），以及通过重传进行纠正。

TCP supports unicast delivery of data.  
TCP 支持单播传输数据。

There are anycast applications that can successfully use TCP without modifications, though there is some risk of instability due to changes of lower-layer forwarding behavior [46].  
有一些任播应用程序可以在不修改的情况下成功地使用 TCP，尽管由于下层转发行为的变化存在一些不稳定的风险 [46]。

TCP is connection oriented, though it does not inherently include a liveness detection capability.  
TCP 是面向连接的，尽管它本身并不包括活跃性检测功能。

Data flow is supported bidirectionally over TCP connections, though applications are free to send data only unidirectionally, if they so choose.  
通过 TCP 连接双向支持数据流，但如果应用程序愿意，它们可以自由地仅单向发送数据。

TCP uses port numbers to identify application services and to multiplex distinct flows between hosts.  
TCP 使用端口号来识别应用程序服务并在主机之间复用不同的流。

A more detailed description of TCP features compared to other transport protocols can be found in Section 3.1 of [52].  
与其他传输协议相比，TCP 功能的更详细描述可以在 [52] 的第 3.1 节中找到。

Further description of the motivations for developing TCP and its role in the Internet protocol stack can be found in Section 2 of [16] and earlier versions of the TCP specification.  
关于开发 TCP 的动机和它在互联网协议栈中的作用的更多描述，可以在[16]的第 2 节和早期版本的 TCP 规范中找到。

## 功能规范

**3.Functional Specification**

### 头部格式

**3.1. Header Format**

TCP segments are sent as internet datagrams.  
TCP 段作为网络数据报发送。

The Internet Protocol (IP) header carries several information fields, including the source and destination host addresses [1] [13].
网际互联协议 (IP) 报头携带多个信息字段，包括源和目标主机地址 [1] [13]。

A TCP header follows the IP headers, supplying information specific to TCP.  
TCP 头部跟在 IP 头部之后，提供特定于 TCP 的信息。

This division allows for the existence of host-level protocols other than TCP.  
这种划分允许存在除 TCP 之外的主机级协议。

In the early development of the Internet suite of protocols, the IP header fields had been a part of TCP.  
在 Internet 协议套件的早期开发中，IP 报头字段一直是 TCP 的一部分。

This document describes TCP, which uses TCP headers.  
本文档描述了使用 TCP 头部的 TCP。

A TCP header, followed by any user data in the segment, is formatted as follows, using the style from [66]:  
在段中，TCP 头部后面是任意用户数据，格式如下，使用 [66] 中的样式：

{{< center >}}

```
 0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |       Destination Port        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data |       |C|E|U|A|P|R|S|F|                               |
   | Offset| Rsrvd |W|C|R|C|S|S|Y|I|            Window             |
   |       |       |R|E|G|K|H|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           [Options]                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               :
   :                             Data                              :
   :                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

Note that one tick mark represents one bit position.  
注意：一个刻度线代表一个比特位。

Figure 1: TCP Header Format  
图 1：TCP 头部格式

{{< /center >}}

where:  
其中：

**Source Port**: 16 bits  
{{< block-indent >}}
The source port number.  
源端口号
{{< /block-indent >}}

**Destination Port**: 16 bits  
{{< block-indent >}}
The destination port number.  
目标端口号
{{< /block-indent >}}

**Sequence Number**: 32 bits  
{{< block-indent >}}
The sequence number of the first data octet in this segment (except when SYN is present).  
该段数据中第一个字节的序列号（有 SYN 标志除外）。  
If SYN is set, the sequence number is the initial sequence number (ISN) and the first data octet is ISN+1.  
如果设置了 SYN，则序列号是初始序列号 (ISN)，第一个字节数据是 ISN+1。
{{< /block-indent >}}

**Acknowledgment Number**: 32 bits
{{< block-indent >}}
If the ACK control bit is set, this field contains the value of the next sequence number the sender of the segment is expecting to receive. Once a connection is established, this is always sent.  
如果设置了 ACK 标志，这个字段表示发送者期望收到的下一个序列号的值。一旦建立了连接，一直会发送这个字段。
{{< /block-indent >}}

**Data Offset (DOffset)**: 4 bits  
{{< block-indent >}}  
The number of 32 bit words in the TCP Header. This indicates where the data begins. The TCP header (even one including options) is an integer multiple of 32 bits long.  
这个数表示 TCP 头部的长度有多少个 32 bit，表示真正数据开始的位置。TCP 头部（即使包括选项部分）的长度是 32 bit 的整数倍。
{{< /block-indent >}}

**Reserved (Rsrvd)**: 4 bits  
{{< block-indent >}}
A set of control bits reserved for future use. Must be zero in generated segments and must be ignored in received segments if the corresponding future features are not implemented by the sending or receiving host.  
为将来使用而保留的一组控制位。如果发送或接收主机未实现相应的未来功能，则在生成的段中必须为零，并且在接收的段中必须忽略。
{{< /block-indent >}}

**Control bits**:  
{{< block-indent >}}
The control bits are also known as "flags".  
控制位也称为 "标志"。

Assignment is managed by IANA from the "TCP Header Flags" registry [62].  
由 IANA 从 "TCP Header Flags" 注册表 [62] 中管理分配。

The currently assigned control bits are CWR, ECE, URG, ACK, PSH, RST, SYN, and FIN.  
目前分配的控制位是 CWR、ECE、URG、ACK、PSH、RST、SYN 和 FIN。

CWR: 1 bit

Congestion Window Reduced (see [6]).  
减少拥塞窗口（参见 [6]）。

ECE: 1 bit

ECN-Echo (see [6]).  
显式拥塞通知回应(参见 [6]).

URG: 1 bit

Urgent pointer field is significant.  
紧急指针字段很重要。

ACK: 1 bit

Acknowledgment field is significant.  
确认字段很重要。

PSH: 1 bit

Push function (see the Send Call description in Section 3.9.1).  
推送功能（参见第 3.9.1 节中的 Send 调用说明）。

RST: 1 bit

Reset the connection.  
重置连接。

SYN: 1 bit

Synchronize sequence numbers.  
同步序列号。

FIN: 1 bit

No more data from sender.  
发送者没有更多数据。

{{< /block-indent >}}

**Window**: 16 bits
{{< block-indent >}}
The number of data octets beginning with the one indicated in the acknowledgment field which the sender of this segment is willing to accept.  
从确认序号开始，发送方可以接收的字节数。

The value is shifted when the window scaling extension is used [47].  
当使用窗口缩放扩展时，该值会发生变化 [47]。

The window size MUST be treated as an unsigned number, or else large window sizes will appear like negative windows and TCP will not work (MUST-1).  
窗口大小必须被视为无符号的数字，否则大的窗口大小将出现负窗口，TCP 将无法工作（MUST-1）。

It is RECOMMENDED that implementations will reserve 32-bit fields for the send and receive window sizes in the connection record and do all window computations with 32 bits (REC-1).  
建议实现在连接记录中为发送和接收窗口大小保留 32 位字段，并以 32 位进行所有窗口计算（REC-1）。
{{< /block-indent >}}

**Checksum**: 16 bits  
{{< block-indent >}}
The checksum field is the 16 bit one's complement of the one's complement sum of all 16 bit words in the header and text.  
检验和是头部和数据部分所有分割成 16 bit 数的经过二进制反码求和得到的数。

The checksum computation needs to ensure the 16-bit alignment of the data being summed.  
校验和计算需要确保求和的数据 16 位对齐。

If a segment contains an odd number of header and text octets, alignment can be achieved by padding the last octet with zeros on its right to form a 16-bit word for checksum purposes.  
如果段的头部和内容是奇数个字节，可以通过在最后一个字节的右侧填充零来对齐，以组成一个 16 位字来实现校验和。

The pad is not transmitted as part of the segment.  
填充不会作为 TCP 段的一部分进行传输。

While computing the checksum, the checksum field itself is replaced with zeros.  
在计算校验和时，校验和字段本身用零替换。

The checksum also covers a pseudo-header (Figure 2) conceptually prefixed to the TCP header.  
校验和还包括了一个伪头部（图 2），在概念上作为 TCP 头部的前缀。

The pseudo-header is 96 bits for IPv4 and 320 bits for IPv6.  
伪头部在 IPv4 下是 96 位，在 IPv6 下是 320 位。

Including the pseudo-header in the checksum gives the TCP connection protection against misrouted segments.  
在校验和中包含伪标头可以避免 TCP 连接错误路由的段。

This information is carried in IP headers and is transferred across the TCP/network interface in the arguments or results of calls by the TCP implementation on the IP layer.  
这些信息包含在 IP 头部中，并在 TCP/网络 接口上通过 TCP 对 IP 层的调用的参数或结果进行传输。

{{< /block-indent >}}

{{< center >}}

```
+--------+--------+--------+--------+
|           Source Address          |
+--------+--------+--------+--------+
|         Destination Address       |
+--------+--------+--------+--------+
|  zero  |  PTCL  |    TCP Length   |
+--------+--------+--------+--------+
```

Figure 2: IPv4 Pseudo-header  
图 2：IPv4 伪头部

{{< /center >}}

{{< block-indent >}}
Pseudo-header components for IPv4:  
IPv4 的伪头组成:

Source Address: the IPv4 source address in network byte order  
Source Address: 网络字节序的 IPv4 源地址

Destination Address: the IPv4 destination address in network byte order  
Destination Address: 网络字节序的 IPv4 目的地址

zero: bits set to zero  
zero: 全部设置为 0

PTCL: the protocol number from the IP header  
PTCL: 来自 IP 头部的协议号

TCP Length: the TCP header length plus the data length in octets (this is not an explicitly transmitted quantity but is computed), and it does not count the 12 octets of the pseudo-header.
TCP Length: TCP 报头加上数据部分的长度，单位是字节（这不是一个明确的传输量，而是计算出来的），并且不包括 12 字节的伪头部。

For IPv6, the pseudo-header is defined in Section 8.1 of RFC 8200 [13] and contains the IPv6 Source Address and Destination Address, an Upper-Layer Packet Length (a 32-bit value otherwise equivalent to TCP Length in the IPv4 pseudo-header), three bytes of zero padding, and a Next Header value, which differs from the IPv6 header value if there are extension headers present between IPv6 and TCP.  
对于 IPv6，伪标头在 RFC 8200 [13] 的第 8.1 节中定义，包含 IPv6 源地址和目标地址、上层数据包长度（一个 32 位值，否则等同于 IPv4 伪标头中的 TCP 长度） header），三个字节的零填充和一个 Next Header 值，如果 IPv6 和 TCP 之间存在扩展头部，则该值与 IPv6 头部值不同。

The TCP checksum is never optional. The sender MUST generate it (MUST-2) and the receiver MUST check it (MUST-3).  
TCP 校验和永远不是可选的，发送方必须生成它（MUST-2）并且接收方必须检查它（MUST-3）。

{{< /block-indent >}}

**Urgent Pointer**: 16 bits  
{{< block-indent >}}
This field communicates the current value of the urgent pointer as a positive offset from the sequence number in this segment.  
这个字段表示当前紧急指针距离本段中序列号的正偏移。

The urgent pointer points to the sequence number of the octet following the urgent data.  
紧急指针指向紧急数据后的字节的序列号。

This field should only be interpreted in segments with the URG control bit set.  
这个字段只应在设置了 URG 标志的 TCP 段中使用。
{{< /block-indent >}}

**Options**:  
{{< block-indent >}}
[TCP Option]; size(Options) == (DOffset-5)\*32; present only when DOffset > 5.  
[TCP Option]; size(Options) == (DOffset-5)\*32; 只有在 DOffset > 5 时存在.

Note that this size expression also includes any padding trailing the actual options present.  
注意，这个大小表达式还包括在实际选项后面的任何填充。

Options may occupy space at the end of the TCP header and are a multiple of 8 bits in length.  
选项部分可能占用 TCP 头的末尾的空间，长度为 8bit 的倍数。

All options are included in the checksum.  
选项部分也包括在检验和的计算中。

An option may begin on any octet boundary.  
选项部分可以从任何字节边界上开始。

There are two cases for the format of an option:  
选项的格式有两种情况：

- Case 1: A single octet of option-kind.  
  情况 1: 一个字节的选项类型。
- Case 2: An octet of option-kind (Kind), an octet of option-length, and the actual option-data octets.  
  情况 2: 一个字节的选项类型(Kind)、一个字节的选项长度和真正选项数据。

The option-length counts the two octets of option-kind and option-length as well as the option-data octets.  
选项长度包括选项种类和选项长度的两个字节，以及选项数据的字节数。

Note that the list of options may be shorter than the Data Offset field might imply.  
注意：选项列表可能比数据偏移字段要短。

The content of the header beyond the End of Option List Option MUST be header padding of zeros (MUST-69).  
选项列表选项结束后的头部内容必须用零填充（MUST-69）。

The list of all currently defined options is managed by IANA [62], and each option is defined in other RFCs, as indicated there.  
所有当前定义的选项列表由 IANA [62] 管理，每个选项都在其他 RFC 中定义，如此处所示。

That set includes experimental options that can be extended to support multiple concurrent usages [45].  
该列表包括可以扩展以支持多个并发使用的实验选项 [45]。

A given TCP implementation can support any currently defined options, but the following options MUST be supported (MUST-4 -- note Maximum Segment Size Option support is also part of MUST-14 in Section 3.7.1):  
给定的 TCP 实现可以支持任何当前定义的选项，但必须支持以下选项（MUST-4 —— 注意最大段大小选项支持也是第 3.7.1 节中 MUST-14 的一部分）：

{{< /block-indent >}}
{{< center >}}

```
+======+========+============================+
| Kind | Length | Meaning                    |
+======+========+============================+
| 0    | -      | End of Option List Option. |
+------+--------+----------------------------+
| 1    | -      | No-Operation.              |
+------+--------+----------------------------+
| 2    | 4      | Maximum Segment Size.      |
+------+--------+----------------------------+
```

Table 1: Mandatory Option Set  
表 1: 强制性选项列表
{{< /center >}}

{{< block-indent >}}
These options are specified in detail in Section 3.2.  
这些选项在第 3.2 节中有详细说明。

A TCP implementation MUST be able to receive a TCP Option in any segment (MUST-5).  
TCP 实现必须能够在任何段中接收 TCP 选项（MUST-5）。

A TCP implementation MUST (MUST-6) ignore without error any TCP Option it does not implement, assuming that the option has a length field.  
TCP 实现必须（MUST-6）无误地忽略它没有实现的任何 TCP 选项，假设该选项有一个长度字段。

All TCP Options except End of Option List Option (EOL) and No-Operation (NOP) MUST have length fields, including all future options (MUST-68).  
除了选项列表结束选项（EOL）和无操作（NOP）之外的所有 TCP 选项必须有长度字段，包括所有未来选项（MUST-68）。

TCP implementations MUST be prepared to handle an illegal option length (e.g., zero); a suggested procedure is to reset the connection and log the error cause (MUST-7).  
TCP 实现必须准备好处理非法选项长度（例如，0），建议的处理是重置连接并记录错误原因 (MUST-7)。

Note: There is ongoing work to extend the space available for TCP Options, such as [65].  
注意：目前正在进行扩展 TCP 选项可用空间的工作，例如 [65]。

{{< /block-indent >}}

**Data**: variable length

{{< block-indent >}}
User data carried by the TCP segment.  
TCP 段中携带的用户数据。
{{< /block-indent >}}

### 具体的选项定义

**3.2. Specific Option Definitions**

A TCP Option, in the mandatory option set, is one of an End of Option List Option, a No-Operation Option, or a Maximum Segment Size Option.
TCP 选项，在强制性选项列表中，是选项列表结束选项、无操作选项或最大段大小选项中的一个。

An End of Option List Option is formatted as follows:  
选项列表结束选项的格式如下：

```
 0
 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+
|       0       |
+-+-+-+-+-+-+-+-+
```

where:  
其中：

Kind: 1 byte; Kind == 0.

This option code indicates the end of the option list.  
该选项代码表示选项列表的结尾。

This might not coincide with the end of the TCP header according to the Data Offset field.  
根据数据偏移字段，这可能与 TCP 头部的结尾不一致。

This is used at the end of all options, not the end of each option, and need only be used if the end of the options would not otherwise coincide with the end of the TCP header.  
这用于所有选项的末尾，而不是每个选项的末尾，并且仅在选项末尾与 TCP 标头末尾不一致时才需要使用。

A No-Operation Option is formatted as follows:  
无操作选项的格式如下：

```
 0
 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+
|       1       |
+-+-+-+-+-+-+-+-+
```

where:  
其中：

Kind: 1 byte; Kind == 1.

This option code can be used between options, for example, to align the beginning of a subsequent option on a word boundary.  
该选项代码可用于选项之间，例如，将后续选项的开头对齐到字边界上。

There is no guarantee that senders will use this option, so receivers MUST be prepared to process options even if they do not begin on a word boundary (MUST-64).  
不能保证发送方会使用这个选项，因此接收方必须准备好处理选项，即使它们不是从字边界开始的（MUST-64）。

A Maximum Segment Size Option is formatted as follows:  
最大段大小选项的格式如下：

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       2       |     Length    |   Maximum Segment Size (MSS)  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

where:  
其中：

Kind: 1 byte; Kind == 2.

If this option is present, then it communicates the maximum receive segment size at the TCP endpoint that sends this segment.  
如果存在此选项，则它会在发送此段的 TCP 端传达最大接收段大小。

This value is limited by the IP reassembly limit.  
该值受 IP 重组限制。

This field may be sent in the initial connection request (i.e., in segments with the SYN control bit set) and MUST NOT be sent in other segments (MUST-65).  
该字段可以在初始连接请求中发送（即，在设置了 SYN 控制位的段中）并且不得在其他段中发送（MUST-65）。

If this option is not used, any segment size is allowed.  
如果不使用此选项，则允许任何段大小。

A more complete description of this option is provided in Section 3.7.1.  
第 3.7.1 节提供了此选项的更完整描述。

Length: 1 byte; Length == 4.

Length of the option in bytes.  
选项的长度（以字节为单位）。

Maximum Segment Size (MSS): 2 bytes.

The maximum receive segment size at the TCP endpoint that sends this segment.  
发送该段的 TCP 端的最大接收段大小。

#### 其他常用选项

**3.2.1. Other Common Options**

Additional RFCs define some other commonly used options that are recommended to implement for high performance but are not necessary for basic TCP interoperability.  
其他 RFC 定义了一些其他建议为实现高性能而实现的常用选项，但对于基本 TCP 互操作性而言不是必需的。

These are the TCP Selective Acknowledgment (SACK) Option [22] [26], TCP Timestamp (TS) Option [47], and TCP Window Scale (WS) Option [47].  
这些是 TCP 选择性确认 (SACK) 选项 [22] [26]、TCP 时间戳 (TS) 选项 [47] 和 TCP 窗口比例 (WS) 选项 [47]。

#### 实验性 TCP 选项

**3.2.2. Experimental TCP Options**

Experimental TCP Option values are defined in [30], and [45] describes the current recommended usage for these experimental values.  
实验性 TCP 选项值在 [30] 中定义，[45] 描述了这些实验值的当前推荐用法。

### 术语概述

**3.3. TCP Terminology Overview**

This section includes an overview of key terms needed to understand the detailed protocol operation in the rest of the document.  
本节概述了理解文档其余部分详细协议操作所需的关键术语。

There is a glossary of terms in Section 4.  
第 4 节中有术语表。

#### 关键连接状态变量

**3.3.1. Key Connection State Variables**

Before we can discuss the operation of the TCP implementation in detail, we need to introduce some detailed terminology.  
在我们详细讨论 TCP 实现的操作之前，我们需要介绍一些详细的术语。

The maintenance of a TCP connection requires maintaining state for several variables.  
TCP 连接的维护需要维护多个变量的状态。

We conceive of these variables being stored in a connection record called a Transmission Control Block or TCB.  
我们设想将这些变量存储在称为传输控制块或 TCB 的连接记录中。

Among the variables stored in the TCB are the local and remote IP addresses and port numbers, the IP security level, and compartment of the connection (see Appendix A.1), pointers to the user's send and receive buffers, pointers to the retransmit queue and to the current segment.  
存储在 TCB 中的变量包括本地和远程 IP 地址和端口号、IP 安全级别和连接区段（参见附录 A.1）、指向用户发送和接收缓冲区的指针、指向重传队列的指针和当前段。

In addition, several variables relating to the send and receive sequence numbers are stored in the TCB.  
此外，几个与发送和接收序列号相关的变量存储在 TCB 中。

{{< center >}}

```
+==========+=====================================================+
| Variable | Description                                         |
+==========+=====================================================+
| SND.UNA  | send unacknowledged                                 |
+----------+-----------------------------------------------------+
| SND.NXT  | send next                                           |
+----------+-----------------------------------------------------+
| SND.WND  | send window                                         |
+----------+-----------------------------------------------------+
| SND.UP   | send urgent pointer                                 |
+----------+-----------------------------------------------------+
| SND.WL1  | segment sequence number used for last window update |
+----------+-----------------------------------------------------+
| SND.WL2  | segment acknowledgment number used for last window  |
|          | update                                              |
+----------+-----------------------------------------------------+
| ISS      | initial send sequence number                        |
+----------+-----------------------------------------------------+
```

Table 2: Send Sequence Variables  
表 2: 发送序列变量

```
+==========+=================================+
| Variable | Description                     |
+==========+=================================+
| RCV.NXT  | receive next                    |
+----------+---------------------------------+
| RCV.WND  | receive window                  |
+----------+---------------------------------+
| RCV.UP   | receive urgent pointer          |
+----------+---------------------------------+
| IRS      | initial receive sequence number |
+----------+---------------------------------+
```

Table 3: Receive Sequence Variables  
表 3: 接收序列变量
{{< /center >}}

The following diagrams may help to relate some of these variables to the sequence space.  
下图可能有助于将其中一些变量与序列空间联系起来。

{{< center >}}

```
    1         2          3          4
----------|----------|----------|----------
SND.UNA    SND.NXT    SND.UNA
                     +SND.WND

1 - old sequence numbers which have been acknowledged
2 - sequence numbers of unacknowledged data
3 - sequence numbers allowed for new data transmission
4 - future sequence numbers which are not yet allowed
```

Figure 3: Send Sequence Space  
图 3：发送序列变量

{{< /center >}}

The send window is the portion of the sequence space labeled 3 in figure 3.  
发送窗口是图 3 中标记为 3 的序列空间的一部分。

{{< center >}}

```
  1          2          3
----------|----------|----------
RCV.NXT    RCV.NXT
          +RCV.WND

1 - old sequence numbers which have been acknowledged
2 - sequence numbers allowed for new reception
3 - future sequence numbers which are not yet allowed
```

Figure 4: Receive Sequence Space  
图 4：接收序列变量

{{< /center >}}

The receive window is the portion of the sequence space labeled 2 in figure 4.  
接收窗口是图 4 中标记为 2 的序列空间的一部分。

There are also some variables used frequently in the discussion that take their values from the fields of the current segment.  
还有一些在讨论中经常使用的变量，它们的值来自当前段的字段。

{{< center >}}

```
+==========+===============================+
| Variable | Description                   |
+==========+===============================+
| SEG.SEQ  | segment sequence number       |
+----------+-------------------------------+
| SEG.ACK  | segment acknowledgment number |
+----------+-------------------------------+
| SEG.LEN  | segment length                |
+----------+-------------------------------+
| SEG.WND  | segment window                |
+----------+-------------------------------+
| SEG.UP   | segment urgent pointer        |
+----------+-------------------------------+
```

Table 4: Current Segment Variables  
表 4：当前段变量

{{< /center >}}

#### 状态机概述

**3.3.2. State Machine Overview**

A connection progresses through a series of states during its lifetime.  
一个连接在其生命周期中会经历一系列的状态。

The states are: LISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT, and the fictional state CLOSED.  
这些状态是：LISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT 以及虚构的状态 CLOSED。

CLOSED is fictional because it represents the state when there is no TCB, and therefore, no connection.  
CLOSED 是虚构的，因为它代表了没有 TCB 的状态，也就是没有连接。

Briefly the meanings of the states are:  
简而言之，这些状态的含义是：

**LISTEN** - represents waiting for a connection request from any remote TCP peer and port.  
**LISTEN** - 表示等待来自任何远程对等 TCP 和端口的连接请求。

**SYN-SENT** - represents waiting for a matching connection request after having sent a connection request.  
**SYN-SENT** - 表示在发送了一个连接请求后等待一个匹配的连接请求。

**SYN-RECEIVED** - represents waiting for a confirming connection request acknowledgment after having both received and sent a connection request.  
**SYN-RECEIVED** - 表示在收到和发送连接请求后，等待确认连接请求的确认。

**ESTABLISHED** - represents an open connection, data received can be delivered to the user. The normal state for the data transfer phase of the connection.  
**ESTABLISHED** - 代表一个已建立的连接，收到的数据可以传递给用户，是连接数据传输阶段的正常状态。

**FIN-WAIT-1** - represents waiting for a connection termination request from the remote TCP peer, or an acknowledgment of the connection termination request previously sent.  
**FIN-WAIT-1** - 表示等待来自远程对等 TCP 的连接终止请求，或等待之前发送的终止连接请求的确认。

**FIN-WAIT-2** - represents waiting for a connection termination request from the remote TCP peer.  
**FIN-WAIT-2** - 表示等待来自远程对等 TCP 的连接终止请求。

**CLOSE-WAIT** - represents waiting for a connection termination request from the local user.  
**CLOSE-WAIT** - 表示等待本端用户的连接终止请求。

**CLOSING** - represents waiting for a connection termination request acknowledgment from the remote TCP peer.  
**CLOSING** - 表示等待来自远程对等 TCP 的连接终止请求确认。

**LAST-ACK** - represents waiting for an acknowledgment of the connection termination request previously sent to the remote TCP peer(this termination request sent to the remote TCP peer already included an acknowledgment of the termination request sent from the remote TCP peer).
**LAST-ACK** - 表示等待对先前发送到远程对等 TCP 的连接终止请求的确认（发送给远程对等 TCP 的这个终止请求已经包括了远程对等 TCP 发送的终止请求的确认）。

**TIME-WAIT** - represents waiting for enough time to pass to be sure the remote TCP peer received the acknowledgment of its connection termination request and to avoid new connections being impacted by delayed segments from previous connections.  
**TIME-WAIT** - 表示等待足够的时间通过以确保远程对等 TCP 收到其连接终止请求的确认，并避免新连接受到先前连接的延迟段的影响。

**CLOSED** - represents no connection state at all.  
**CLOSED** - 表示没有连接的状态。

A TCP connection progresses from one state to another in response to events.  
TCP 连接根据事件从一个状态转换到另一个状态。

The events are the user calls, OPEN, SEND, RECEIVE, CLOSE, ABORT, and STATUS; the incoming segments, particularly those containing the SYN and FIN flags; and timeouts.  
这些事件是用户调用 OPEN、SEND、RECEIVE、CLOSE、ABORT 和 STATUS；收到 TCP 段，特别是包含 SYN 和 FIN 标志的段；以及超时。

The OPEN call specifies whether connection establishment is to be actively pursued, or to be passively waited for.  
OPEN 调用指定是主动要求连接建立，还是被动等待。

A passive OPEN request means that the process wants to accept incoming connection requests, in contrast to an active OPEN attempting to initiate a connection.  
被动 OPEN 请求意味着进程想要接受传入的连接请求，这与主动 OPEN 尝试启动连接相反。

The state diagram in Figure 5 illustrates only state changes, together with the causing events and resulting actions, but addresses neither error conditions nor actions that are not connected with state changes.  
图 5 中的状态图只说明了状态的变化，以及引起的事件和触发的行为，但既没有涉及错误条件，也没有涉及与状态变化无关的行为。

In a later section, more detail is offered with respect to the reaction of the TCP implementation to events.  
在后面的章节中，将提供关于 TCP 对事件响应的更多细节。

Some state names are abbreviated or hyphenated differently in the diagram from how they appear elsewhere in the document.

NOTA BENE: This diagram is only a summary and must not be taken as the total specification. Many details are not included.  
注意：此图只是一个摘要，不能作为全部规范，许多细节未包括在内。

```
                               +---------+ ---------\      active OPEN
                               |  CLOSED |            \    -----------
                               +---------+<---------\   \   create TCB
                                 |     ^              \   \  snd SYN
                    passive OPEN |     |   CLOSE        \   \
                    ------------ |     | ----------       \   \
                     create TCB  |     | delete TCB         \   \
                                 V     |                      \   \
             rcv RST (note 1)  +---------+            CLOSE    |    \
          -------------------->|  LISTEN |          ---------- |     |
         /                     +---------+          delete TCB |     |
        /           rcv SYN      |     |     SEND              |     |
       /           -----------   |     |    -------            |     V
   +--------+      snd SYN,ACK  /       \   snd SYN          +--------+
   |        |<-----------------           ------------------>|        |
   |  SYN   |                    rcv SYN                     |  SYN   |
   |  RCVD  |<-----------------------------------------------|  SENT  |
   |        |                  snd SYN,ACK                   |        |
   |        |------------------           -------------------|        |
   +--------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +--------+
      |         --------------   |     |   -----------
      |                x         |     |     snd ACK
      |                          V     V
      |  CLOSE                 +---------+
      | -------                |  ESTAB  |
      | snd FIN                +---------+
      |                 CLOSE    |     |    rcv FIN
      V                -------   |     |    -------
   +---------+         snd FIN  /       \   snd ACK         +---------+
   |  FIN    |<----------------          ------------------>|  CLOSE  |
   | WAIT-1  |------------------                            |   WAIT  |
   +---------+          rcv FIN  \                          +---------+
     | rcv ACK of FIN   -------   |                          CLOSE  |
     | --------------   snd ACK   |                         ------- |
     V        x                   V                         snd FIN V
   +---------+               +---------+                    +---------+
   |FINWAIT-2|               | CLOSING |                    | LAST-ACK|
   +---------+               +---------+                    +---------+
     |              rcv ACK of FIN |                 rcv ACK of FIN |
     |  rcv FIN     -------------- |    Timeout=2MSL -------------- |
     |  -------            x       V    ------------        x       V
      \ snd ACK              +---------+delete TCB          +---------+
        -------------------->|TIME-WAIT|------------------->| CLOSED  |
                             +---------+                    +---------+
```

{{< center >}}
Figure 5: TCP Connection State Diagram  
图 5：TCP 连接状态图
{{< /center >}}

The following notes apply to Figure 5:  
以下注释适用于图 5：

- Note 1: The transition from SYN-RECEIVED to LISTEN on receiving a RST is conditional on having reached SYN-RECEIVED after a passive OPEN.  
  在接收到 RST 时从 SYN-RECEIVED 到 LISTEN 的转换以在被动 OPEN 之后达到 SYN-RECEIVED 为条件。

- Note 2: The figure omits a transition from FIN-WAIT-1 to TIME-WAIT if a FIN is received and the local FIN is also acknowledged.  
  如果收到 FIN 并且本地 FIN 也得到确认，则图中省略了从 FIN-WAIT-1 到 TIME-WAIT 的转换。

- Note 3: A RST can be sent from any state with a corresponding transition to TIME-WAIT (see [70] for rationale).  
  RST 可以从任何状态发送，并相应地转换为 TIME-WAIT（基本原理参见 [70]）。

  These transitions are not explicitly shown; otherwise, the diagram would become very difficult to read.  
  这些转换没有明确显示；否则，图表将变得很难阅读。

  Similarly, receipt of a RST from any state results in a transition to LISTEN or CLOSED, though this is also omitted from the diagram for legibility.  
  类似地，从任何状态接收到 RST 都会导致转换为 LISTEN 或 CLOSED，尽管为了便于阅读，图中也省略了这一点。

### 序列号

**3.4. Sequence Numbers**

A fundamental notion in the design is that every octet of data sent over a TCP connection has a sequence number.  
TCP 设计中的一个基本概念是，通过 TCP 连接发送的每个字节的数据都有一个序列号。

Since every octet is sequenced, each of them can be acknowledged.  
由于每个字节都是有顺序的，所以每个字节都可以被确认。

The acknowledgment mechanism employed is cumulative so that an acknowledgment of sequence number X indicates that all octets up to but not including X have been received.  
TCP 所采用的确认机制是累积性的，因此序列号为 X 的确认表示已经收到了之前但不包括 X 的所有字节。

This mechanism allows for straightforward duplicate detection in the presence of retransmission.  
这种机制使得在存在重传的情况下可以直接进行重复检测。

The numbering scheme of octets within a segment is as follows: the first data octet immediately following the header is the lowest numbered, and the following octets are numbered consecutively.  
段内字节的编号方案如下：紧跟在头部之后的第一个字节数据编号最小，随后的字节连续编号。

It is essential to remember that the actual sequence number space is finite, though large.  
需要记住，实际的序列号范围是有限的，尽管很大。

This space ranges from 0 to 2\*\*32 - 1.  
这个范围是从 0 到 2\*\*32-1 。

Since the space is finite, all arithmetic dealing with sequence numbers must be performed modulo 2\*\*32.  
由于范围是有限的，所有处理序列号的运算都必须模 2\*\*32。

This unsigned arithmetic preserves the relationship of sequence numbers as they cycle from 2\*\*32 - 1 to 0 again.  
这种无符号算术保留了序列号之间的关系，因为它们从 2\*\*32-1 再重新到 0。

There are some subtleties to computer modulo arithmetic, so great care should be taken in programming the comparison of such values.  
计算机模运算有一些细微的差异，所以在编程比较这些值时应该非常小心。

The symbol "=<" means "less than or equal" (modulo 2\*\*32).  
符号 "=<" 表示 "小于或等于" (模 2\*\*32)。

The typical kinds of sequence number comparisons that the TCP implementation must perform include:  
TCP 实现中需要操作的典型的序列号比较包括：

(a) Determining that an acknowledgment refers to some sequence number sent but not yet acknowledged.  
(a) 确定一个确认是对应某个已发送但尚未确认的序列号。

(b) Determining that all sequence numbers occupied by a segment have been acknowledged (e.g., to remove the segment from a retransmission queue).  
(b) 确定 TCP 段所占用的所有序列号都已被确认（例如，从重传队列中删除该 TCP 段）。

(c) Determining that an incoming segment contains sequence numbers which are expected (i.e., that the segment "overlaps" the receive window).  
(c) 确定一个收到的 TCP 段包含预期的序列号（即该 TCP 段与接收窗口"重叠"）。

In response to sending data, the TCP endpoint will receive acknowledgments.  
TCP 将收到确认作为对发送数据的响应。

The following comparisons are needed to process the acknowledgments.  
在处理确认时需要进行以下比较。

SND.UNA = oldest unacknowledged sequence number  
SND.UNA = 最早的未确认的序列号

SND.NXT = next sequence number to be sent  
SND.NXT = 下一个要发送的序列号

SEG.ACK = acknowledgment from the receiving TCP peer (next sequence number expected by the receiving TCP)  
SEG.ACK = 来自接收 TCP 的确认（接收 TCP 所期望的下一个序列号）。

SEG.SEQ = first sequence number of a segment  
SEG.SEQ = TCP 段的第一个序列号

SEG.LEN = the number of octets occupied by the data in the segment (counting SYN and FIN)  
SEG.LEN = 段落中的数据所占的字节数 (包括 SYN 和 FIN)

SEG.SEQ+SEG.LEN-1 = last sequence number of a segment  
SEG.SEQ+SEG.LEN-1 = TCP 段的最后一个序列号

A new acknowledgment (called an "acceptable ack"), is one for which the inequality below holds:  
一个新的确认（即 "可接受的确认"），会满足以下不等式。  
SND.UNA < SEG.ACK =< SND.NXT

A segment on the retransmission queue is fully acknowledged if the sum of its sequence number and length is less than the acknowledgment value in the incoming segment.  
如果重传队列中的一个 TCP 段的序列号和长度之和小于收到段的确认值，则该段被完全确认。

When data is received the following comparisons are needed:  
当收到数据时，需要进行以下比较：

RCV.NXT = next sequence number expected on an incoming segments, and is the left or lower edge of the receive window  
RCV.NXT = 下一个预期收到 TCP 段的序列号，也是接收窗口的左边界或下限。

RCV.NXT+RCV.WND-1 = last sequence number expected on an incoming segment, and is the right or upper edge of the receive window  
RCV.NXT+RCV.WND-1 = 最后一个预期收到 TCP 段的序列号，也是接收窗口的右边界或上限。

SEG.SEQ = first sequence number occupied by the incoming segment  
SEG.SEQ = 收到 TCP 段的第一个序列号

SEG.SEQ+SEG.LEN-1 = last sequence number occupied by the incoming segment  
SEG.SEQ+SEG.LEN-1 = 收到 TCP 段的最后一个序列号

A segment is judged to occupy a portion of valid receive sequence space if  
在下列情况下，一个 TCP 段被判断为占据了有效接收序列范围的一部分

RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND

or  
或

RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND

The first part of this test checks to see if the beginning of the segment falls in the window, the second part of the test checks to see if the end of the segment falls in the window; if the segment passes either part of the test it contains data in the window.  
该测试的第一部分检查段的开头是否落在窗口中，测试的第二部分检查段的结尾是否落在窗口中；如果该段通过了测试的任何一部分，则它在窗口中包含数据。

Actually, it is a little more complicated than this. Due to zero windows and zero-length segments, we have four cases for the acceptability of an incoming segment:  
实际上，情况比这更复杂一些。由于零窗口和零长度的 TCP 段，我们有四种情况来判断一个收到的 TCP 段是否可接受：

{{< center >}}

```
+=========+=========+======================================+
| Segment | Receive | Test                                 |
| Length  | Window  |                                      |
+=========+=========+======================================+
| 0       | 0       | SEG.SEQ = RCV.NXT                    |
+---------+---------+--------------------------------------+
| 0       | >0      | RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND |
+---------+---------+--------------------------------------+
| >0      | 0       | not acceptable                       |
+---------+---------+--------------------------------------+
| >0      | >0      | RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND |
|         |         |                                      |
|         |         | or                                   |
|         |         |                                      |
|         |         | RCV.NXT =< SEG.SEQ+SEG.LEN-1 <       |
|         |         | RCV.NXT+RCV.WND                      |
+---------+---------+--------------------------------------+
```

Table 5: Segment Acceptability Tests  
表 5：段可接受性测试
{{< /center >}}

Note that when the receive window is zero no segments should be acceptable except ACK segments.  
请注意，当接收窗口为零时，除了 ACK 段外，不应接受其他 TCP 段。

Thus, it is possible for a TCP implementation to maintain a zero receive window while transmitting data and receiving ACKs.  
因此，TCP 实现应该有可能在传输数据和接收 ACK 的同时保持一个零接收窗口。

A TCP receiver MUST process the RST and URG fields of all incoming segments, even when the receive window is zero (MUST-66).
即使接收窗口为零，TCP 也必须处理所有接收段的 RST 和 URG 字段 (MUST-66)。

We have taken advantage of the numbering scheme to protect certain control information as well.
我们还利用了编号方案来保护某些控制信息。

This is achieved by implicitly including some control flags in the sequence space so they can be retransmitted and acknowledged without confusion (i.e., one and only one copy of the control will be acted upon).  
这是通过在序列空间中隐含地包括一些控制标志来实现的，使得它们可以被重发和确认而不会产生混淆(即，将对控制的一个且仅一个副本进行操作)。

Control information is not physically carried in the segment data space.  
控制信息不实际在 TCP 段数据空间中携带。

Consequently, we must adopt rules for implicitly assigning sequence numbers to control.
因此，我们必须采用隐式分配序列号的规则来控制。

The SYN and FIN are the only controls requiring this protection, and these controls are used only at connection opening and closing.  
SYN 和 FIN 是唯一需要这种保护的控制，而且这些控制只在连接打开和关闭时使用。

For sequence number purposes, the SYN is considered to occur before the first actual data octet of the segment in which it occurs, while the FIN is considered to occur after the last actual data octet in a segment in which it occurs.  
就序列号而言，SYN 被认为发生在其所在 TCP 段的实际数据第一个字节之前，而 FIN 被认为发生在其所在段的实际数据的最后一个字节之后。

The segment length (SEG.LEN) includes both data and sequence space-occupying controls.  
TCP 段的长度包括数据和占用序列空间的控制信息。

When a SYN is present then SEG.SEQ is the sequence number of the SYN.  
当存在 SYN 时，SEG.SEQ 是 SYN 的序列号。

#### 初始序列号的选择

**3.4.1. Initial Sequence Number Selection**

A connection is defined by a pair of sockets. Connections can be reused.  
一个连接是由一对套接字确定的，连接可以重复使用。

New instances of a connection will be referred to as incarnations of the connection.  
连接的新实例会用来表示连接。

The problem that arises from this is -- "how does the TCP implementation identify duplicate segments from previous incarnations of the connection?"  
由此产生的问题是 -- "TCP 实现如何识别来自以前连接中的重复段？"

This problem becomes apparent if the connection is being opened and closed in quick succession, or if the connection breaks with loss of memory and is then reestablished.  
如果快速连续地打开和关闭连接，或者如果连接因内存丢失而断开，然后重新建立，则此问题会变得明显。

To support this, the TIME-WAIT state limits the rate of connection reuse, while the initial sequence number selection described below further protects against ambiguity about which incarnation of a connection an incoming packet corresponds to.  
为了支持这一点，TIME-WAIT 状态限制了连接重用的速度，而下面描述的初始序列号选择进一步防止关于接收数据包对应于哪个连接实例的歧义。

To avoid confusion, we must prevent segments from one incarnation of a connection from being used while the same sequence numbers may still be present in the network from an earlier incarnation.  
为了防止出现混乱，我们必须防止使用来自先前连接中有相同序列号的数据段。

We want to assure this even if a TCP endpoint crashes and loses all knowledge of the sequence numbers it has been using.  
我们要保证这一点，即使 TCP 崩溃并失去了它使用的序列号的所有信息。

When new connections are created, an initial sequence number (ISN) generator is employed which selects a new 32 bit ISN.  
当创建新连接时，使用初始序列号(ISN)生成器选择新的 32 位 ISN。

There are security issues that result if an off-path attacker is able to predict or guess ISN values [42].  
如果 off-path attacker 能够预测或猜测 ISN 值，则会出现安全问题 [42]。

TCP initial sequence numbers are generated from a number sequence that monotonically increases until it wraps, known loosely as a "clock".  
TCP 初始序列号是由一个数字序列生成的，该数字序列单调递增，直到它回绕，广泛地称为 "时钟"。

This clock is a 32-bit counter that typically increments at least once every roughly 4 microseconds, although it is neither assumed to be realtime nor precise, and need not persist across reboots.  
这个时钟是一个 32 位计数器，通常大约每 4 微秒至少递增一次，尽管它既不假定是实时的也不精确，并且不需要在重新启动后持续存在。

The clock component is intended to ensure that with a Maximum Segment Lifetime (MSL), generated ISNs will be unique since it cycles approximately every 4.55 hours, which is much longer than the MSL.  
时钟组件旨在确保使用最大段寿命 (MSL) 生成的 ISN 将是唯一的，因为它大约每 4.55 小时循环一次，这比 MSL 长得多。

Please note that for modern networks that support high data rates where the connection might start and quickly advance sequence numbers to overlap within the MSL, it is recommended to implement the Timestamp Option as mentioned later in Section 3.4.3.  
请注意，对于支持高数据率的现代网络，连接可能开始并快速推进序列号，在 MSL 内重叠，建议实现 3.4.3 节后面提到的时间戳选项。

A TCP implementation MUST use the above type of "clock" for clock-driven selection of initial sequence numbers (MUST-8), and SHOULD generate its initial sequence numbers with the expression:  
对于初始序列号(MUST-8)的时钟驱动选择，TCP 实现必须使用上述类型的 "时钟"，并且应使用以下表达式生成其初始序列号：

ISN = M + F(localip, localport, remoteip, remoteport, secretkey)

where M is the 4 microsecond timer, and F() is a pseudorandom function (PRF) of the connection's identifying parameters ("localip, localport, remoteip, remoteport") and a secret key ("secretkey") (SHLD-1).  
其中，M 是 4 微秒计时器，F()是连接的标识参数("localip, localport, remoteip, remoteport")和密钥("seckkey")(SHLD-1)的伪随机函数(PRF)。

F() MUST NOT be computable from the outside (MUST-9), or an attacker could still guess at sequence numbers from the ISN used for some other connection.  
F()不能从外部计算出来(MUST-9)，否则攻击者仍然可以从用于其他连接的 ISN 中猜测序列号。

The PRF could be implemented as a cryptographic hash of the concatenation of the TCP connection parameters and some secret data.  
PRF 可以被实现为 TCP 连接参数和一些秘密数据的级联的密码散列。

For discussion of the selection of a specific hash algorithm and management of the secret key data, please see Section 3 of [42].  
关于特定散列算法的选择和密钥数据的管理的讨论，请参见[42]的第 3 节。

For each connection there is a send sequence number and a receive sequence number.  
对于每个连接，都有一个发送序列号和一个接收序列号。

The initial send sequence number (ISS) is chosen by the data sending TCP peer, and the initial receive sequence number (IRS) is learned during the connection-establishing procedure.  
初始发送序列号(ISS)由数据发送 TCP 选择，而初始接收序列号(IRS)在连接建立过程中得到。

For a connection to be established or initialized, the two TCP peers must synchronize on each other's initial sequence numbers.  
如果要建立或初始化的连接，两个 TCP 必须同步对方的初始序列号。

This is done in an exchange of connection-establishing segments carrying a control bit called "SYN" (for synchronize) and the initial sequence numbers.  
这是通过交换建立连接的信息来完成的，这些信息带有一个称为 "SYN"（用于同步）的控制位和初始序列号。

As a shorthand, segments carrying the SYN bit are also called "SYNs".  
简而言之，携带 SYN 位的消息也称为 "SYNs"。

Hence, the solution requires a suitable mechanism for picking an initial sequence number and a slightly involved handshake to exchange the ISNs.  
因此，该解决方案需要一个合适的机制来挑选初始序列号，并需要一个稍微复杂的握手来交换 ISN。

The synchronization requires each side to send its own initial sequence number and to receive a confirmation of it in acknowledgment from the remote TCP peer.  
同步需要每一方发送自己的初始序列号，并从远端的 ACK 中得到确认。

Each side must also receive the remote peer's initial sequence number and send a confirming acknowledgment.  
每一方还必须收到远端的初始序列号，并发送确认的 ACK。

(1) A --> B SYN my sequence number is X  
(1) A --> B 同步自己的序列号 X

(2) A <-- B ACK your sequence number is X  
(2) A <-- B 确认你的序列号是 X

(3) A <-- B SYN my sequence number is Y  
(3) A <-- B 同步自己的序列号 Y

(4) A --> B ACK your sequence number is Y  
(4) A --> B 确认你的序列号是 Y

Because steps 2 and 3 can be combined in a single message this is called the three-way (or three message) handshake (3WHS).  
由于第 2 和第 3 步可以结合在一个消息中，这被称为三次（或三次信息）握手(3WHS)。

A 3WHS is necessary because sequence numbers are not tied to a global clock in the network, and TCP implementations may have different mechanisms for picking the ISNs.  
"三次握手" 是必要的，因为序列号没有绑定到网络中的全局时钟，并且 TCP 可能有不同的机制来挑选 ISN。

The receiver of the first SYN has no way of knowing whether the segment was an old one or not, unless it remembers the last sequence number used on the connection (which is not always possible), and so it must ask the sender to verify this SYN.  
第一个 SYN 的接收者没有办法知道这个 TCP 段是否是一个旧的延迟段，除非它记得连接上使用的最后一个序列号（这并不总是可能的），所以它必须要求发送者验证这个 SYN。

The three-way handshake and the advantages of a clock-driven scheme for ISN selection are discussed in [69].  
在[3]中讨论了 "三次握手" 和 ISN 选择 "时钟驱动" 方案的优势。

#### 知道什么时候该保持静默

**3.4.2. Knowing When to Keep Quiet**

A theoretical problem exists where data could be corrupted due to confusion between old segments in the network and new ones after a host reboots if the same port numbers and sequence space are reused.  
如果重复使用相同的端口号和序列空间，则在主机重新启动后，由于网络中的旧网段和新网段之间的混淆，理论上存在可能导致数据损坏的问题。

The "quiet time" concept discussed below addresses this, and the discussion of it is included for situations where it might be relevant, although it is not felt to be necessary in most current implementations.  
下面讨论的 "静默时间" 概念解决了这一问题，并将它的讨论包括在可能与之相关的情况下，尽管它在大多数当前实现中并不是必要的。

The problem was more relevant earlier in the history of TCP.  
在 TCP 历史的早期，这个问题更为相关。

In practical use on the Internet today, the error-prone conditions are sufficiently unlikely that it is safe to ignore.  
在今天互联网的实际使用中，容易出错的情况不太可能发生，因此可以放心地忽略。

Reasons why it is now negligible include: (a) ISS and ephemeral port randomization have reduced likelihood of reuse of port numbers and sequence numbers after reboots, (b) the effective MSL of the Internet has declined as links have become faster, and (c) reboots often taking longer than an MSL anyways.  
它现在可以忽略不计的原因包括：  
(a) ISS 和临时端口随机化降低了重新启动后重用端口号和序列号的可能性。  
(b) 随着链接变得更快，互联网的有效 MSL 已经下降。  
(c) 无论如何，重新启动通常比 MSL 花费的时间更长。

To be sure that a TCP implementation does not create a segment carries a sequence number that may be duplicated by an old segment remaining in the network, the TCP endpoint must keep quiet for a MSL before assigning any sequence numbers upon starting up or recovering from a situation where memory of sequence numbers in use was lost.  
为了确保 TCP 实现不会创建一个携带与网络中旧 TCP 段中序列号重复的 TCP 段，TCP 在启动时或从丢失当前使用序列号内存的崩溃中恢复时，在分配任何序列号之前保持最大段存活时间（MSL）的静默时间。

For this specification the MSL is taken to be 2 minutes.  
在本规范中，MSL 是 2 分钟。

This is an engineering choice, and may be changed if experience indicates it is desirable to do so.  
这是一个工程选择，它可能会根据经验改变。

Note that if a TCP endpoint is reinitialized in some sense, yet retains its memory of sequence numbers in use, then it need not wait at all; it must only be sure to use sequence numbers larger than those recently used.  
注意，如果一个 TCP 在某种情况被重新初始化，但保留了其正在使用的序列号的内存，那么它不需要等待；它只需要确保使用比最近使用的序列号大的序列号。

#### TCP 静默时间的概念

**3.4.3. The TCP Quiet Time Concept**

Hosts that for any reason lose knowledge of the last sequence numbers transmitted on each active (i.e., not closed) connection shall delay emitting any TCP segments for at least the agreed MSL in the internet system of which the host is a part.  
如果主机因为任何原因没有保留在每个活动（即未关闭）连接上传输的最后一个序列号的任何信息，则应至少延迟商定的最大段生命周期（MSL）后，再发送任何 TCP 段到主机所处的 internet 系统中。

In the paragraphs below, an explanation for this specification is given.  
在下面的段落中，给出了对该规范的解释。

TCP implementors may violate the "quiet time" restriction, but only at the risk of causing some old data to be accepted as new or new data rejected as old duplicated by some receivers in the internet system.  
TCP 实现者可以会违反 "quiet time" 限制，但是可能存在导致某些旧数据被接受为新数据或新数据被 internet 系统中的某些接收方认为是旧的重复数据而拒收的风险。

TCP endpoints consume sequence number space each time a segment is formed and entered into the network output queue at a source host.  
每次生成段并加入到源主机的网络输出队列时，TCP 都会消耗序列号空间。

The duplicate detection and sequencing algorithm in the TCP protocol relies on the unique binding of segment data to sequence space to the extent that sequence numbers will not cycle through all 2\*\*32 values before the segment data bound to those sequence numbers has been delivered and acknowledged by the receiver and all duplicate copies of the segments have "drained" from the internet.  
TCP 协议中的重复检测和排序算法依赖于段数据与序列空间的唯一绑定，因此与这些序列号绑定的段数据被送达并被接收方确认以及段的所有副本从互联网上 "耗尽" 之前，序列号不会在所有 2\*\*32 值中循环。

Without such an assumption, two distinct TCP segments could conceivably be assigned the same or overlapping sequence numbers, causing confusion at the receiver as to which data is new and which is old.  
如果没有这样的假设，两个不同的 TCP 段可能会被分配相同或重叠的序列号，从而导致接收方无法区分哪些数据是新数据，哪些是旧数据。

Remember that each segment is bound to as many consecutive sequence numbers as there are octets of data and SYN or FIN flags in the segment.  
记住，每个段都绑定到与段中数据和 SYN 或 FIN 标志的字节一样多的连续序列号。

Under normal conditions, TCP implementations keep track of the next sequence number to emit and the oldest awaiting acknowledgment so as to avoid mistakenly reusing a sequence number over before its first use has been acknowledged.  
在正常情况下，TCP 会跟踪下一个要发出的序列号和最旧的等待确认的序列号，以避免在第一次使用得到确认之前错误地重用该序列号。

This alone does not guarantee that old duplicate data is drained from the net, so the sequence space has been made very large to reduce the probability that a wandering duplicate will cause trouble upon arrival.  
仅仅这样并不能保证旧的重复数据从网络中消失，所以序列空间被做得非常大，以减少漫游的重复数据到达后造成麻烦的可能性。

At 2 megabits/sec. it takes 4.5 hours to use up 2\*\*32 octets of sequence space.  
在 2 兆比特/秒的情况下，需要 4.5 小时才能用完 2\*\*32 个字节的序列空间。

Since the maximum segment lifetime in the net is not likely to exceed a few tens of seconds, this is deemed ample protection for foreseeable nets, even if data rates escalate to 10's of megabits/sec.  
由于网络中的段的最大存活时间不太可能超过几十秒，这被认为是对可预见网络的充分保护，即使数据速率升级到 10 兆比特/秒。

At 100 megabits/sec, the cycle time is 5.4 minutes which may be a little short, but still within reason.  
在 100 兆比特/秒时，循环时间为 5.4 分钟，这可能有点短，但仍在合理范围内。

Much higher data rates are possible today, with implications described in the final paragraph of this subsection.  
今天，更高的数据速率是可能的，其影响在本小节的最后一段中描述。

The basic duplicate detection and sequencing algorithm in TCP can be defeated, however, if a source TCP endpoint does not have any memory of the sequence numbers it last used on a given connection.  
然而，如果源 TCP 没有任何关于它在给定连接上最后使用的序列号的内存，则 TCP 中的基础重复检测和排序算法可能会失效。

For example, if the TCP implementation were to start all connections with sequence number 0, then upon the host rebooting, a TCP peer might re-form an earlier connection (possibly after half-open connection resolution) and emit packets with sequence numbers identical to or overlapping with packets still in the network which were emitted on an earlier incarnation of the same connection.  
例如，如果 TCP 以序列号 0 开始所有连接，那么在重新启动时，TCP 可能会重新建立较早的连接（可能在半开连接解析之后）并发出序列号与网络中的数据包相同或重叠的数据包，这些数据包是在同一连接的早期实例下发出的。

In the absence of knowledge about the sequence numbers used on a particular connection, the TCP specification recommends that the source delay for MSL seconds before emitting segments on the connection, to allow time for segments from the earlier connection incarnation to drain from the system.  
在不知道特定连接上使用的序列号的情况下，TCP 规范建议源 TCP 在连接上发送段之前延迟 MSL 秒，以便让来自早期连接实例的段有时间从系统中消失。

Even hosts which can remember the time of day and used it to select initial sequence number values are not immune from this problem (i.e., even if time of day is used to select an initial sequence number for each new connection incarnation).  
即使是可以记住一天中的时间并使用它来选择初始序列号值的主机也不能避免这个问题（即，即使一天中的时间用于为每个新连接化身选择一个初始序列号）。

Suppose, for example, that a connection is opened starting with sequence number S.  
例如，假设一个连接以序列号 S 开始打开。

Suppose that this connection is not used much and that eventually the initial sequence number function (ISN(t)) takes on a value equal to the sequence number, say S1, of the last segment sent by this TCP on a particular connection.  
假设这个连接使用不多，最终初始序列号函数（ISN(t)）的值等于这个 TCP 在特定连接上发送的最后一个段的序列号，例如 S1。

Now suppose, at this instant, the host reboots and establishes a new incarnation of the connection.  
现在，假设在这个时刻，主机重启并建立了一个新的连接的实例。

The initial sequence number chosen is S1 = ISN(t) -- last used sequence number on old incarnation of connection!  
选择的初始序列号是 S1 = ISN(t) -- 旧的连接的最后使用的序列号!

If the recovery occurs quickly enough, any old duplicates in the net bearing sequence numbers in the neighborhood of S1 may arrive and be treated as new packets by the receiver of the new incarnation of the connection.  
如果恢复发生得足够快，网络中任何带有 S1 附近序列号的旧重复数据都可能到达，并被新的连接实例的接收者视为新的数据包。

The problem is that the recovering host may not know for how long it was down between rebooting nor does it know whether there are still old duplicates in the system from earlier connection incarnations.  
问题是正在恢复的主机可能不知道它重启了多长时间，也不知道系统中是否仍然存在来自早期连接实例的旧的重复数据。

One way to deal with this problem is to deliberately delay emitting segments for one MSL after recovery from a crash- this is the "quiet time" specification.  
解决这个问题的一种方法是在从崩溃中恢复后故意延迟一个 MSL 再发送段，这是 "静默时间" 规范。

Hosts that prefer to avoid waiting are willing to risk possible confusion of old and new packets at a given destination may choose not to wait for the "quie t time".  
喜欢避免等待的主机，愿意冒着在目的地可能出现新旧数据包混淆的风险，可以选择不等待 "静默时间"。

Implementors may provide TCP users with the ability to select on a connection-by-connection basis whether to wait after a reboot, or may informally implement the "quiet time" for all connections.  
实现者可以为 TCP 用户提供在连接基础上选择是否在崩溃后等待的能力，或者可以非正式地为所有连接实现 "静默时间"。

Obviously, even where a user selects to "wait", this is not necessary after the host has been "up" for at least MSL seconds.  
很明显，即使用户选择了 "等待"，在主机至少 "启动" 了 MSL 秒之后，也没有必要这样做。

To summarize: every segment emitted occupies one or more sequence numbers in the sequence space, the numbers occupied by a segment are "busy" or "in use" until MSL seconds have passed.  
总结一下：每个发出的段在序列空间中占据一个或多个序列号，段所占据的序列号是 "忙" 或 "使用中"，直到 MSL 秒过去。

Upon rebooting, a block of space-time is occupied by the octets and SYN or FIN flags of any potentially still in-flight segments.  
重启时，一个时空块被任何仍在网络中的段的数据和 SYN 或 FIN 标志占据。

If a new connection is started too soon and uses any of the sequence numbers in the space-time footprint of those potentially still in-flight segment of the previous connection incarnation, there is a potential sequence number overlap area which could cause confusion at the receiver.  
如果新连接启动得太早，并且使用了前一个连接实例的仍在网络中的段的时空足迹中的任何序列号，则存在潜在的序列号重叠区域，这可能会导致接收方混淆。

High-performance cases will have shorter cycle times than those in the megabits per second that the base TCP design described above considers.  
高性能情况下的周期时间将比上述基本 TCP 设计考虑的兆比特每秒的周期时间更短。

At 1 Gbps, the cycle time is 34 seconds, only 3 seconds at 10 Gbps, and around a third of a second at 100 Gbps.  
在 1 Gbps 时，周期时间为 34 秒，在 10 Gbps 时仅为 3 秒，在 100 Gbps 时约为三分之一秒。

In these higher-performance cases, TCP Timestamp Options and Protection Against Wrapped Sequences (PAWS) [47] provide the needed capability to detect and discard old duplicates.  
在这些更高性能的情况下，TCP 时间戳选项和针对包装序列的保护(PAWS)[47]提供了检测和丢弃旧副本所需的能力。

### 建立连接

**3.5. Establishing a Connection**

The "three-way handshake" is the procedure used to establish a connection.  
"三次握手" 是用于建立连接的过程。

This procedure normally is initiated by one TCP peer and responded to by another TCP peer.  
这个过程通常由一个 TCP 发起，由另一个 TCP 响应。

The procedure also works if two TCP peers simultaneously initiate the procedure.  
如果两个 TCP 同时发起连接，该过程也应正常工作。

When simultaneous attempt occurs, each TCP peer receives a "SYN" segment which carries no acknowledgment after it has sent a "SYN".  
当同时尝试建立连接时，TCP 在发送 "SYN" 后，收到没有携带确认的 "SYN" 段。

Of course, the arrival of an old duplicate "SYN" segment can potentially make it appear, to the recipient, that a simultaneous connection initiation is in progress.  
当然，当接收者收到一个旧的重复的 "SYN" 段时，有可能会认为是同时建立连接。

Proper use of "reset" segments can disambiguate these cases.  
适当使用 "reset" 段可以消除这些情况。

Several examples of connection initiation follow.  
下面是几个建立连接的例子。

Although these examples do not show connection synchronization using data-carrying segments, this is perfectly legitimate, so long as the receiving TCP endpoint doesn't deliver the data to the user until it is clear the data is valid (i.e., the data must be buffered at the receiver until the connection reaches the ESTABLISHED state, given that the three-way handshake reduces the possibility of false connections).  
虽然这些例子中连接同步没有显示携带数据，这是完全可以的，在接收 TCP 明确数据有效之前，它不向用户传递数据（即这些数据必须先放在接收者的缓存中，直到连接达到 ESTABLISHED 状态，因为三方握手减少了错误连接的可能性）。

It is the implementation of a trade-off between memory and messages to provide information for this checking.  
它是内存和消息之间的权衡的实现，为该检查提供信息。

The simplest 3WHS is shown in figure 6.  
最简单的三次握手如图 6 所示。

The figures should be interpreted in the following way.  
这些符号应作如下解释。

Each line is numbered for reference purposes.  
每行都有编号，以便参考。

Right arrows (-->) indicate departure of a TCP segment from TCP peer A to TCP peer B, or arrival of a segment at B from A.  
右箭头 (-->) 表示从 TCP A 发送到 TCP B 的 TCP 段，或 B 接收到 A 的 TCP 段。

Left arrows (<--), indicate the reverse.  
左箭头 (<--) 表示相反方向。

Ellipsis (...) indicates a segment which is still in the network (delayed).  
省略号 (...) 表示仍在网络中的 TCP 段(延迟了)。

Comments appear in parentheses.  
括号中的是注释。

TCP connection states represent the state AFTER the departure or arrival of the segment (whose contents are shown in the center of each line).  
TCP 状态表示数据段发送或到达后的状态(其内容显示在每行的中间)。

Segment contents are shown in abbreviated form, with sequence number, control flags, and ACK field.  
TCP 段的内容以缩写的形式显示，包括序列号、控制标志和 ACK 字段。

Other fields such as window, addresses, lengths, and text have been left out in the interest of clarity.  
为清楚起见，省略了其他字段，如窗口、地址、长度和数据。

```
      TCP Peer A                                            TCP Peer B
  1.  CLOSED                                                LISTEN
  2.  SYN-SENT    --> <SEQ=100><CTL=SYN>                --> SYN-RECEIVED
  3.  ESTABLISHED <-- <SEQ=300><ACK=101><CTL=SYN,ACK>   <-- SYN-RECEIVED
  4.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK>       --> ESTABLISHED
  5.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK><DATA> --> ESTABLISHED
```

{{< center >}}
Figure 6: Basic Three-Way Handshake for Connection Synchronization  
图 6：用于连接同步的基础三次握手

{{< /center >}}

In line 2 of figure 6, TCP peer A begins by sending a SYN segment indicating that it will use sequence numbers starting with sequence number 100.  
在图 9 的第 2 行，TCP A 开始发送一个 SYN 段，表明它将使用从序列号 100 开始的序列号。

In line 3, TCP peer B sends a SYN and acknowledges the SYN it received from TCP peer A.  
在第 3 行，TCP B 发送了一个 SYN，并确认了它从 TCP A 收到的 SYN。

Note that the acknowledgment field indicates TCP peer B is now expecting to hear sequence 101, acknowledging the SYN which occupied sequence 100.  
注意，确认字段表明 TCP B 现在期望收到到序列 101，确认收到序列 100 的 SYN。

At line 4, TCP peer A responds with an empty segment containing an ACK for TCP B's SYN; and in line 5, TCP A sends some data.  
在第 4 行，TCP A 发送一个包含 ACK 的空段回应 TCP B 的 SYN；在第 5 行，TCP A 发送了一些数据。

Note that the sequence number of the segment in line 5 is the same as in line 4 because the ACK does not occupy sequence number space (if it did, we would wind up ACKing ACK's!).  
注意，第 5 行的 TCP 段的序列号与第 4 行相同，因为 ACK 不占用序列号空间（如果它占用了，我们就会变成 ACK 的 ACK！）

Simultaneous initiation is only slightly more complex, as is shown in figure 7.  
同时建立连接只是稍微复杂一些，如图 7 所示。

Each TCP peer's connection state cycles from CLOSED to SYN-SENT to SYN-RECEIVED to ESTABLISHED.  
每个 TCP 的连接状态从 CLOSED 到 SYN-SENT 到 SYN-RECEIVED 到 ESTABLISHED 循环。

```
      TCP Peer A                                       TCP Peer B
  1.  CLOSED                                           CLOSED
  2.  SYN-SENT     --> <SEQ=100><CTL=SYN>              ...
  3.  SYN-RECEIVED <-- <SEQ=300><CTL=SYN>              <-- SYN-SENT
  4.               ... <SEQ=100><CTL=SYN>              --> SYN-RECEIVED
  5.  SYN-RECEIVED --> <SEQ=100><ACK=301><CTL=SYN,ACK> ...
  6.  ESTABLISHED  <-- <SEQ=300><ACK=101><CTL=SYN,ACK> <-- SYN-RECEIVED
  7.               ... <SEQ=101><ACK=301><CTL=ACK>     --> ESTABLISHED
```

{{< center >}}
Figure 7: Simultaneous Connection Synchronization  
图 7：同时连接同步
{{< /center >}}

A TCP implementation MUST support simultaneous open attempts (MUST-10).  
TCP 实现必须支持同时打开尝试(必须-10)。

Note that a TCP implementation MUST keep track of whether a connection has reached SYN-RECEIVED state as the result of a passive OPEN or an active OPEN (MUST-11).  
注意，TCP 实现必须跟踪连接是由于被动打开还是主动打开(MUST-11)而达到 SYN-RECEIVED 状态。

The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.  
三次握手的主要原因是为了防止旧的重复连接启动造成混乱。

To deal with this, a special control message, reset, is specified.  
为了解决这个问题，我们指定了一个特殊的控制消息--reset。

If the receiving TCP is in a non-synchronized state (i.e., SYN-SENT, SYN-RECEIVED), it returns to LISTEN on receiving an acceptable reset.  
如果接收的 TCP 处于非同步状态（即 SYN-SENT，SYN-RECEIVED），它在收到有效的 reset 时返回到 LISTEN。

If the TCP is in one of the synchronized states (ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT), it aborts the connection and informs its user.  
如果 TCP 处于同步状态之一（ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT），它将中止连接并通知其用户。

We discuss this latter case under "half-open" connections below.  
我们将在下面的 "half-open" 连接下讨论后面一种情况。

```
      TCP Peer A                                           TCP Peer B
  1.  CLOSED                                               LISTEN
  2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               ...
  3.  (duplicate) ... <SEQ=90><CTL=SYN>                --> SYN-RECEIVED
  4.  SYN-SENT    <-- <SEQ=300><ACK=91><CTL=SYN,ACK>   <-- SYN-RECEIVED
  5.  SYN-SENT    --> <SEQ=91><CTL=RST>                --> LISTEN
  6.              ... <SEQ=100><CTL=SYN>               --> SYN-RECEIVED
  7.  SYN-SENT    <-- <SEQ=400><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED
  8.  ESTABLISHED --> <SEQ=101><ACK=401><CTL=ACK>      --> ESTABLISHED
```

{{< center >}}
Figure 8: Recovery from Old Duplicate SYN  
图 8： 从之前重复 SYN 中恢复
{{< /center >}}

As a simple example of recovery from old duplicates, consider figure 8.  
从之前重复 SYN 中恢复的简单示例，请参见图 8。

At line 3, an old duplicate SYN arrives at TCP Peer B.  
在第 3 行，一个之前重复 SYN 到达了 TCP B。

TCP Peer B cannot tell that this is an old duplicate, so it responds normally (line 4).  
TCP B 无法断定这是之前的 SYN，所以它正常响应（第 4 行）。

TCP A detects that the ACK field is incorrect and returns a RST (reset) with its SEQ field selected to make the segment believable.  
TCP A 检测到 ACK 字段不正确，然后返回一个 RST（重置），同时选择 SEQ 字段以使该 TCP 段可信。

TCP B, on receiving the RST, returns to the LISTEN state.  
TCP B 收到 RST 后，返回到 LISTEN 状态。

When the original SYN (pun intended) finally arrives at line 6, the synchronization proceeds normally.  
在第 6 行，当真正的 SYN（双关语）最终到达时，同步正常进行。

If the SYN at line 6 had arrived before the RST, a more complex exchange might have occurred with RST's sent in both directions.  
如果第 6 行的 SYN 在 RST 之前到达，则可能会发生更复杂的交换，双方都会发送 RST。

#### 半开放连接和其他异常情况

**3.5.1. Half-Open Connections and Other Anomalies**

An established connection is said to be "half-open" if one of the TCPs has closed or aborted the connection at its end without the knowledge of the other, or if the two ends of the connection have become desynchronized owing to a failure or reboot that resulted in loss of memory.  
如果其中一个 TCP 在另一个不知道的情况下关闭或中止了连接，或者连接的两端由于错误或重启导致内存丢失而变得不同步，则已建立的连接被称为 "半开放"。

Such connections will automatically become reset if an attempt is made to send data in either direction.  
如果尝试向任一方向发送数据，这种连接将自动重置。

However, half-open connections are expected to be unusual, and the recovery procedure is mildly involved.  
然而，半开放连接被认为是不正常的，恢复过程也涉及到一些问题。

If at site A the connection no longer exists, then an attempt by the user at site B to send any data on it will result in the site B TCP endpoint receiving a reset control message.  
如果站点 A 的连接不再存在，那么站点 B 的用户试图在其上发送任何数据将导致站点 B 的 TCP 收到重置控制消息。

Such a message indicates to the site B TCP endpoint that something is wrong, and it is expected to abort the connection.  
这种消息表明 B 的 TCP 有问题，并希望它能中止连接。

Assume that two user processes A and B are communicating with one another when a failure or reboot occurs causing loss of memory to A's TCP implementation.  
假设两个用户进程 A 和 B 正在相互通信，当发生错误或重启导致 A 的 TCP 实现丢失内存时。

Depending on the operating system supporting A's TCP implementation, it is likely that some error recovery mechanism exists.  
可能会存在一些错误恢复机制，这取决于 TCP A 实现所运行的操作系统。

When the TCP endpoint is up again, A is likely to start again from the beginning or from a recovery point.  
当 TCP 再次启动时，A 可能会从头或从某个恢复点重新启动。

As a result, A will probably try to OPEN the connection again or try to SEND on the connection it believes open.  
因此，A 可能会尝试再次打开连接或尝试在它认为已经打开的连接上发送。

In the latter case, it receives the error message "connection not open" from the local (A's) TCP implementation.  
在后面一种情况下，它会收到来自本地(A) TCP 实现的错误消息 "Connection Not Open"。

In an attempt to establish the connection, A's TCP implementation will send a segment containing SYN.  
在尝试建立连接时，A 的 TCP 实现将发送包含 SYN 的 TCP 段。

This scenario leads to the example shown in figure 9.  
这种情况的示例如图 9 所示。

After TCP Peer A reboots, the user attempts to re-open the connection.  
在 TCP A 崩溃后，用户试图重新打开连接。

TCP Peer B, in the meantime, thinks the connection is open.  
在此期间，TCP B 认为连接是打开的。

```
      TCP Peer A                                       TCP Peer B
  1.  (REBOOT)                              (send 300,receive 100)
  2.  CLOSED                                           ESTABLISHED
  3.  SYN-SENT --> <SEQ=400><CTL=SYN>              --> (??)
  4.  (!!)     <-- <SEQ=300><ACK=100><CTL=ACK>     <-- ESTABLISHED
  5.  SYN-SENT --> <SEQ=100><CTL=RST>              --> (Abort!!)
  6.  SYN-SENT                                         CLOSED
  7.  SYN-SENT --> <SEQ=400><CTL=SYN>              -->
```

{{< center >}}
Figure 9: Half-Open Connection Discovery  
图 9: 半开放连接发现

{{< /center >}}

When the SYN arrives at line 3, TCP Peer B, being in a synchronized state, and the incoming segment outside the window, responds with an acknowledgment indicating what sequence it next expects to hear (ACK 100).  
在第 3 行，当 SYN 到达时，TCP B 处于同步状态，而接收段在接收窗口之外，返回一个确认，ACK=100，表示它期望收到的下一个序列号。

TCP A Peer sees that this segment does not acknowledge anything it sent and, being unsynchronized, sends a reset (RST) because it has detected a half-open connection.  
TCP A 看到这个 TCP 段没有确认它所发送的任何东西，并且由于不同步，发送了一个重置（RST），因为它检测到一个半开放的连接。

TCP B Peer aborts at line 5.  
在第 5 行，TCP B 终止。

TCP Peer A will continue to try to establish the connection; the problem is now reduced to the basic 3-way handshake of figure 6.  
TCP A 会继续尝试建立连接；问题现在简化为图 6 中基础的三次握手。

An interesting alternative case occurs when TCP A Peer reboots and TCP Peer B tries to send data on what it thinks is a synchronized connection.  
另一种有趣的情况是，当 TCP A 崩溃，而 TCP B 尝试在它认为是同步的连接上发送数据时。

This is illustrated in figure 10.  
图 10 说明了这种情况。

In this case, the data arriving at TCP Peer A from TCP Peer B (line 2) is unacceptable because no such connection exists, so TCP Peer A sends a RST.  
在这种情况下，从 TCP B 到达 TCP A 的数据（第 2 行）是无效的，因为不存在这样的连接，所以 TCP A 发送了一个 RST。

The RST is acceptable so TCP Peer B processes it and aborts the connection.  
RST 是有效的，所以 TCP B 处理它并终止连接。

```
      TCP Peer A                                           TCP Peer B
  1.  (REBOOT)                                  (send 300,receive 100)
  2.  (??)    <-- <SEQ=300><ACK=100><DATA=10><CTL=ACK> <-- ESTABLISHED
  3.          --> <SEQ=100><CTL=RST>                   --> (ABORT!!)
```

{{< center >}}
Figure 10: Active Side Causes Half-Open Connection Discovery  
图 10：活跃端导致半开放连接的发现
{{< /center >}}

In Figure 11, two TCP Peers A and B with passive connections waiting for SYN are depicted.  
在图 11 中，描述了两个等待 SYN 的被动连接 TCP A 和 B。

An old duplicate arriving at TCP Peer B (line 2) stirs B into action.  
一个以前重复的 SYN 到达 TCP B（第 2 行），导致 B 做出回应。

A SYN-ACK is returned (line 3) and causes TCP Peer A to generate a RST (the ACK in line 3 is not acceptable).  
一个 SYN-ACK 被返回（第 3 行），并导致 TCP A 产生一个 RST（第 3 行的 ACK 是无效的）。

TCP Peer B accepts the reset and returns to its passive LISTEN state.  
TCP B 接受重置，并返回到其被动的 LISTEN 状态。

```
      TCP Peer A                                    TCP Peer B
  1.  LISTEN                                        LISTEN
  2.       ... <SEQ=Z><CTL=SYN>                -->  SYN-RECEIVED
  3.  (??) <-- <SEQ=X><ACK=Z+1><CTL=SYN,ACK>   <--  SYN-RECEIVED
  4.       --> <SEQ=Z+1><CTL=RST>              -->  (return to LISTEN!)
  5.  LISTEN                                        LISTEN
```

{{< center >}}
Figure 11: Old Duplicate SYN Initiates a Reset on two Passive Sockets  
图 11： 以前重复 SYN 在两个被动套接字上启动重置
{{< /center >}}

A variety of other cases are possible, all of which are accounted for by the following rules for RST generation and processing.  
可能存在多种其他情况，所有这些情况都可以通过以下 RST 生成和处理规则解释。

#### 重置生成

**3.5.2. Reset Generation**

A TCP user or application can issue a reset on a connection at any time, though reset events are also generated by the protocol itself when various error conditions occur, as described below.  
TCP 用户或应用程序可以随时对连接发出重置，但重置事件也会在发生各种错误情况时由协议本身生成，如下所述。

The side of a connection issuing a reset should enter the TIME-WAIT state, as this generally helps to reduce the load on busy servers for reasons described in [70].  
发出重置的连接端应进入 TIME-WAIT 状态，因为这通常有助于减少繁忙服务器上的负载，原因如 [70] 所述。

As a general rule, reset (RST) is sent whenever a segment arrives that apparently is not intended for the current connection.  
作为一般规则，当一个 TCP 段到达时，如果显然不是为当前连接准备的，就应该发送复位（RST）。

A reset must not be sent if it is not clear that this is the case.  
如果不清楚是这种情况，就不应该发送重置段。

There are three groups of states:  
有三组状态：

1.If the connection does not exist (CLOSED), then a reset is sent in response to any incoming segment except another reset.  
1.如果连接不存在（CLOSED），那么除了收到的是一个重置段之外，对其它任何收到的段都会回复一个重置段。

A SYN segment that does not match an existing connection is rejected by this means.  
通过此方法拒绝与现有连接不匹配的 SYN 段。

If the incoming segment has an ACK field, the reset takes its sequence number from the ACK field of the segment; otherwise the reset has sequence number zero and the ACK field is set to the sum of the sequence number and segment length of the incoming segment.  
如果接收的段有 ACK 字段，重置从该段的 ACK 字段中获取其序列号，否则重置的序列号为 0，ACK 字段设置为接收段的序列号和段长之和。

The connection remains in the CLOSED state.  
连接保持关闭状态。

2.If the connection is in any non-synchronized state (LISTEN, SYN-SENT, SYN-RECEIVED), and the incoming segment acknowledges something not yet sent (the segment carries an unacceptable ACK), or if an incoming segment has a security level or compartment (Appendix A.1) that does not exactly match the level and compartment requested for the connection, a reset is sent.  
2.如果连接处于任何非同步状态（LISTEN、SYN-SENT、SYN-RECEIVED），并且接收段确认没有发送的内容（该段携带无效的 ACK），或者如果接收段具有安全等级或区段(附录 A.1)与连接请求的层级和区段不完全匹配，则会发送重置。

If the incoming segment has an ACK field, the reset takes its sequence number from the ACK field of the segment, otherwise the reset has sequence number zero and the ACK field is set to the sum of the sequence number and segment length of the incoming segment.  
如果接收的段有 ACK 字段，重置从该段的 ACK 字段中获取其序列号，否则重置的序列号为 0，ACK 字段设置为接收段的序列号和段长之和。

The connection remains in the same state.  
连接保持相同状态。

3.If the connection is in a synchronized state (ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT), any unacceptable segment (out of window sequence number or unacceptible acknowledgment number) must be responded to with an empty acknowledgment segment (without any user data) containing the current send sequence number and an acknowledgment indicating the next sequence number expected to be received, and the connection remains in the same state.  
3.如果连接处于同步状态（ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、CLOSE-WAIT、CLOSING、LAST-ACK、TIME-WAIT），任何无效的段（超出窗口序列号或无效的确认号）只需回复一个空确认段，其中包含当前发送序列号和一个表示下一个预期接收序列号的确认，并且连接保持相同状态。

If an incoming segment has a security level or compartment that does not exactly match the level and compartment requested for the connection, a reset is sent and connection goes to the CLOSED state. The reset takes its sequence number from the ACK field of the incoming segment.  
如果接收段的安全级别或区段与连接请求的级别和区段不完全匹配，则发送重置，连接进入 CLOSED 状态。 重置从接收段的 ACK 字段中获取其序列号。

#### 重置处理

**3.5.3. Reset Processing**

In all states except SYN-SENT, all reset (RST) segments are validated by checking their SEQ-fields.  
在除 SYN-SENT 之外的所有状态中，所有的重置（RST）段都通过检查其 SEQ 字段来验证。

A reset is valid if its sequence number is in the window.  
如果重置的序列号在窗口范围中，则重置有效。

In the SYN-SENT state (a RST received in response to an initial SYN), the RST is acceptable if the ACK field acknowledges the SYN.  
在 SYN-SENT 状态（接收到响应初始 SYN 的 RST），如果 ACK 字段确认 SYN，则 RST 是有效的。

The receiver of a RST first validates it, then changes state.  
RST 的接收者首先验证它，然后改变状态。

If the receiver was in the LISTEN state, it ignores it.  
如果接收器处于 LISTEN 状态，就会忽略它。

If the receiver was in SYN-RECEIVED state and had previously been in the LISTEN state, then the receiver returns to the LISTEN state, otherwise the receiver aborts the connection and goes to the CLOSED state.  
如果接收方处于 SYN-RECEIVED 状态，并且之前处于 LISTEN 状态，那么接收方返回到 LISTEN 状态，否则接收方中止连接，进入 CLOSED 状态。

If the receiver was in any other state, it aborts the connection and advises the user and goes to the CLOSED state.  
如果接收方处于任何其它状态，它将中止连接并通知用户并进入 CLOSED 状态。

TCP implementations SHOULD allow a received RST segment to include data (SHLD-2).  
TCP 实现应该允许接收到包含数据的 RST 段 (SHLD-2)。

It has been suggested that a RST segment could contain diagnostic data that explains the cause of the RST.  
有人建议 RST 段可以包含解释 RST 原因的诊断数据。

No standard has yet been established for such data.  
目前还没有为这种数据建立标准。

### 关闭连接

**3.6. Closing a Connection**

CLOSE is an operation meaning "I have no more data to send."  
CLOSE 是一个操作，意思是 "我没有更多的数据要发送"。

The notion of closing a full-duplex connection is subject to ambiguous interpretation, of course, since it may not be obvious how to treat the receiving side of the connection.  
当然，关闭全双工连接的概念会有模糊的解释，因为如何处理连接的接收方可能并不明显。

We have chosen to treat CLOSE in a simplex fashion.  
我们选择以简单的方式来处理 CLOSE。

The user who CLOSEs may continue to RECEIVE until the TCP receiver is told that the remote peer has CLOSED also.  
主动关闭的用户可以继续接收，直到他被告知远端也关闭了。

Thus, a program could initiate several SENDs followed by a CLOSE, and then continue to RECEIVE until signaled that a RECEIVE failed because the remote peer has CLOSED.  
因此，一个程序可以多次发送，然后关闭，再继续接收，直到有信号说接收失败，因为远端已经关闭。

The TCP implementation will signal a user, even if no RECEIVEs are outstanding, that the remote peer has closed, so the user can terminate their side gracefully.  
我们假设，即使没有未完成的接收，TCP 也会通知用户远端已经关闭，所以用户可以优雅地中止自己这端。

A TCP will reliably deliver all buffers SENT before the connection was CLOSED so a user who expects no data in return need only wait to hear the connection was CLOSED successfully to know that all his data was received at the destination TCP endpoint.  
TCP 将在连接关闭前可靠地发送的所有缓冲区的数据，因此没有数据接收的用户只需等到连接被成功关闭，就能知道他的所有数据已经成功发送到目的地 TCP。

Users must keep reading connections they close for sending until the TCP implementation indicates there is no more data.  
用户必须继续读取他们关闭发送的连接，直到 TCP 实现说没有更多数据为止。

There are essentially three cases:  
主要有三种情况：

&emsp;1) The user initiates by telling the TCP implementation to CLOSE the connection (TCP Peer A in Figure 12).  
&emsp;1) 用户主动告诉 TCP 关闭连接（图 12 中的 TCP A）。

&emsp;2) The remote TCP initiates by sending a FIN control signal (TCP Peer B in Figure 12).  
&emsp;2) 远程 TCP 通过发送 FIN 控制标志开始关闭（图 12 中的 TCP B）。

&emsp;3) Both users CLOSE simultaneously (Figure 13)  
&emsp;3) 两个用户同时关闭（图 13）。

Case 1: Local user initiates the close  
情况 1：本地用户发起关闭

In this case, a FIN segment can be constructed and placed on the outgoing segment queue.  
在这种情况下，会生成一个 FIN 段，并将其加入到发送段队列中。

No further SENDs from the user will be accepted by the TCP, and it enters the FIN-WAIT-1 state.  
TCP 将不再接受用户的发送，并进入 FIN-WAIT-1 状态。

RECEIVEs are allowed in this state.  
在这种状态下，允许接收。

All segments preceding and including FIN will be retransmitted until acknowledged.  
在 FIN 之前和包括 FIN 在内的所有段超时将被重传，直到被确认。

When the other TCP peer has both acknowledged the FIN and sent a FIN of its own, the first TCP peer can ACK this FIN.  
当另一个 TCP 既确认了 FIN 又发送了自己的 FIN 时，第一个 TCP 可以对这个 FIN 进行 ACK。

Note that a TCP endpoint receiving a FIN will ACK but not send its own FIN until its user has CLOSED the connection also.  
注意，收到 FIN 的 TCP 会进行 ACK，但不会发送自己的 FIN，直到其用户也关闭了连接。

Case 2: TCP endpoint receives a FIN from the network  
情况 2：TCP 收到来自网络的 FIN

If an unsolicited FIN arrives from the network, the receiving TCP endpoint can ACK it and tell the user that the connection is closing.  
如果来自网络的未经请求的 FIN 到达，接收的 TCP 可以确认该 FIN 并告诉用户连接正在关闭。

The user will respond with a CLOSE, upon which the TCP endpoint can send a FIN to the other TCP peer after sending any remaining data.  
在发送完剩余数据后，用户会用 CLOSE 来回应，在此基础上，TCP 可以向另一端 TCP 发送 FIN。

The TCP endpoint then waits until its own FIN is acknowledged whereupon it deletes the connection.  
然后，TCP 等待，直到它自己的 FIN 被确认，然后它删除连接。

If an ACK is not forthcoming, after the user timeout the connection is aborted and the user is told.  
如果没有收到 ACK，在超时后，连接将被终止，并告诉用户。

Case 3: Both users close simultaneously  
情况 3：两个用户同时关闭

A simultaneous CLOSE by users at both ends of a connection causes FIN segments to be exchanged (Figure 13).  
连接两端的用户同时关闭会交换 FIN 段 （图 13）。

When all segments preceding the FINs have been processed and acknowledged, each TCP can ACK the FIN it has received.  
当 FIN 之前的所有段都被处理并确认后，每个 TCP 可以对它所收到的 FIN 进行 ACK。

Both will, upon receiving these ACKs, delete the connection.  
两者都将在收到这些 ACK 后，删除连接。

```
      TCP Peer A                                           TCP Peer B
  1.  ESTABLISHED                                          ESTABLISHED
  2.  (Close)
      FIN-WAIT-1  --> <SEQ=100><ACK=300><CTL=FIN,ACK>  --> CLOSE-WAIT
  3.  FIN-WAIT-2  <-- <SEQ=300><ACK=101><CTL=ACK>      <-- CLOSE-WAIT
  4.                                                       (Close)
      TIME-WAIT   <-- <SEQ=300><ACK=101><CTL=FIN,ACK>  <-- LAST-ACK
  5.  TIME-WAIT   --> <SEQ=101><ACK=301><CTL=ACK>      --> CLOSED
  6.  (2 MSL)
      CLOSED
```

{{< center >}}
Figure 12: Normal Close Sequence  
图 12：正常关闭序列
{{< /center >}}

```
      TCP Peer A                                           TCP Peer B
  1.  ESTABLISHED                                          ESTABLISHED
  2.  (Close)                                              (Close)
      FIN-WAIT-1  --> <SEQ=100><ACK=300><CTL=FIN,ACK>  ... FIN-WAIT-1
                  <-- <SEQ=300><ACK=100><CTL=FIN,ACK>  <--
                  ... <SEQ=100><ACK=300><CTL=FIN,ACK>  -->
  3.  CLOSING     --> <SEQ=101><ACK=301><CTL=ACK>      ... CLOSING
                  <-- <SEQ=301><ACK=101><CTL=ACK>      <--
                  ... <SEQ=101><ACK=301><CTL=ACK>      -->
  4.  TIME-WAIT                                            TIME-WAIT
      (2 MSL)                                              (2 MSL)
      CLOSED                                               CLOSED
```

{{< center >}}
Figure 13: Simultaneous Close Sequence  
图 13：同时关闭序列
{{< /center >}}

A TCP connection may terminate in two ways: (1) the normal TCP close sequence using a FIN handshake (Figure 12), and (2) an "abort" in which one or more RST segments are sent and the connection state is immediately discarded.  
TCP 连接可能以两种方式终止：(1) 使用 FIN 握手的正常 TCP 关闭序列（图 12），以及 (2) 发送一个或多个 RST 段并立即丢弃连接状态的 "abort" .

If the local TCP connection is closed by the remote side due to a FIN or RST received from the remote side, then the local application MUST be informed whether it closed normally or was aborted (MUST-12).  
如果本地 TCP 连接由于从远程端接收到 FIN 或 RST 而被远程端关闭，则必须通知本地应用程序它是正常关闭还是被中止（MUST-12）。

#### 半关闭连接

**3.6.1. Half-Closed Connections**

The normal TCP close sequence delivers buffered data reliably in both directions.  
正常的 TCP 关闭序列在两个方向上可靠地传送缓冲数据。

Since the two directions of a TCP connection are closed independently, it is possible for a connection to be "half closed", i.e., closed in only one direction, and a host is permitted to continue sending data in the open direction on a half-closed connection.  
由于 TCP 连接的两个方向是独立关闭的，因此连接有可能处于 "半关闭" 状态，即只在一个方向关闭，且允许主机在半关闭连接中打开的方向继续发送数据。

A host MAY implement a "half-duplex" TCP close sequence, so that an application that has called CLOSE cannot continue to read data from the connection (MAY-1).  
主机可以实现 "半双工" TCP 关闭序列，这样调用 CLOSE 的应用程序就不能继续从连接中读取数据 (MAY-1)。

If such a host issues a CLOSE call while received data is still pending in the TCP connection, or if new data is received after CLOSE is called, its TCP implementation SHOULD send a RST to show that data was lost (SHLD-3). See [23], Section 2.17 for discussion.  
如果这样的主机在收到的数据仍在 TCP 连接中等待时发出 CLOSE 调用，或者在调用 CLOSE 后收到新的数据，其 TCP 实现应发送一个 RST 以显示数据丢失（SHLD-3）。讨论见[23]，第 2.17 节。

When a connection is closed actively, it MUST linger in the TIME-WAIT state for a time 2xMSL (Maximum Segment Lifetime) (MUST-13).  
当一个连接被主动关闭时，它必须在 TIME-WAIT 状态下停留 2xMSL（最大段寿命）的时间（MUST-13）。

However, it MAY accept a new SYN from the remote TCP endpoint to reopen the connection directly from TIME-WAIT state (MAY-2), if it:  
然而，它可能会接受来自远程 TCP 端点的新 SYN，直接从 TIME-WAIT 状态（MAY-2）重新打开连接，如果它：

(1) assigns its initial sequence number for the new connection to be larger than the largest sequence number it used on the previous connection incarnation, and  
(1) 为新连接分配的初始序列号要大于它在上一个连接实例中使用的最大序列号，但是

(2) returns to TIME-WAIT state if the SYN turns out to be an old duplicate.  
(2) 如果 SYN 是一个旧的重复段，则返回到 TIME-WAIT 状态。

When the TCP Timestamp Options are available, an improved algorithm is described in [40] in order to support higher connection establishment rates.  
当 TCP 时间戳选项可用时，[40] 中提出了一种改进的算法，以支持更高的连接建立速率。

This algorithm for reducing TIME-WAIT is a Best Current Practice that SHOULD be implemented since Timestamp Options are commonly used, and using them to reduce TIME-WAIT provides benefits for busy Internet servers (SHLD-4).  
这种减少 TIME-WAIT 的算法是当前应该实现的最佳做法，因为时间戳选项是常用的，使用它们来减少 TIME-WAIT 有利于繁忙的互联网服务器（SHLD-4）。

### 分段

**3.7. Segmentation**

The term "segmentation" refers to the activity TCP performs when ingesting a stream of bytes from a sending application and packetizing that stream of bytes into TCP segments.

Individual TCP segments often do not correspond one-for-one to individual send (or socket write) calls from the application.

Applications may perform writes at the granularity of messages in the upper-layer protocol, but TCP guarantees no correlation between the boundaries of TCP segments sent and received and the boundaries of the read or write buffers of user application data.

In some specific protocols, such as Remote Direct Memory Access (RDMA) using Direct Data Placement (DDP) and Marker PDU Aligned Framing (MPA) [34], there are performance optimizations possible when the relation between TCP segments and application data units can be controlled, and MPA includes a specific mechanism for detecting and verifying this relationship between TCP segments and application message data structures, but this is specific to applications like RDMA.

In general, multiple goals influence the sizing of TCP segments created by a TCP implementation.

Goals driving the sending of larger segments include:

- Reducing the number of packets in flight within the network.

- Increasing processing efficiency and potential performance by enabling a smaller number of interrupts and inter-layer interactions.

- Limiting the overhead of TCP headers.

Note that the performance benefits of sending larger segments may decrease as the size increases, and there may be boundaries where advantages are reversed.

For instance, on some implementation architectures, 1025 bytes within a segment could lead to worse performance than 1024 bytes, due purely to data alignment on copy operations.

Goals driving the sending of smaller segments include:

- Avoiding sending a TCP segment that would result in an IP datagram larger than the smallest MTU along an IP network path because this results in either packet loss or packet fragmentation.
  Making matters worse, some firewalls or middleboxes may drop fragmented packets or ICMP messages related to fragmentation.

- Preventing delays to the application data stream, especially when TCP is waiting on the application to generate more data, or when the application is waiting on an event or input from its peer in order to generate more data.

- Enabling "fate sharing" between TCP segments and lower-layer data units (e.g., below IP, for links with cell or frame sizes smaller than the IP MTU).

Towards meeting these competing sets of goals, TCP includes several mechanisms, including the Maximum Segment Size Option, Path MTU Discovery, the Nagle algorithm, and support for IPv6 Jumbograms, as discussed in the following subsections.
