---
title: RFC761 TCP 协议中文翻译
weight: 2
draft: true
# bookFlatSection: false
# bookToc: true
# bookHidden: false
# bookCollapseSection: false
# bookComments: false
# bookSearchExclude: false
---

# RFC761 TCP 协议中文翻译

这是 RFC 上较早关于 TCP 协议标准的文档，站在现在的角度来看，它可能不是很准确或者不是很完整，但是非常有学习价值。

原文：[DoD standard Transmission Control Protocol](https://datatracker.ietf.org/doc/rfc761/)

## 封面

RFC(Request for Comments): 761  
IEN(Internet Experiment Note): 129

{{< center >}}
DOD STANDARD  
美国国防部标准

TRANSMISSION CONTROL PROTOCOL
TCP 协议
January 1980
1980 年 1 月

prepared for

Defense Advanced Research Projects Agency  
国防高级研究计划局  
Information Processing Techniques Office  
信息处理技术办公室  
1400 Wilson Boulevard  
威尔逊大道 1400 号
Arlington, Virginia 22209  
弗吉尼亚州阿灵顿 22209

by

Information Sciences Institute  
信息科学研究所  
University of Southern California
南加州大学  
4676 Admiralty Way  
4676 金钟路
Marina del Rey, California 90291  
加利福尼亚州玛丽安德尔湾 90291

{{< /center >}}

{{< center >}}
TABLE OF CONTENTS
{{< /center >}}

## 目录

PREFACE 前言

1.INTRODUCTION 介绍  
{{< indent >}} 1.1 Motivation 动机  
{{< indent >}} 1.2 Scope 范围  
{{< indent >}} 1.3 About This Document 关于本文  
{{< indent >}} 1.4 Interfaces 接口  
{{< indent >}} 1.5 Operation 操作

2.PHILOSOPHY 基本原理  
{{< indent >}} 2.1 Elements of the Internetwork System 互联网系统的要素  
{{< indent >}} 2.2 Model of Operation 运作模式  
{{< indent >}} 2.3 The Host Environment 主机环境  
{{< indent >}} 2.4 Interfaces 接口  
{{< indent >}} 2.5 Relation to Other Protocols 与其他协议的关系  
{{< indent >}} 2.6 Reliable Communication 可靠的通信  
{{< indent >}} 2.7 Connection Establishment and Clearing 连接的建立和清除  
{{< indent >}} 2.8 Data Communication 数据通信  
{{< indent >}} 2.9 Precedence and Security 优先级和安全性  
{{< indent >}} 2.10 Robustness Principle 稳健性原则

3.FUNCTIONAL SPECIFICATION 功能规范  
{{< indent >}} 3.1 Header Format 头部格式  
{{< indent >}} 3.2 Terminology 术语表  
{{< indent >}} 3.3 Sequence Numbers 序列号  
{{< indent >}} 3.4 Establishing a connection 建立连接  
{{< indent >}} 3.5 Closing a Connection 关闭连接  
{{< indent >}} 3.6 Precedence and Security 优先级和安全性  
{{< indent >}} 3.7 Data Communication 数据通信  
{{< indent >}} 3.8 Interfaces 接口  
{{< indent >}} 3.9 Event Processing 事件处理

GLOSSARY 术语表

REFERENCES 参考文献

## 前言

PREFACE  
前言

This document describes the DoD Standard Transmission Control Protocol
(TCP).  
本文描述了美国国防部标准传输控制协议（TCP 协议）。

There have been eight earlier editions of the ARPA TCP
specification on which this standard is based, and the present text
draws heavily from them.  
ARPA TCP 规范已经有 8 个早期版本，本文中的 TCP 标准是基于它们，并且很多内容都是借鉴它们的。

There have been many contributors to this work both in terms of concepts and in terms of text.  
在概念和编纂方面，都有很多人对这项工作做出贡献。

This edition incorporates the addition of security, compartmentation, and precedence
concepts into the TCP specification.  
此版本在 TCP 规范中加入了安全、间隔和优先级概念。

{{< right >}}
Jon Postel

Editor
{{< /right >}}

## 介绍

1.INTRODUCTION

The Transmission Control Protocol (TCP) is intended for use as a highly reliable host-to-host protocol between hosts in packet-switched computer communication networks, and especially in interconnected systems of such networks.  
传输控制协议（TCP）旨在作为分组交换计算机通信网络中主机之间的高度可靠的主机到主机协议使用，特别是在这种网络的互连系统中。

This document describes the functions to be performed by the Transmission Control Protocol, the program that implements it, and its interface to programs or users that require its services.  
本文描述了传输控制协议（TCP）所要执行的功能、实现它的程序以及它与需要其服务的程序或用户的接口。

### 动机

1.1. Motivation

Computer communication systems are playing an increasingly important role in military, government, and civilian environments.  
计算机通信系统在军事、政府和民用环境中发挥越来越重要的作用。

This document primarily focuses its attention on military computer communication requirements, especially robustness in the presence of communication unreliability and availability in the presence of congestion, but many of these problems are found in the civilian and government sector as well.  
本文着重关注军用计算机通信系统的要求，尤其是通信不可靠时的健壮性和通讯拥堵时的可用性，但是这些问题大多也存在于民用和政府部门的计算机通讯系统中。

As strategic and tactical computer communication networks are developed and deployed, it is essential to provide means of interconnecting them and to provide standard interprocess communication protocols which can support a broad range of applications.  
随着战略和战术计算机通信网络的开发和部署，使它们互联并提供标准的进程间通信协议变得很有必要，这样才能够让它们能够得到广泛的应用。

In anticipation of the need for such standards, the Deputy Undersecretary of Defense for Research and Engineering has declared the Transmission Control Protocol (TCP) described herein to be a basis for DoD-wide inter-process communication protocol standardization.  
鉴于对此类标准的需求，负责研究和工程的国防部副部长宣布本文所述的传输控制协议（TCP）为美国国防部范围内进程间通信协议标准化的基础。

TCP is a connection-oriented, end-to-end reliable protocol designed to fit into a layered hierarchy of protocols which support multi-network applications.  
TCP 是一个面向连接的、端到端的可靠协议，旨在适应支持多网络应用的协议分层结构。

The TCP provides for reliable inter-process communication between pairs of processes in host computers attached to distinct but interconnected computer communication networks.  
TCP 协议为处于同一网络中，但是处于不同计算机中的两个进程提供可靠的进程间通信。

Very few assumptions are made as to the reliability of the communication protocols below the TCP layer.  
TCP 层以下的通信协议被认为是不可靠的。

TCP assumes it can obtain a simple, potentially unreliable datagram service from the lower level protocols.  
TCP 假设它可以从更低的协议中获取简单但可能是不可靠的数据包服务。

In principle, the TCP should be able to operate above a wide spectrum of communication systems ranging from hard-wired connections to packet-switched or circuit-switched networks.  
原则上，TCP 协议应该可以在从硬线连接到分组交换或电路交换网络的广泛通信系统中运行。

TCP is based on concepts first described by Cerf and Kahn in [1].  
TCP 协议基于 Cerf 和 Kahn 最先提出的概念。

The TCP fits into a layered protocol architecture just above a basic Internet Protocol [2] which provides a way for the TCP to send and receive variable-length segments of information enclosed in internet datagram "envelopes".  
TCP 协议是适用于一个分层协议结构，它在 IP 协议之上，IP 协议为 TCP 层提供了一种发送和接收可变长度的信息段的网络数据包的方式。

The internet datagram provides a means for addressing source and destination TCPs in different networks.  
网络数据包提供了一种在不同网络中寻找 TCP 源地址和目的地址的方法。

The internet protocol also deals with any fragmentation or reassembly of the TCP segments required to achieve transport and delivery through multiple networks and interconnecting gateways.  
IP 协议也处理通过多个网络和网关实现传输和交付所需的 TCP 段的任何分段或重组。

The internet protocol also carries information on the precedence, security classification and compartmentation of the TCP segments, so this information can be communicated end-to-end across multiple networks.  
IP 协议还携带关于 TCP 段的优先级、安全分类和间隔的信息，因此这些信息可以在多个网络中被端到端的进行传递。

{{< center >}}
Protocol Layering  
协议分层

```
+---------------------+
|     higher-level    |
+---------------------+
|        TCP          |
+---------------------+
|  internet protocol  |
+---------------------+
|communication network|
+---------------------+
```

Figure 1

{{< /center >}}

Much of this document is written in the context of TCP implementations which are co-resident with higher level protocols in the host computer.  
本文的大部分内容是在 TCP 实现的背景下编写的，这些实现与主机中更高级别的协议共存。

As a practical matter, many computer systems will be connected to networks via front-end computers which house the TCP and internet protocol layers, as well as network specific software.  
实际上，许多计算机系统将会通过包含 TCP 和 IP 协议层以及网络软件的前置机连接到网络。

The TCP specification describes an interface to the higher level protocols which appears to be implementable even for the front-end case, as long as a suitable host-to-front end protocol is implemented.  
TCP 规范描述了一个到更高层协议的接口，只要实现了合适的主机到前端的协议，即使对于前端情况，该接口似乎也是可实现的。

1.2. Scope

### 范围

The TCP is intended to provide a reliable process-to-process communication service in a multinetwork environment.  
TCP 旨在在多网络环境中提供可靠的进程到进程通信服务。

The TCP is intended to be a host-to-host protocol in common use in multiple networks.  
TCP 旨在成为多网络环境中常用的主机到主机协议。

1.3. About this Document

### 关于本文

This document represents a specification of the behavior required of any TCP implementation, both in its interactions with higher level protocols and in its interactions with other TCPs.  
本文描述了所有 TCP 实现所需的行为规范，无论是与其它更高级的协议交互还是与其它 TCP 的交互。

The rest of this section offers a very brief view of the protocol interfaces and operation.  
本节的其余部分非常简要地介绍了协议接口和操作。

Section 2 summarizes the philosophical basis for the TCP design.  
第 2 节概述了 TCP 设计的哲学基础。

Section 3 offers both a detailed description of the actions required of TCP when various events occur (arrival of new segments, user calls, errors, etc.) and the details of the formats of TCP segments.  
第 3 节详细描述了当各种事件发生时（新段的到来、用户呼叫、错误等）TCP 所需的行动，以及 TCP 段格式的细节。

### 接口

1.4. Interfaces

The TCP interfaces on one side to user or application processes and on the other side to a lower level protocol such as Internet Protocol.  
TCP 一端连接到用户或应用程序进程，另一端连接到较低级别的协议，比如 IP 协议。

The interface between an application process and the TCP is illustrated in reasonable detail.  
相当详细地说明了应用程序进程和 TCP 之间的接口。

This interface consists of a set of calls much like the calls an operating system provides to an application process for manipulating files.  
这个接口由一组调用组成，很像操作系统为操作文件的应用进程提供的调用。

For example, there are calls to open and close connections and to send and receive letters on established connections.  
例如，有调用打开和关闭连接，以及在已建立的连接上发送和接收数据。

It is also expected that the TCP can asynchronously communicate with application programs.  
还期望 TCP 能够与应用程序进行异步通信。

Although considerable freedom is permitted to TCP implementors to design interfaces which are appropriate to a particular operating system environment, a minimum functionality is required at the TCP/user interface for any valid implementation.  
尽管允许 TCP 实现者有相当大的自由来设计适合特定操作系统环境的接口，但对于任何有效的实现，TCP/user 接口都需要最少的功能。

The interface between TCP and lower level protocol is essentially unspecified except that it is assumed there is a mechanism whereby the two levels can asynchronously pass information to each other.  
除了假设两个级别可以相互异步传递信息的机制之外，基本上没有指定 TCP 和较低级别协议之间的接口。

Typically, one expects the lower level protocol to specify this interface.  
通常情况下，是由低级别的协议指定这个接口。

TCP is designed to work in a very general environment of interconnected networks.  
TCP 被设计为可以在互连网络的非常普遍的环境中工作。

The lower level protocol which is assumed throughout this document is the Internet Protocol [2].  
本文中假定的较低级别协议是 IP 协议。

### 操作

1.5. Operation

As noted above, the primary purpose of the TCP is to provide reliable, securable logical circuit or connection service between pairs of processes.  
如上所述，TCP 的主要目的是在进程对之间提供可靠、安全的逻辑线路或连接服务。

To provide this service on top of a less reliable internet communication system requires facilities in the following areas:  
要在不太可靠的互联网通信系统之上提供这种服务，需要在以下方面的设施：

- Basic Data Transfer 基础数据传输
- Reliability 可靠性
- Flow Control 流量控制
- Multiplexing 多路复用
- Connections 连接
- Precedence and Security 优先级和安全性

The basic operation of the TCP in each of these areas is described in the following paragraphs.  
以下段落描述了 TCP 在每个方面的基本操作。

Basic Data Transfer:  
基础数据传输

The TCP is able to transfer a continuous stream of octets in each direction between its users by packaging some number of octets into segments for transmission through the internet system.  
TCP 能够在其用户之间的每个方向传输连续的字节流，将一些字节数据打包成段，通过互联网传输。

In this stream mode, the TCPs decide when to block and forward data at their own convenience.  
在这种流模式下，TCP 根据自己的情况来决定阻止和转发数据。

For users who desire a record-oriented service, the TCP also permits the user to submit records, called letters, for transmission.  
对于需要面向记录的服务的用户，TCP 还允许用户提交记录以供传输。

When the sending user indicates a record boundary (end-of-letter), this causes the TCPs to promptly forward and deliver data up to that point to the receiver.  
当发送记录边界时，这会使得 TCP 立即转发数据，并将数据传递到接收者。

Reliability:  
可靠性

The TCP must recover from data that is damaged, lost, duplicated, or delivered out of order by the internet communication system.  
TCP 必须从因特网通信系统损坏、丢失、复制或乱序传送的数据中恢复。

This is achieved by assigning a sequence number to each octet transmitted, and requiring a positive acknowledgment (ACK) from the
receiving TCP.  
这是通过给传输的每个字节分配一个序列号，并要求接收的 TCP 回复一个确认（ACK）来实现的。

If the ACK is not received within a timeout interval, the data is retransmitted.  
如果在规定的时间隔内没有收到 ACK，则重传数据。

At the receiver, the sequence numbers are used to correctly order segments that may be received out of order and to eliminate duplicates.  
在接收方，序列号用来按顺序排列可能接收到的乱序的片段，并消除重复的片段。

Damage is handled by adding a checksum to each segment transmitted, checking it at the receiver, and discarding damaged segments.  
通过在传输的每个片段上添加一个校验和，在接收方进行检查，并丢弃损坏的片段。

As long as the TCPs continue to function properly and the internet system does not become completely partitioned, no transmission errors will affect the users.  
只要 TCP 各端继续正常运行，网络系统也没有断开，传输错误就不会影响到用户。

TCP recovers from internet communication system errors.  
TCP 从互联网通信错误中恢复。

Flow Control:  
流量控制

TCP provides a means for the receiver to govern the amount of datasent by the sender.  
TCP 为接收方提供了一种方法来管理发送方发送的数据量。

This is achieved by returning a "window" with every ACK indicating a range of acceptable sequence numbers beyond the last segment successfully received.  
这是通过在每个 ACK 中返回一个 "窗口" 来实现的，窗口表示在成功接收的最后一个片段之外的可接受的序列号范围。

For stream mode, the window indicates an allowed number of octets that the sender may transmit before receiving further permission.  
对于流模式，窗口表示发送者在收到后续指示之前可以传输的字节数。

For record mode, the window indicates an allowed amount of buffer space the sender may consume, this may be more than the number of data octets transmitted if there is a mismatch between letter size and buffer size.  
对于记录模式，窗口表示发送方可能消耗的缓冲空间的数量，如果数据包大小和缓冲区大小不匹配，可能超过传输的数据字节数。

Multiplexing:  
多路复用

To allow for many processes within a single Host to use TCP communication facilities simultaneously, the TCP provides a set of addresses or ports within each host.  
为了允许单个主机内的多个进程同时使用 TCP 进行通信，TCP 在每个主机内提供了一组地址或端口。

Concatenated with the network and host addresses from the internet communication layer, this forms a socket.  
从互联网通信层连接网络和主机地址，形成一个套接字。

A pair of sockets uniquely identifies each connection.  
一对套接字唯一标识每个连接。

That is, a socket may be simultaneously used in multiple connections.  
也就是说，一个套接字可以同时在多个连接中使用。

The binding of ports to processes is handled independently by each Host.  
每个主机单独处理端口与进程的绑定。

However, it proves useful to attach frequently used processes (e.g., a "logger" or timesharing service) to fixed sockets which are made known to the public.  
然而，事实证明，将常用的进程（例如，"logger"或 timesharing 服务）附加到固定的套接字上会很有用。

These services can then be accessed through the known addresses. Establishing and learning the port addresses of other processes may involve more dynamic mechanisms.  
通过已知地址就可以访问这些服务，建立和学习其他进程的端口地址可能涉及更多的动态机制。

Connections:  
连接

The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream.  
上述的可靠性和流量控制机制要求 TCP 初始化和维护每个数据流的某些状态信息。

The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.  
这些信息（包括套接字、序列号和窗口大小）的组合称为连接。

Each connection is uniquely specified by a pair of sockets identifying its two sides.  
每个连接都由标识其两端的一对套接字唯一指定。

When two processes wish to communicate, their TCP's must first establish a connection (initialize the status information on each side).  
当两个进程想要进行通信时，它们必须先建立 TCP 连接（初始化每一端的状态信息）。

When their communication is complete, the connection is terminated or closed to free the resources for other uses.  
当他们的通信完成后，连接被终止或关闭，以释放资源用于其他用途。

Since connections must be established between unreliable hosts and over the unreliable internet communication system, a handshake mechanism with clock-based sequence numbers is used to avoid erroneous initialization of connections.  
由于必须在不可靠的主机之间和通过不可靠的互联网通信系统建立连接，因此使用了基于时钟序列号的握手机制，以避免连接的错误初始化。

Precedence and Security:  
优先级和安全性

The users of TCP may indicate the security and precedence of their communication.  
TCP 的用户可以指定其通信的安全性和优先级。

Provision is made for default values to be used when these features are not needed.  
规定在不需要这些功能时，会使用默认值。

## 基本原理

2.PHILOSOPHY

### 互联网系统的要素

2.1. Elements of the Internetwork System

The internetwork environment consists of hosts connected to networks which are in turn interconnected via gateways.  
互联网络环境由连接到网络的主机组成，这些网络又通过网关互连。

It is assumed here that the networks may be either local networks (e.g., the ETHERNET) or large networks (e.g., the ARPANET), but in any case are based on packet switching technology.  
这里假设网络可以是本地网络（如 ETHERNET）或大型网络（如 ARPANET），但在任何情况下都是基于分组交换技术。

The active agents that produce and consume messages are processes.  
进程是产生和消费消息的活跃元素。

Various levels of protocols in the networks, the gateways, and the hosts support an interprocess communication system that provides two-way data flow on logical connections between process ports.  
网络、网关和主机中的各种级别的协议支持进程间通信系统，该系统在进程端口之间的逻辑连接上提供双向数据流。

We specifically assume that data is transmitted from host to host through means of a set of networks.  
我们特别假设数据通过一组网络从一个主机传输到另一个主机。

When we say network, we have in mind a packet switched network (PSN).  
当我们说网络时，我们想到的是分组交换网络(PSN)。

This assumption is probably unnecessary, since a circuit switched network or a hybrid combination of the two could also be used; but for concreteness, we explicitly assume that the hosts are connected to one or more packet switches of a PSN.  
这一假设可能是不必要的，因为也可以使用电路交换网络或两者的混合组合。但为了具体起见，我们明确假设主机连接到 PSN 的一个或多个分组交换机。

The term packet is used generically here to mean the data of one transaction between a host and a packet switch.  
术语 "数据包" 在这里泛指主机和数据包交换机之间的一次事务处理数据。

The format of data blocks exchanged between the packet switches in a network will generally not be of concern to us.  
我们通常不会关心网络中分组交换机之间交换的数据块的格式。

Hosts are computers attached to a network, and from the communication network's point of view, are the sources and destinations of packets.  
主机是连接到网络的计算机，从通信网络的角度来看，主机是数据包的来源和目的地。

Processes are viewed as the active elements in host computers (in accordance with the fairly common definition of a process as a program in execution).  
进程被看作是主机中的活跃元素（根据相当普遍的定义，进程是一个正在执行的程序）。

Even terminals and files or other I/O devices are viewed as communicating with each other through the use of processes.  
甚至终端和文件或其他 I/O 设备也被看作是通过使用进程来相互通信的。

Thus, all communication is viewed as inter-process communication.  
因此，所有的通信都被看作是进程间的通信。

Since a process may need to distinguish among several communication streams between itself and another process (or processes), we imagine that each process may have a number of ports through which it communicates with the ports of other processes.  
因为一个进程可能需要区分它和另一个进程(或多个进程)之间的几个通信流，所以我们假设每个进程可能有许多端口，它通过这些端口与其他进程的端口进行通信。

### 运作模式

2.2. Model of Operation

Processes transmit data by calling on the TCP and passing buffers of data as arguments.  
进程通过调用 TCP 并将数据缓冲区作为参数来传输数据。

The TCP packages the data from these buffers into segments and calls on the internet module to transmit each segment to the destination TCP.  
TCP 将这些缓冲区中的数据打包成 TCP 段，并调用网络模块将每个 TCP 段传输到目的主机的 TCP。

The receiving TCP places the data from a segment into the receiving user's buffer and notifies the receiving user.  
接收 TCP 将 TCP 段中的数据放入接收用户的缓冲区，并通知接收用户。

The TCPs include control information in the segments which they use to ensure reliable ordered data transmission.  
TCP 把控制信息放在 TCP 段中，它们用于确保可靠有序的数据传输。

The model of internet communication is that there is an internet protocol module associated with each TCP which provides an interface to the local network.  
互联网通信的模型是有一个互联网协议模块与每个 TCP 相关联，它提供到本地网络的接口。

This internet module packages TCP segments inside internet datagrams and routes these datagrams to a destination internet module or intermediate gateway.  
这个互联网模块将 TCP 段封装在网络数据报中，并将这些数据报路由到目标互联网模块或中间网关。

To transmit the datagram through the local network, it is embedded in a local network packet.  
为了通过本地网络传输数据报，它被嵌入到本地网络数据包中。

The packet switches may perform further packaging, fragmentation, or other operations to achieve the delivery of the local packet to the destination internet module.  
分组交换机可以执行进一步的打包、分段或其他操作，以实现将本地数据包发送到目的地互联网模块。

At a gateway between networks, the internet datagram is "unwrapped" from its local packet and examined to determine through which network the internet datagram should travel next.  
在网关时，网络数据报从其本地数据包中 "解包" 并进行检查并决定该网络数据报接下来应通过哪个网络传输。

The internet datagram is then "wrapped" in a local packet suitable to the next network and routed to the next gateway, or to the final destination.  
然后，网络数据报在适合于下一个网络的本地数据包中被 "包装" ，并被路由到下一个网关或最终目的地。

A gateway is permitted to break up an internet datagram into smaller internet datagram fragments if this is necessary for transmission through the next network.  
如果有必要的话，允许网关将网络数据报分解成更小的网络数据报片段，再传输到下一个网络。

To do this, the gateway produces a set of internet datagrams; each carrying a fragment.  
为此，网关生成一组网络数据报；每个数据包携带一个片段。

Fragments may be broken into smaller ones at intermediate gateways.  
数据包片段可以在中间网关处分解成更小的片段。

The internet datagram fragment format is designed so that the destination internet module can reassemble fragments into internet datagrams.  
网络数据报片段格式的设计使得目的地的互联网模块可以将片段重组为网络数据报。

A destination internet module unwraps the segment from the datagram (after reassembling the datagram, if necessary) and passes it to the destination TCP.  
目的地互联网模块从数据报中解开 TCP 段(如果需要，在重组数据报之后)，并将其传递给 TCP。

This simple model of the operation glosses over many details.  
这个简单的运作模式掩盖了许多细节。

One important feature is the type of service.  
一个重要的特征是服务的类型。

This provides information to the gateway (or internet module) to guide it in selecting the service parameters to be used in traversing the next network.  
这为网关（或互联网模块）提供了信息，指导它选择遍历下一个网络时使用的服务参数。

Included in the type of service information is the precedence of the datagram.  
服务类型信息中包括数据报的优先级。

Datagrams may also carry security information to permit host and gateways that operate in multilevel secure environments to properly segregate datagrams for security considerations.  
数据报还可以携带安全信息，使得在多级安全环境中操作的主机和网关出于安全考虑可以适当地分离数据报。

### 主机环境

2.3. The Host Environment

The TCP is assumed to be a module in a time sharing operating system.  
假定 TCP 是分时操作系统中的一个模块。

The users access the TCP much like they would access the file system.  
用户访问 TCP 就像他们访问文件系统一样。

The TCP may call on other operating system functions, for example, to manage data structures.  
TCP 可以调用其他操作系统的功能，例如，管理数据结构。

The actual interface to the network is assumed to be controlled by a device driver module.  
假设到网络的实际接口由设备驱动模块控制。

The TCP does not call on the network device driver directly, but rather calls on the internet datagram protocol module which may in turn call on the device driver.  
TCP 不直接调用网络设备驱动程序，而是调用网络数据报协议模块，而后者又可能调用设备驱动程序。

Though it is assumed here that processes are supported by the host operating system, the mechanisms of TCP do not preclude implementation of the TCP in a front-end processor.  
虽然这里假设进程是由主机操作系统支持的，但 TCP 的机制并不排除在前端处理器中实现 TCP。

However, in such an implementation, a host-to-front-end protocol must provide the functionality to support the type of TCP-user interface described above.  
然而，在这样的实现中，主机到前端协议必须提供支持上述类型的 TCP-用户接口的功能。

### 接口

2.4. Interfaces

The TCP/user interface provides for calls made by the user on the TCP to OPEN or CLOSE a connection, to SEND or RECEIVE data, or to obtain STATUS about a connection.  
TCP/用户接口提供了用户控制 TCP 的调用，用来打开或关闭连接、发送或接收数据或获取有关连接的状态。

These calls are like other calls from user programs on the operating system, for example, the calls to open, read from, and close a file.  
这些调用类似于操作系统上用户程序的其他调用，例如打开、读取和关闭文件的调用。

The TCP/internet interface provides calls to send and receive datagrams addressed to TCP modules in hosts anywhere in the internet system.  
TCP/互联网接口提供了调用，用来发送和接收寻址到互联网系统中任何地方的主机中的 TCP 模块的数据报。

These calls have parameters for passing the address, type of service, precedence, security, and other control information.  
这些调用有参数用于传递地址、服务类型、优先级、安全性和其他控制信息。

### 与其他协议的关系

2.5. Relation to Other Protocols

The following diagram illustrates the place of the TCP in the protocol hierarchy:  
下图说明了 TCP 在协议层次结构中的位置

```
+------+ +-----+ +-----+       +-----+
|Telnet| | FTP | |Voice|  ...  |     |  Application Level
+------+ +-----+ +-----+       +-----+
     |   |         |             |
    +-----+     +-----+       +-----+
    | TCP |     | RTP |  ...  |     |   Host Level
    +-----+     +-----+       +-----+
        |           |             |
    +-------------------------------+
    |      Internet Protocol        |   Gateway Level
    +-------------------------------+
                    |
      +---------------------------+
      |   Local Network Protocol  |     Network Level
      +---------------------------+
                    |
          Protocol Relationships
```

{{< center >}}
Figure 2

{{< /center >}}

It is expected that the TCP will be able to support higher level protocols efficiently.  
预计 TCP 将能够有效地支持更高级别的协议。

It should be easy to interface higher level protocols like the ARPANET Telnet [3] or AUTODIN II THP to the TCP.  
应该很容易将更高层次的协议如 ARPANET Telnet[3]或 AUTODIN II THP 连接到 TCP。

### 可靠的通信

2.6. Reliable Communication

A stream of data sent on a TCP connection is delivered reliably and in order at the destination.  
通过 TCP 连接上发送的数据流在目的地可靠且有序地传送。

Transmission is made reliable via the use of sequence numbers and acknowledgments.  
通过使用序列号和确认机制，使得传输变得可靠。

Conceptually, each octet of data is assigned a sequence number.  
从概念上讲，每个字节的数据都分配有一个序列号。

The sequence number of the first octet of data in a segment is the sequence number transmitted with that segment and is called the segment sequence number.  
TCP 段中数据的第一个字节的序号是与该 TCP 段一起传输的序列号，称为 segment sequence number。

Segments also carry an acknowledgment number which is the sequence number of the next expected data octet of transmissions in the reverse direction.  
TCP 段还携带一个确认号码，这是期望对方传输的下一个字节数据包的序列号。

When the TCP transmits a segment, it puts a copy on a retransmission queue and starts a timer; when the acknowledgment for that data is received, the segment is deleted from the queue.  
当 TCP 传输一个 TCP 段时，它会将 TCP 段的一个副本放在重传队列中，并启动一个计时器；当收到该数据的确认时，则将该 TCP 段将从重传队列中删除。

If the acknowledgment is not received before the timer runs out, the segment is retransmitted.  
如果在定时器结束之前没有收到确认，则重传该 TCP 段。

An acknowledgment by TCP does not guarantee that the data has been delivered to the end user, but only that the receiving TCP has taken the responsibility to do so.  
TCP 的确认并不保证数据已经交付给最终用户，而只是表明接收的 TCP 已经接收了这份数据。

To govern the flow of data into a TCP, a flow control mechanism is employed.  
为了管理进入 TCP 的数据流，采用了流量控制机制。

The the data receiving TCP reports a window to the sending TCP.  
数据接收 TCP 向发送 TCP 报告一个窗口。

This window specifies the number of octets, starting with the acknowledgment number that the data receiving TCP is currently prepared to receive.  
该窗口指定字节的数量，从数据接收的 TCP 目前准备接收的确认号码开始。

### 连接的建立和清除

2.7. Connection Establishment and Clearing

To identify the separate data streams that a TCP may handle, the TCP provides a port identifier.  
为了识别 TCP 可以处理的单独数据流，TCP 提供了端口标识符。

Since port identifiers are selected independently by each operating system, TCP, or user, they might not be unique.  
由于端口标识符是由每个操作系统、TCP 或用户独立选择的，它们可能不是唯一的。

To provide for unique addresses at each TCP, we concatenate an internet address identifying the TCP with a port identifier to create a socket which will be unique throughout all networks connected together.  
为了给每个 TCP 提供唯一的地址，我们将识别 TCP 的网络地址与端口标识符连接起来，以创建一个套接字，该套接字在所有连接在一起的网络中是唯一的。

A connection is fully specified by the pair of sockets at the ends.  
一个连接完全由两端的一对套接字指定。

A local socket may participate in many connections to different foreign sockets.  
一个本地套接字可以参与许多与不同的外部套接字的连接。

A connection can be used to carry data in both directions, that is, it is "full duplex".  
一个连接可以用来双向传输数据，也就是说，它是 "全双工"。

TCPs are free to associate ports with processes however they choose.  
TCP 可以自由地将端口与进程联系起来，不管他们如何选择。

However, several basic concepts seem necessary in any implementation.  
然而，在任何实现中，有几个基本概念几乎都是必须的。

There must be well-known sockets which the TCP associates only with the "appropriate" processes by some means.  
有一些有名的套接字，TCP 通过某种方式将其与 "适当" 的进程联系起来。

We envision that processes may "own" ports, and that processes can only initiate connections on the ports they own.  
我们设想进程可以 "拥有" 端口，而且这些进程只能在它们拥有的端口上发起连接。

(Means for implementing ownership is a local issue, but we envision a Request Port user command, or a method of uniquely allocating a group of ports to a given process, e.g., by associating the high order bits of a port name with a given process.)  
实现所有权的方法是一个局部问题，但是我们设想了一个请求端口的用户命令，或者一个将一组端口唯一地分配给一个给定进程的方法，例如，通过将端口名称的高位 bit 与一个给定进程联系起来。

A connection is specified in the OPEN call by the local port and foreign socket arguments.  
在 OPEN 调用中，通过本地端口和外部套接字参数指定一个连接。

In return, the TCP supplies a (short) local connection name by which the user refers to the connection in subsequent calls.  
TCP 提供了一个（简短的）本地连接名称作为返回，用户在后续的调用中用这个名称来指代连接。

There are several things that must be remembered about a connection.  
关于连接，必须记住几件事。

To store this information we imagine that there is a data structure called a Transmission Control Block (TCB).  
为了存储这些信息，我们设想有一个叫做传输控制块（TCB）的数据结构。

One implementation strategy would have the local connection name be a pointer to the TCB for this connection.  
一种实现策略是将本地连接名称作为指向该连接的 TCB 的指针。

The OPEN call also specifies whether the connection establishment is to be actively pursued, or to be passively waited for.  
OPEN 调用还指定是主动连接建立，还是被动等待建立连接。

A passive OPEN request means that the process wants to accept incoming connection requests rather than attempting to initiate a connection.  
被动 OPEN 请求意味着进程想要接受进来的连接请求，而不是尝试启动连接。

Often the process requesting a passive OPEN will accept a connection request from any caller.
被动 OPEN 的进程通常会接受来自任何调用者的连接请求。

In this case a foreign socket of all zeros is used to denote an unspecified socket.  
在这种情况下，使用全 0 的外部套接字来表示未指定的套接字。

Unspecified foreign sockets are allowed only on passive OPENs.  
未指定的外部套接字只允许在被动 OPEN 中使用。

A service process that wished to provide services for unknown other processes could issue a passive OPEN request with an unspecified foreign socket.  
想要为未知的其他进程提供服务的服务进程可以使用未指定的外部套接字发起被动 OPEN 请求。

Then a connection could be made with any process that requested a connection to this local socket.  
然后就可以与请求连接到此本地套接字的任何进程建立连接。

It would help if this local socket were known to be associated with this service.  
如果已知这个本地套接字与此服务相关联，将会非常有用。

Well-known sockets are a convenient mechanism for a priori associating a socket address with a standard service.  
well-known sockets 是一种便利的机制，可以先验地将套接字地址与标准服务联系起来。

For instance, the "Telnet-Server" process might be permanently assigned to a particular socket, and other sockets might be reserved for File Transfer, Remote Job Entry, Text Generator, Echoer, and Sink processes (the last three being for test purposes).  
例如，"Telnet-Server" 进程可能被永久分配给一个特定的套接字，而其他套接字可能被保留用于文件传输、远程作业输入、文本生成器、回声器和接收器进程（最后三个用于测试目的）。

A socket address might be reserved for access to a "Look-Up" service which would return the specific socket at which a newly created service would be provided.  
可以为访问 "查找" 服务保留套接字地址，该服务可以返回新创建服务的特定套接字。

The concept of a well-known socket is part of the TCP specification, but the assignment of sockets to services is outside this specification.  
well-known socket 的概念是 TCP 规范的一部分，但将套接字分配给服务超出了该规范。

Processes can issue passive OPENs and wait for matching calls from other processes and be informed by the TCP when connections have been established.  
进程可以发起被动的 OPEN，等待来自其他进程的相应调用，并在连接建立后由 TCP 通知。

Two processes which issue calls to each other at the same time are correctly connected.  
两个在同一时间相互发出调用的进程可以正确建立连接。

This flexibility is critical for the support of distributed computing in which components act asynchronously with respect to each other.  
这种灵活性对于支持分布式计算至关重要，在分布式计算中，组件彼此异步地工作。

There are two cases for matching the sockets in the local request and an incoming segment.  
有两种情况用于匹配本地请求和收到 TCP 段中的套接字。

In the first case, the local request has fully specified the foreign socket. In this case, the match must be exact.  
在第一种情况下，本地请求已经明确指定了外部套接字。在这种情况下，匹配是精确的。

In the second case, the local request has left the foreign socket unspecified. In this case, any foreign socket is acceptable as long as the local sockets match.  
在第二种情况下，本地请求未指定外部套接字。在这种情况下，只要本地套接字匹配，任何外来套接字都是可以接受的。

If there are several pending passive OPENs (recorded in TCBs) with the same local socket, an incoming segment should be matched to a request with the specific foreign socket in the segment, if such a request exists, before selecting a request with an unspecified foreign socket.  
如果有多个等待中的被动 OPEN（记录在 TCB 中）具有相同的本地套接字，则在选择具有未指定的外部套接字的请求之前，应将收到 TCP 段与具有段中特定的外部套接字（如果存在此类请求）的请求相匹配。

The procedures to establish and clear connections utilize synchronize (SYN) and finis (FIN) control flags and involve an exchange of three messages.  
建立和清除连接的过程使用同步 (SYN) 和结束 (FIN) 控制标志，并涉及三次消息交换。

This exchange has been termed a three-way hand shake [4].  
这种交换被称为三次握手。

A connection is initiated by the rendezvous of an arriving segment containing a SYN and a waiting TCB entry created by a user OPEN command.  
通过包含 SYN 的到达段和一个由用户 OPEN 命令创建的等待的 TCB 条目的会合而发起连接。

The matching of local and foreign sockets determines when a connection has been initiated.  
本地套接字和外部套接字的匹配决定了连接何时开始。

The connection becomes "established" when sequence numbers have been synchronized in both directions.  
当序列号在连接双向同步时，连接就建立了。

The clearing of a connection also involves the exchange of segments, in this case carrying the FIN control flag.  
连接的清除也涉及到段的交换，在这种情况下，带有 FIN 控制标志。

### 数据通信

2.8. Data Communication

The data that flows on a connection may be thought of as a stream of octets, or as a sequence of records.  
在一个连接上流动的数据可以被认为是一个字节流，或者是一个记录的序列。

In TCP the records are called letters and are of variable length.
在 TCP 中，记录被称为信件，其长度是可变的。

The sending user indicates in each SEND call whether the data in that call completes a letter by the setting of the end-of-letter parameter.  
发送用户在每个 SEND 调用中通过设置 end-of-letter 参数来表明该调用中的数据是否发送完了一个信件。

The length of a letter may be such that it must be broken into segments before it can be transmitted to its destination.
信件的长度可以是这样的：在将其传输到其目的地之前，必须将其分成多个段。

We assume that the segments will normally be reassembled into a letter before being passed to the receiving process.  
我们假设这些片段通常会在传递给接收进程之前被重新组合成一个信件。

A segment may contain all or a part of a letter, but a segment never contains parts of more than one letter.  
一个段可能包含一个信件的全部或部分，但一个段绝不包含多个信件的部分。

The end of a letter is marked by the appearance of an EOL control flag in a segment.  
一个段中出现 EOL 控制标志表示一个信件的结束。

A sending TCP is allowed to collect data from the sending user and to send that data in segments at its own convenience, until the end of letter is signaled then it must send all unsent data.  
一个发送 TCP 可以从发送用户那里收集数据，并在自己合适的时候分片发送这些数据，在发出信件结束的信号时，它必须发送所有未发送的数据。

When a receiving TCP has a complete letter, it must not wait for more data from the sending TCP before passing the letter to the receiving process.  
当一个接收 TCP 收到一个完整的信件时，它必须先将信件传递给接收进程，然后再等待来自发送 TCP 的更多数据。

There is a coupling between letters as sent and the use of buffers of data that cross the TCP/user interface.  
发送的信件和使用跨 TCP/用户接口的数据缓冲区之间存在耦合。

Each time an end-of-letter (EOL) flag is associated with data placed into the receiving user's buffer, the buffer is returned to the user for processing even if the buffer is not filled.  
每当信件结尾（EOL）标志与放入接收用户缓冲区的数据相关联时，即使缓冲区未被填满，缓冲区也会返回给用户进行处理。

If a letter is longer than the user's buffer, the letter is passed to the user in buffer size units, the last of which may be only partly full.  
如果一个信件比用户的缓冲区长，那么这个字母就会以缓冲区大小为单位传递给用户，最后一个缓冲区可能只有部分。

The receiving TCP's buffer size may be communicated to the sending TCP when the connection is being established.  
在建立连接时，接收 TCP 的缓冲区大小可能会被传达给发送 TCP。

The TCP is responsible for regulating the flow of segments on the connections, as a way of preventing itself from becoming saturated or overloaded with traffic.  
TCP 负责调节连接上的流量，以此来防止自己的流量达到饱和或过载。

This is done using a window flow control mechanism.  
这是用流量窗口控制机制完成的。

The data receiving TCP reports to the data sending TCP a window which is the range of sequence numbers of data octets that data receiving TCP is currently prepared to accept.  
接收 TCP 向发送 TCP 报告一个窗口，该窗口是数据接收 TCP 目前准备接受的字节数据的序列号范围。

TCP also provides a means to communicate to the receiver of data that at some point further along in the data stream than the receiver is currently reading there is urgent data.  
TCP 还提供了一种方法来向数据的接收者传达，在数据流更远的地方中有比目前读取更紧急数据。

TCP does not attempt to define what the user specifically does upon being notified of pending urgent data, but the general notion is that the receiving process should take action to read through the end urgent data quickly.  
TCP 并不试图定义用户在收到待处理紧急数据的通知后具体做什么，但一般的情况是，接收进程应该采取行动，尽快读完最后的紧急数据。

### 优先级和安全性

2.9. Precedence and Security

The TCP makes use of the internet protocol type of service field and security option to provide precedence and security on a per connection basis to TCP users.
TCP 利用 IP 协议的服务类型字段和安全选项，在每个连接的基础上向 TCP 用户提供优先权和安全性。

Not all TCP modules will necessarily function in a multilevel secure environment, some may be limited to unclassified use only, and others may operate at only one security level and compartment.  
并非所有 TCP 模块都必须在多级安全环境中运行，有些模块可能仅限于公开使用，而其他模块可能仅在一个安全级别和间隔中运行。

Consequently, some TCP implementations and services to users may be limited to a subset of the multilevel secure case.  
因此，某些 TCP 实现和对用户的服务可能仅限于多级安全情况的一个子集。

TCP modules which operate in a multilevel secure environment should properly mark outgoing segments with the security, compartment, and precedence.  
在多级安全环境中运行的 TCP 模块应正确标记传出 TCP 段的安全性、分区和优先级。

Such TCP modules should also provide to their users or higher level protocols such as Telnet or THP an interface to allow them to specify the desired security level, compartment, and precedence of connections.  
这样的 TCP 模块还应该为它们的用户或者更高层次的协议，例如 Telnet 或者 THP 提供一个接口，以便让它们指定所需的连接的安全级别、间隔和优先级。

### 稳健性原则

2.10. Robustness Principle

TCP implementations should follow a general principle of robustness: be conservative in what you do, be liberal in what you accept from others.  
TCP 实现应该遵循一个一般的稳健性原则：在你做的事情上要保守，在你接受别人的事情上要自由。

## 功能规范

3.FUNCTIONAL SPECIFICATION

### 头部格式

3.1. Header Format

TCP segments are sent as internet datagrams. The Internet Protocol header carries several information fields, including the source and destination host addresses [2].  
TCP 段以互联网数据报的形式发送。IP 协议报头携带多个信息字段，包括源主机地址和目的主机地址。

A TCP header follows the internet header, supplying information specific to the TCP protocol. This ivision allows for the existence of host level protocols other than TCP.  
TCP 头部 在 IP 协议头部后面，提供 TCP 协议特定的信息。这种划分允许存在除 TCP 以外的主机级协议。

{{< center >}}
TCP Header Format  
TCP 头部格式

```
0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |          Source Port          |       Destination Port        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        Sequence Number                        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                    Acknowledgment Number                      |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |  Data |           |U|A|E|R|S|F|                               |
  | Offset| Reserved  |R|C|O|S|Y|I|            Window             |
  |       |           |G|K|L|T|N|N|                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |           Checksum            |         Urgent Pointer        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                    Options                    |    Padding    |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                             data                              |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

Note that one tick mark represents one bit position.  
注意：一个刻度线代表一个比特位。

Figure 3.

{{< /center >}}

Source Port: 16 bits  
{{< indent >}} The source port number.  
{{< indent >}} 源端口号

Destination Port: 16 bits  
{{< indent >}} The destination port number.  
{{< indent >}} 目标端口号

Sequence Number: 32 bits  
{{< indent >}} The sequence number of the first data octet in this segment (exceptwhen SYN is present).  
{{< indent >}} 该段数据中第一个字节的序列号（有 SYN 标志除外）。

Acknowledgment Number: 32 bits  
{{< indent >}} If the ACK control bit is set this field contains the value of the next sequence number the sender of the segment is expecting to receive. Once a connection is established this is always sent.  
{{< indent >}} 如果有 ACK 标志，这个字段表示发送者期望收到的下一个序列号的值。一旦建立了连接，一直会发送这个字段。

Data Offset: 4 bits  
{{< indent >}} The number of 32 bit words in the TCP Header. This indicates where the data begins. The TCP header including options is an integral number of 32 bits long.  
{{< indent >}} 这个数表示 TCP 头部的长度有多少个 32 bit，表示真正数据开始的位置。

Reserved: 6 bits  
{{< indent >}} Reserved for future use. Must be zero.  
{{< indent >}} 保留将来使用，全部为 0。

Control Bits: 8 bits (from left to right):  
{{< indent >}} URG: Urgent Pointer field significant 紧急标志  
{{< indent >}} ACK: Acknowledgment field significant 确认标志  
{{< indent >}} EOL: End of Letter 信件结束标志  
{{< indent >}} RST: Reset the connection 重置标志  
{{< indent >}} SYN: Synchronize sequence numbers 同步标志  
{{< indent >}} FIN: No more data from sender 断开连接标志

Window: 16 bits  
{{< indent >}} The number of data octets beginning with the one indicated in the acknowledgment field which the sender of this segment is willing to accept.  
{{< indent >}} 从确认序号开始，发送方可以接收的字节数。

Checksum: 16 bits  
{{< indent >}} The checksum field is the 16 bit one's complement of the one's complement sum of all 16 bit words in the header and text.  
{{< indent >}} 检验和是头部和数据部分所有分割成 16 bit 数的经过二进制反码求和得到的数。  
{{< indent >}} If a segment contains an odd number of header and text octets to be checksummed, the last octet is padded on the right with zeros to form a 16 bit word for checksum purposes.  
{{< indent >}} 如果 TCP 段头部和数据部分是奇数个字节要进行校验，则在最后一个字节右边填充零，以形成一个 16 bit，用于校验。  
{{< indent >}} The pad is not transmitted as part of the segment.  
{{< indent >}} 填充不会作为 TCP 段的一部分进行传输。  
{{< indent >}} While computing the checksum, the checksum field itself is replaced with zeros.  
{{< indent >}} 在计算校验和时，校验和字段本身用零替换。

{{< indent >}} The checksum also covers a 96 bit pseudo header conceptually prefixed to the TCP header.  
{{< indent >}} 在校验和时还包括一个 96 bit 的伪头部，加在 TCP 头部前面。  
{{< indent >}} This pseudo header contains the Source Address, the Destination Address, the Protocol, and TCP length.  
{{< indent >}} 这个伪头部包含源地址、目标地址、协议和 TCP 长度。
{{< indent >}} This gives the TCP protection against misrouted segments.  
{{< indent >}} 这为 TCP 提供了防止错误路由 TCP 段的保护。  
{{< indent >}} This information is carried in the Internet Protocol and is transferred across the TCP/Network interface in the arguments or results of calls by the TCP on the IP.  
{{< indent >}} 这些信息在 IP 协议中携带，并在 TCP/网络接口上通过 TCP 对 IP 的调用的参数或结果进行传输。

{{< center >}}

```
+--------------------------+
|      Source Address      |
+--------------------------+
|    Destination Address   |
+--------------------------+
| zero | PTCL | TCP Length |
+--------------------------+
```

{{< /center >}}

{{< indent >}} The TCP Length is the TCP header plus the data length in octets (this is not an explicitly transmitted quantity, but is computed from the total length, and the header length).  
{{< indent >}} TCP 长度是 TCP 报头加上数据部分的长度，单位是字节（这不是一个明确的传输量，而是从总长度和头部长度计算出来的）。

Urgent Pointer: 16 bits  
{{< indent >}} This field communicates the current value of the urgent pointer as a positive offset from the sequence number in this segment.  
{{< indent >}} 这个字段表示当前紧急指针距离本段中序列号的正偏移。  
{{< indent >}} The urgent pointer points to the sequence number of the octet following the urgent data.  
{{< indent >}} 紧急指针指向紧急数据后的字节的序列号。  
{{< indent >}} This field should only be interpreted in segments with the URG control bit set.  
{{< indent >}} 这个字段只应在设置了 URG 标志的 TCP 段中使用。

Options: variable  
{{< indent >}} Options may occupy space at the end of the TCP header and are a multiple of 8 bits in length.  
{{< indent >}} 可选部分可能占用 TCP 头的末尾的空间，长度为 8bit 的倍数。  
{{< indent >}} All options are included in the checksum.
{{< indent >}} 可选部分也包括在检验和的计算中。
{{< indent >}} An option may begin on any octet boundary. There are two cases for the format of an option:
{{< indent >}} 可选部分可以从任何字节边界上开始。选项的格式有两种情况：

- Case 1: A single octet of option-kind.  
  情况 1: 一个字节的选项类型。
- Case 2: An octet of option-kind, an octet of option-length, and the actual option-data octets.  
  情况 2: 一个字节的选项类型、一个字节的选项长度和真正选项数据。

{{< indent >}} The option-length counts the two octets of option-kind and option-length as well as the option-data octets.  
{{< indent >}} 选项长度包括选项种类和选项长度的两个字节，以及选项数据的字节数。

{{< indent >}} Note that the list of options may be shorter than the data offset field might imply.  
{{< indent >}} 注意：选项列表可能比数据偏移字段要短。  
{{< indent >}} The content of the header beyond the End-of-Option option should be header padding (i.e., zero).  
{{< indent >}} 头部中在选项之外的内容是填充（即，0）。

{{< indent >}} A TCP must implement all options.  
{{< indent >}} TCP 必须实现所有选项。

{{< indent >}} Currently defined options include (kind indicated in octal):  
{{< indent >}} 目前定义的选项包括（种类以八进制表示）：

```
Kind     Length    Meaning
----     ------    -------
 0         -       End of option list.
 1         -       No-Operation.
100        -       Reserved.
105        4       Buffer Size.
```

{{< indent >}} Specific Option Definitions  
{{< indent >}} 具体选项定义

{{< indent >}} End of Option List

```
+--------+
|00000000|
+--------+
Kind=0
```

{{< indent >}} This option code indicates the end of the option list.  
{{< indent >}} 该选项代码表示选项列表的结束。  
{{< indent >}} This might not coincide with the end of the TCP header according to the Data Offset field.  
{{< indent >}} 根据数据偏移字段，这可能与 TCP 头的结尾不一致。  
{{< indent >}} This is used at the end of all options, not the end of each option, and need only be used if the end of the options would not otherwise coincide with the end of the TCP header.  
{{< indent >}} 这用于所有选项的末尾，而不是每个选项的末尾，并且仅在选项末尾与 TCP 头末尾不一致时才需要使用。

No-Operation

```
+--------+
|00000001|
+--------+
Kind=1
```

{{< indent >}} This option code may be used between options, for example, to align the beginning of a subsequent option on a word boundary.  
{{< indent >}} 该选项代码可以在选项之间使用，例如，在一个字的边界上对准后续选项的开头。  
{{< indent >}} There is no guarantee that senders will use this option, so receivers must be prepared to process options even if they do not begin on a word boundary.  
{{< indent >}} 不能保证发送者会使用这个选项，所以接收者必须准备好处理选项，即使它们不以字的边界开始。

Buffer Size

```
+--------+--------+---------+--------+
|01000101|00000100|    buffer size   |
+--------+--------+---------+--------+
Kind=105 Length=4

```

Buffer Size Option Data: 16 bits

{{< indent >}} If this option is present, then it communicates the receive buffer size at the TCP which sends this segment.  
{{< indent >}} 如果该选项存在，那么它在发送该段的 TCP 上传达接收缓冲区的大小。  
{{< indent >}} This field should only be sent in the initial connection request (i.e., in segments with the SYN control bit set).  
{{< indent >}} 该字段应该只在初始连接请求中发送（即在设置了 SYN 标志的段中）。  
{{< indent >}} If this option is not used, the default buffer size of one octet is assumed.  
{{< indent >}} 如果不使用这个选项，则假定默认的缓冲区大小为一个字节。

Padding: variable

{{< indent >}} The TCP header padding is used to ensure that the TCP header ends and data begins on a 32 bit boundary. The padding is composed of zeros.  
{{< indent >}} TCP 头的填充用于确保 TCP 头的结束和数据的开始都在 32 bit 边界上。填充是由零组成的。

### 术语表

3.2. Terminology

Before we can discuss very much about the operation of the TCP we need to introduce some detailed terminology.  
在我们非常深入地讨论 TCP 的运作之前，我们需要介绍一些复杂的术语。

The maintenance of a TCP connection requires the remembering of several variables.  
维护一个 TCP 连接需要记住几个变量。

We conceive of these variables being stored in a connection record called a Transmission Control Block or TCB.  
我们设想这些变量被存储在一个叫做传输控制块或 TCB 的连接记录中。

Among the variables stored in the TCB are the local and remote socket numbers, the security and precedence of the connection, pointers to the user's send and receive buffers, pointers to the retransmit queue and to the current segment.  
TCB 中存储的变量包括本地和远程套接字编号、连接的安全性和优先级、指向用户的发送和接收缓冲区的指针、指向重传队列和当前段的指针。

In addition several variables relating to the send and receive sequence numbers are stored in the TCB.  
此外，与发送和接收序列号相关的几个变量存储在 TCB 中。

Send Sequence Variables  
发送序列变量

```
SND.UNA - send unacknowledged
SND.NXT - send sequence
SND.WND - send window
SND.BS  - send buffer size
SND.UP  - send urgent pointer
SND.WL  - send sequence number used for last window update
SND.LBB - send last buffer beginning
ISS     - initial send sequence number
```

Receive Sequence Variables  
接收序列变量

```
RCV.NXT - receive sequence
RCV.WND - receive window
RCV.BS  - receive buffer size
RCV.UP  - receive urgent pointer
RCV.LBB - receive last buffer beginning
IRS     - initial receive sequence number
```

The following diagrams may help to relate some of these variables to the sequence space.  
下图可能有助于将其中一些变量与序列空间联系起来。
{{< center >}}

```
    1         2          3          4
----------|----------|----------|----------
SND.UNA    SND.NXT    SND.UNA
                     +SND.WND

1 - old sequence numbers which have been acknowledged
2 - sequence numbers of unacknowledged data
3 - sequence numbers allowed for new data transmission
4 - future sequence numbers which are not yet allowed
```

Send Sequence Space

Figure 4.

{{< /center >}}

{{< center >}}

```
  1          2          3
----------|----------|----------
RCV.NXT    RCV.NXT
          +RCV.WND

1 - old sequence numbers which have been acknowledged
2 - sequence numbers allowed for new reception
3 - future sequence numbers which are not yet allowed
```

Receive Sequence Space

Figure 5.

{{< /center >}}

There are also some variables used frequently in the discussion that take their values from the fields of the current segment.  
还有一些在讨论中经常使用的变量，它们的值来自当前段的字段。

Current Segment Variables
当前段变量

```
SEG.SEQ - segment sequence number
SEG.ACK - segment acknowledgment number
SEG.LEN - segment length
SEG.WND - segment window
SEG.UP  - segment urgent pointer
SEG.PRC - segment precedence value
```

A connection progresses through a series of states during its lifetime.  
一个连接在其生命周期中会经历一系列的状态。

The states are: LISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, TIME-WAIT, CLOSE-WAIT, CLOSING, and the fictional state CLOSED.  
这些状态是：LISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, TIME-WAIT, CLOSE-WAIT, CLOSING，以及虚构的状态 CLOSED。

CLOSED is fictional because itrepresents the state when there is no TCB, and therefore, no connection.  
CLOSED 是虚构的，因为它代表了没有 TCB 的状态，也就是没有连接。

Briefly the meanings of the states are:  
简而言之，这些状态的含义是：

LISTEN - represents waiting for a connection request from any remote TCP and port.  
LISTEN - 表示等待来自任何远程 TCP 和端口的连接请求。

SYN-SENT - represents waiting for a matching connection request after having sent a connection request.  
SYN-SENT - 表示在发送了一个连接请求后等待一个匹配的连接请求。

SYN-RECEIVED - represents waiting for a confirming connection request acknowledgment after having both received and sent a connection request.  
SYN-RECEIVED - 表示在收到和发送连接请求后，等待确认连接请求的确认。

ESTABLISHED - represents an open connection, ready to transmit and receive data segments.  
ESTABLISHED - 代表一个已建立的连接，准备发送和接收 TCP 段。

FIN-WAIT-1 - represents waiting for a connection termination request from the remote TCP, or an acknowledgment of the connection termination request previously sent.  
FIN-WAIT-1 - 表示等待来自远程 TCP 的连接终止请求，或等待之前发送的终止连接请求的确认。

FIN-WAIT-2 - represents waiting for a connection termination request from the remote TCP.  
FIN-WAIT-2 - 表示等待来自远程 TCP 的连接终止请求。

TIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.  
TIME-WAIT - 表示等待足够的时间来确保远程 TCP 收到其连接终止请求的确认。

CLOSE-WAIT - represents waiting for a connection termination request from the local user.  
CLOSE-WAIT - 表示等待本端用户的连接终止请求。

CLOSING - represents waiting for a connection termination request acknowledgment from the remote TCP.  
CLOSING - 表示等待来自远程 TCP 的连接终止请求确认。

CLOSED - represents no connection state at all.  
CLOSED - 表示没有连接的状态。

A TCP connection progresses from one state to another in response to events.  
TCP 连接根据事件从一个状态转换到另一个状态。

The events are the user calls, OPEN, SEND, RECEIVE, CLOSE, ABORT, and STATUS; the incoming segments, particularly those containing the SYN and FIN flags; and timeouts.  
这些事件是用户调用 OPEN、SEND、RECEIVE、CLOSE、ABORT 和 STATUS；收到 TCP 段，特别是包含 SYN 和 FIN 标志的段；以及超时。

The Glossary contains a more complete list of terms and their definitions.  
术语表包含了一个更完整的术语及其定义清单。

The state diagram in figure 6 only illustrates state changes, together with the causing events and resulting actions, but addresses neither error conditions nor actions which are not connected with state changes.  
图 6 中的状态图只说明了状态的变化，以及引起的事件和触发的行为，但既没有涉及错误条件，也没有涉及与状态变化无关的行为。

In a later section, more detail is offered with respect to the reaction of the TCP to events.  
在后面的章节中，将提供关于 TCP 对事件反应的更多细节。

```
                              +---------+ ---------\      active OPEN
                              |  CLOSED |            \    -----------
                              +---------+<---------\   \   create TCB
                                |     ^              \   \  snd SYN
                   passive OPEN |     |   CLOSE        \   \
                   ------------ |     | ----------       \   \
                    create TCB  |     | delete TCB         \   \
                                V     |                      \   \
                              +---------+            CLOSE    |    \
                              |  LISTEN |          ---------- |     |
                              +---------+          delete TCB |     |
                   rcv SYN      |     |     SEND              |     |
                  -----------   |     |    -------            |     V
 +---------+      snd SYN,ACK  /       \   snd SYN          +---------+
 |         |<-----------------           ------------------>|         |
 |   SYN   |                    rcv SYN                     |   SYN   |
 |   RCVD  |<-----------------------------------------------|   SENT  |
 |         |                    snd ACK                     |         |
 |         |------------------           -------------------|         |
 +---------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +---------+
   |           --------------   |     |   -----------
   |                  x         |     |     snd ACK
   |                            V     V
   |  CLOSE                   +---------+
   | -------                  |  ESTAB  |
   | snd FIN                  +---------+
   |                   CLOSE    |     |    rcv FIN
   V                  -------   |     |    -------
 +---------+          snd FIN  /       \   snd ACK          +---------+
 |  FIN    |<-----------------           ------------------>|  CLOSE  |
 | WAIT-1  |------------------           -------------------|   WAIT  |
 +---------+          rcv FIN  \       /   CLOSE            +---------+
   | rcv ACK of FIN   -------   |     |   -------
   | --------------   snd ACK   |     |   snd FIN
   V        x                   V     V
 +---------+                  +---------+
 |FINWAIT-2|                  | CLOSING |
 +---------+                  +---------+
   | rcv FIN                          | rcv ACK of FIN
   | -------    Timeout=2MSL          | --------------
   V snd ACK    ------------          V   delete TCB
 +---------+     delete TCB   +---------+
 |TIME WAIT|----------------->| CLOSED  |
 +---------+                  +---------+

```

{{< center >}}
TCP Connection State Diagram  
TCP 连接状态图

Figure 6.
{{< /center >}}

### 序列号

3.3. Sequence Numbers

A fundamental notion in the design is that every octet of data sent over a TCP connection has a sequence number.  
TCP 设计中的一个基本概念是，通过 TCP 连接发送的每个字节的数据都有一个序列号。

Since every octet is sequenced, each of them can be acknowledged.  
由于每个字节都是有顺序的，所以每个字节都可以被确认。

The acknowledgment mechanism employed is cumulative so that an acknowledgment of sequence number X indicates that all octets up to but not including X have been received.  
TCP 所采用的确认机制是累积性的，因此序列号为 X 的确认表示已经收到了之前但不包括 X 的所有字节。

This mechanism allows for straight-forward duplicate detection in the presence of retransmission.  
这种机制使得在存在重传的情况下可以直接进行重复检测。

Numbering of octets within a segment is that the first data octet immediately following the header is the lowest numbered, and the following octets are numbered consecutively.  
TCP 段内字节的编号是，TCP 头后的第一个字节数据是最小的编号，后面字节的编号是连续递增。

It is essential to remember that the actual sequence number space is finite, though very large.  
需要记住，实际的序列号范围是有限的，尽管非常大。

This space ranges from 0 to 2\*\*32 - 1.  
这个范围是从 0 到 2\*\*32-1 。

Since the space is finite, all arithmetic dealing with sequence numbers must be performed modulo 2\*\*32.  
由于范围是有限的，所有处理序列号的运算都必须模 2\*\*32。

This unsigned arithmetic preserves the relationship of sequence numbers as they cycle from 2\*\*32 - 1 to 0 again.  
这种无符号算术保留了序列号之间的关系，因为它们从 2\*\*32-1 再重新到 0。

There are some subtleties to computer modulo arithmetic, so great care should be taken in programming the comparison of such values.  
计算机模运算有一些细微的差异，所以在编程比较这些值时应该非常小心。

The typical kinds of sequence number comparisons which the TCP must perform include:  
TCP 中需要操作的典型的序列号比较包括：

(a) Determining that an acknowledgment refers to some sequence number sent but not yet acknowledged.  
(a) 确定一个确认是对应某个已发送但尚未确认的序列号。

(b) Determining that all sequence numbers occupied by a segment have been acknowledged (e.g., to remove the segment from a retransmission queue).  
(b) 确定 TCP 段所占用的所有序列号都已被确认（例如，从重传队列中删除该 TCP 段）。

(c) Determining that an incoming segment contains sequence numbers which are expected (i.e., that the segment "overlaps" the receive window).  
(c) 确定一个收到的 TCP 段包含预期的序列号（即该 TCP 段与接收窗口"重叠"）。

On send connections the following comparisons are needed:  
在发送端的连接上，需要进行以下比较：

```
      older sequence numbers                        newer sequence numbers

            SND.UNA                SEG.ACK                 SND.NXT
              |                      |                       |
          ----|----XXXXXXX------XXXXXXXXXX---------XXXXXX----|----
              |    |            |    |             |         |
                   |            |                  |
                Segment 1    Segment 2          Segment 3

                         <----- sequence space ----->
```

{{< center >}}
Sending Sequence Space Information  
发送序列空间信息

Figure 7.

{{< /center >}}

SND.UNA = oldest unacknowledged sequence number  
SND.UNA = 最早的未确认的序列号

SND.NXT = next sequence number to be sent  
SND.NXT = 下一个要发送的序列号

SEG.ACK = acknowledgment (next sequence number expected by the acknowledging TCP)  
SEG.ACK = 确认（确认的 TCP 所期望的下一个序列号）。

SEG.SEQ = first sequence number of a segment  
SEG.SEQ = TCP 段的第一个序列号

SEG.SEQ+SEG.LEN-1 = last sequence number of a segment  
SEG.SEQ+SEG.LEN-1 = TCP 段的最后一个序列号

A new acknowledgment (called an "acceptable ack"), is one for which the inequality below holds:  
一个新的确认（即 "可接受的确认"），会满足以下不等式。  
SND.UNA < SEG.ACK =< SND.NXT

All arithmetic is modulo 2\*\*32 and that comparisons are unsigned.  
所有的运算都需要以 2/\*\*32 为模数，而且是无符号比较。

"=<" means "less than or equal".  
"=<" 表示 "小于或等于"。

A segment on the retransmission queue is fully acknowledged if the sum of its sequence number and length is less than the acknowledgment value in the incoming segment.  
如果重传队列中的一个 TCP 段的序列号和长度之和小于收到段的确认值，则该段被完全确认。

SEG.LEN is the number of octets occupied by the data in the segment.  
SEG.LEN 是 TCP 段中数据所占的字节数。

It is important to note that SEG.LEN must be non-zero; segments which do not occupy any sequence space (e.g., empty acknowledgment segments) are never placed on the retransmission queue, so would not go through this particular test.  
值得注意的是，SEG.LEN 必须非零；不占用任何序列空间的 TCP 段（例如，空的确认段）永远不会被放在重传队列中，所以不用做这个特殊的测试。

On receive connections the following comparisons are needed:  
在接收端的连接上，需要进行以下比较：

```
      older sequence numbers                        newer sequence numbers

                    RCV.NXT                         RCV.NXT+RCV.WND
                      |                               |
          ---------XXX|XXX------XXXXXXXXXX---------XXX|XX---------
                    |  |         |                  |  |
                    |            |                  |
                Segment 1    Segment 2          Segment 3

                        <----- sequence space ----->
```

{{< center >}}
Receiving Sequence Space Information  
接收序列空间信息

Figure 8.

{{< /center >}}

RCV.NXT = next sequence number expected on incoming segments  
RCV.NXT = 下一个预期收到 TCP 段的序列号

RCV.NXT+RCV.WND = last sequence number expected on incoming segments, plus one
RCV.NXT+RCV.WND = 最后一个预期收到 TCP 段的序列号+1

SEG.SEQ = first sequence number occupied by the incoming segment
SEG.SEQ = 收到 TCP 段的第一个序列号

SEG.SEQ+SEG.LEN-1 = last sequence number occupied by the incoming segment
SEG.SEQ+SEG.LEN-1 = 收到 TCP 段的最后一个序列号

A segment is judged to occupy a portion of valid receive sequence space if  
在下列情况下，一个 TCP 段被判断为占据了有效接收序列范围的一部分

0 =< (SEG.SEQ+SEG.LEN-1 - RCV.NXT) < (RCV.NXT+RCV.WND - RCV.NXT)

SEG.SEQ+SEG.LEN-1 is the last sequence number occupied by the segment; RCV.NXT is the next sequence number expected on an incoming segment; and RCV.NXT+RCV.WND is the right edge of the receive window.  
SEG.SEQ+SEG.LEN-1 是该 TCP 段所占用的最后一个序列号；RCV.NXT 是下一个预期收到的 TCP 段的序列号；RCV.NXT+RCV.WND 是接收窗口的右边界。

Actually, it is a little more complicated than this. Due to zero windows and zero length segments, we have four cases for the acceptability of an incoming segment:  
实际上，情况比这更复杂一些。由于零窗口和零长度的 TCP 段，我们有四种情况来判断一个收到的 TCP 段是否可接受：

```
Segment Receive  Test
Length  Window
------- -------  -------------------------------------------
    0       0     SEG.SEQ = RCV.NXT
    0      >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
   >0       0     not acceptable
   >0      >0     RCV.NXT < SEG.SEQ+SEG.LEN =< RCV.NXT+RCV.WND
```

Note that the acceptance test for a segment, since it requires the end of a segment to lie in the window, is somewhat more restrictive than is absolutely necessary.  
请注意，TCP 段的验收测试，因为它要求 TCP 段的末端位于窗口中，所以比绝对必要的更具限制性。

If at least the first sequence number of the segment lies in the receive window, or if some part of the segment lies in the receive window, then the segment might be judged acceptable.  
如果该 TCP 段至少第一个序列号在接收窗口内，或者该段的某些部分在接收窗口内，那么该 TCP 段可能被判定为可接受。

Thus, in figure 8, at least segments 1 and 2 are acceptable by the strict rule, and segment 3 may or may not be, depending on the strictness of interpretation of the rule.  
因此，在图 8 中，根据严格的规则，至少第 1 和第 2 个 TCP 段是可以接受的，而第 3 个 TCP 段可能是，也可能不是，这取决于对规则解释的严格程度。

Note that when the receive window is zero no segments should be acceptable except ACK segments.  
请注意，当接收窗口为零时，除了 ACK 段外，不应接受其他 TCP 段。

Thus, it should be possible for a TCP to maintain a zero receive window while transmitting data and receiving ACKs.  
因此，TCP 应该有可能在传输数据和接收 ACK 的同时保持一个零接收窗口。

We have taken advantage of the numbering scheme to protect certain control information as well.
我们还利用了编号方案来保护某些控制信息。

This is achieved by implicitly including some control flags in the sequence space so they can be retransmitted and acknowledged without confusion (i.e., one and only one copy of the control will be acted upon).  
这是通过在序列空间中隐含地包括一些控制标志来实现的，使得它们可以被重发和确认而不会产生混淆(即，将对控制的一个且仅一个副本进行操作)。

Control information is not physically carried in the segment data space.  
控制信息不实际在 TCP 段数据空间中携带。

Consequently, we must adopt rules for implicitly assigning sequence numbers to control.
因此，我们必须采用隐式分配序列号的规则来控制。

The SYN and FIN are the only controls requiring this protection, and these controls are used only at connection opening and closing.  
SYN 和 FIN 是唯一需要这种保护的控制，而且这些控制只在连接打开和关闭时使用。

For sequence number purposes, the SYN is considered to occur before the first actual data octet of the segment in which it occurs, while the FIN is considered to occur after the last actual data octet in a segment in which it occurs.  
就序列号而言，SYN 被认为发生在其所在 TCP 段的实际数据第一个字节之前，而 FIN 被认为发生在其所在段的实际数据的最后一个字节之后。

The segment length includes both data and sequence space occupying controls.  
TCP 段的长度包括数据和占用序列空间的控制信息。

When a SYN is present then SEG.SEQ is the sequence number of the SYN.  
当存在 SYN 时，SEG.SEQ 是 SYN 的序列号。

Initial Sequence Number Selection  
初始序列号的选择

The protocol places no restriction on a particular connection being used over and over again.  
该协议不限制反复使用特定连接。

A connection is defined by a pair of sockets.  
一个连接是由一对套接字确定的。

New instances of a connection will be referred to as incarnations of the connection.  
连接的新实例会用来表示连接。

The problem that arises owing to this is -- "how does the TCP identify duplicate segments from previous incarnations of the connection?"  
由此产生的问题是 -- "TCP 如何识别来自以前连接中的重复段？"

This problem becomes apparent if the connection is being opened and closed in quick succession, or if the connection breaks with loss of memory and is then reestablished.  
如果快速连续地打开和关闭连接，或者如果连接因内存丢失而断开，然后重新建立，则此问题会变得明显。

To avoid confusion we must prevent segments from one incarnation of a connection from being used while the same sequence numbers may still be present in the network from an earlier incarnation.  
为了防止出现混乱，我们必须防止使用来自先前连接中有相同序列号的数据段。

We want to assure this, even if a TCP crashes and loses all knowledge of the sequence numbers it has been using.  
我们要保证这一点，即使 TCP 崩溃并失去了它使用的序列号的所有信息。

When new connections are created, an initial sequence number (ISN) generator is employed which selects a new 32 bit ISN.  
当创建新连接时，使用初始序列号(ISN)生成器选择新的 32 位 ISN。

The generator is bound to a (possibly fictitious) 32 bit clock whose low order bit is incremented roughly every 4 microseconds.  
发生器跟一个（可能是虚拟的）32 位时钟绑定，其低位大约每 4 微秒递增一次。

Thus, the ISN cycles approximately every 4.55 hours.  
因此，ISN 大约每 4.55 小时循环一次。

Since we assume that segments will stay in the network no more than tens of seconds or minutes, at worst, we can reasonably assume that ISN's will be unique.  
由于我们假设 TCP 段在网络中的停留时间不超过几十秒或几分钟，即使在最坏的情况下，我们仍然可以地假设 ISN 将是唯一的。

For each connection there is a send sequence number and a receive sequence number.  
对于每个连接，都有一个发送序列号和一个接收序列号。

The initial send sequence number (ISS) is chosen by the data sending TCP, and the initial receive sequence number (IRS) is learned during the connection establishing procedure.  
初始发送序列号（ISS）由发送方的 TCP 选择，初始接收序列号（IRS）在连接建立过程中得到。

For a connection to be established or initialized, the two TCPs must synchronize on each other's initial sequence numbers.  
如果要建立或初始化的连接，两个 TCP 必须同步对方的初始序列号。

This is done in an exchange of connection establishing messages carrying a control bit called "SYN" (for synchronize) and the initial sequence numbers.  
这是通过交换建立连接的信息来完成的，这些信息带有一个称为 "SYN"（用于同步）的控制位和初始序列号。

As a shorthand, messages carrying the SYN bit are also called "SYNs".  
简而言之，携带 SYN 位的消息也称为“SYNs”。

Hence, the solution requires a suitable mechanism for picking an initial sequence number and a slightly involved handshake to exchange the ISN's.  
因此，该解决方案需要一个合适的机制来挑选初始序列号，并需要一个稍微复杂的握手来交换 ISN。

A "three way handshake" is necessary because sequence numbers are not tied to a global clock in the network, and TCPs may have different mechanisms for picking the ISN's.
“三次握手”是必要的，因为序列号没有绑定到网络中的全局时钟，并且 TCP 可能有不同的机制来挑选 ISN。

The receiver of the first SYN has no way of knowing whether the segment was an old delayed one or not, unless it remembers the last sequence number used on the connection (which is not always possible), and so it must ask the sender to verify this SYN.
第一个 SYN 的接收者没有办法知道这个 TCP 段是否是一个旧的延迟段，除非它记得连接上使用的最后一个序列号（这并不总是可能的），所以它必须要求发送者验证这个 SYN。

The "three way handshake" and the advantages of a "clock-driven" scheme are discussed in [4].  
在[4]中讨论了 "三方握手 "和 "时钟驱动" 方案的优势。

Knowing When to Keep Quiet  
知道什么时候该保持静默

To be sure that a TCP does not create a segment that carries a sequence number which may be duplicated by an old segment remaining in the network, the TCP must keep quiet for a maximum segment lifetime (MSL) before assigning any sequence numbers upon starting up or recovering from a crash in which memory of sequence numbers in use was lost.  
为了确保 TCP 不会创建一个携带与网络中旧 TCP 段中序列号重复的 TCP 段，TCP 在启动时或从丢失当前使用序列号内存的崩溃中恢复时，在分配任何序列号之前保持最大网段寿命（MSL）的静默时间。

For this specification the MSL is taken to be 2 minutes.  
在本规范中，MSL 是 2 分钟。

This is an engineering choice, and may be changed if experience indicates it is desirable to do so.  
这是一个工程选择，它可能会根据经验改变。

Note that if a TCP is reinitialized in some sense, yet retains its memory of sequence numbers in use, then it need not wait at all; it must only be sure to use sequence numbers larger than those recently used.  
请注意，如果一个 TCP 在某种情况被重新初始化，但保留了其正在使用的序列号的内存，那么它不需要等待；它只需要确保使用比最近使用的序列号大的序列号。

It should be noted that this strategy does not protect against spoofing or other replay type duplicate message problems.  
应该注意的是，这种策略不能防止欺骗或其他重复发送相同信息问题。

### 建立连接

3.4. Establishing a connection

The "three-way handshake" is the procedure used to establish a connection.  
“三次握手”是用于建立连接的过程。

This procedure normally is initiated by one TCP and responded to by another TCP.  
这个过程通常由一个 TCP 发起，由另一个 TCP 响应。

The procedure also works if two TCP simultaneously initiate the procedure.  
如果两个 TCP 同时发起连接，该过程也应正常工作。

When simultaneous attempt occurs, the TCP receives a "SYN" segment which carries no acknowledgment after it has sent a "SYN".  
当同时尝试建立连接时，TCP 在发送 "SYN" 后，收到没有携带确认的 "SYN" 段。

Of course, the arrival of an old duplicate "SYN" segment can potentially make it appear, to the recipient, that a simultaneous connection initiation is in progress.  
当然，当接收者收到一个旧的重复的 "SYN" 段时，有可能会认为是同时建立连接。

Proper use of "reset" segments can disambiguate these cases.  
适当使用 "reset" 段可以消除这些情况。

Several examples of connection initiation follow.  
下面是几个建立连接的例子。

Although these examples do not show connection synchronization using data-carrying segments, this is perfectly legitimate, so long as the receiving TCP doesn't deliver the data to the user until it is clear the data is valid (i.e., the data must be buffered at the receiver until the connection reaches the ESTABLISHED state).  
虽然这些例子中连接同步没有显示携带数据，这是完全可以的，在接收 TCP 明确数据有效之前，它不向用户传递数据（即这些数据必须先放在接收者的缓存中，直到连接达到 ESTABLISHED 状态）。

The three-way handshake reduces the possibility of false connections.  
三次握手降低了错误连接的可能性。

It is the implementation of a trade-off between memory and messages to provide information for this checking.  
它是内存和消息之间的权衡的实现，为该检查提供信息。

The simplest three-way handshake is shown in figure 9 below.  
最简单的三次握手如下面的图 9 所示。

The figures should be interpreted in the following way.  
这些符号应作如下解释。

Each line is numbered for reference purposes.  
每行都有编号，以便参考。

Right arrows (-->) indicate departure of a TCP segment from TCP A to TCP B, or arrival of a segment at B from A.  
右箭头 (-->) 表示从 TCP A 发送到 TCP B 的 TCP 段，或 B 接收到 A 的 TCP 段。

Left arrows (<--), indicate the reverse.  
左箭头 (<--) 表示相反方向。

Ellipsis (...) indicates a segment which is still in the network (delayed).  
省略号 (...) 表示仍在网络中的 TCP 段(延迟了)。

An "XXX" indicates a segment which is lost or rejected.  
“XXX” 表示丢失或被拒绝的 TCP 段。

Comments appear in parentheses.  
括号中的是注释。

TCP states represent the state AFTER the departure or arrival of the segment (whose contents are shown in the center of each line).  
TCP 状态表示数据段发送或到达后的状态(其内容显示在每行的中间)。

Segment contents are shown in abbreviated form, with sequence number, control flags, and ACK field.  
TCP 段的内容以缩写的形式显示，包括序列号、控制标志和 ACK 字段。

Other fields such as window, addresses, lengths, and text have been left out in the interest of clarity.  
为清楚起见，省略了其他字段，如窗口、地址、长度和文本。

```
      TCP A                                                 TCP B
  1.  CLOSED                                                LISTEN
  2.  SYN-SENT    --> <SEQ=100><CTL=SYN>                --> SYN-RECEIVED
  3.  ESTABLISHED <-- <SEQ=300><ACK=101><CTL=SYN,ACK>   <-- SYN-RECEIVED
  4.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK>       --> ESTABLISHED
  5.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK><DATA> --> ESTABLISHED
```

{{< center >}}
Basic 3-Way Handshake for Connection Synchronization  
用于连接同步的基础三次握手协议

Figure 9.

{{< /center >}}

In line 2 of figure 9, TCP A begins by sending a SYN segment indicating that it will use sequence numbers starting with sequence number 100.  
在图 9 的第 2 行，TCP A 开始发送一个 SYN 段，表明它将使用从序列号 100 开始的序列号。

In line 3, TCP B sends a SYN and acknowledges the SYN it received from TCP A.  
在第 3 行，TCP B 发送了一个 SYN，并确认了它从 TCP A 收到的 SYN。

Note that the acknowledgment field indicates TCP B is now expecting to hear sequence 101, acknowledging the SYN which occupied sequence 100.  
注意，确认字段表明 TCP B 现在期望收到到序列 101，确认收到序列 100 的 SYN。

At line 4, TCP A responds with an empty segment containing an ACK for TCP B's SYN; and in line 5, TCP A sends some data.  
在第 4 行，TCP A 发送一个包含 ACK 的空段回应 TCP B 的 SYN；在第 5 行，TCP A 发送了一些数据。

Note that the sequence number of the segment in line 5 is the same as in line 4 because the ACK does not occupy sequence number space (if it did, we would wind up ACKing ACK's!).  
请注意，第 5 行的 TCP 段的序列号与第 4 行相同，因为 ACK 不占用序列号空间（如果它占用了，我们就会变成 ACK 的 ACK！）。

Simultaneous initiation is only slightly more complex, as is shown in figure 10.
同时建立连接只是稍微复杂一些，如图 10 所示。

Each TCP cycles from CLOSED to SYN-SENT to SYN-RECEIVED to ESTABLISHED.  
每个 TCP 从 CLOSED 到 SYN-SENT 到 SYN-RECEIVED 到 ESTABLISHED 循环。

The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.  
三次握手的主要原因是为了防止旧的重复连接启动造成混乱。

To deal with this, a special control message, reset, has been devised.  
为了解决这个问题，我们设计了一个特殊的控制消息--reset。

If the receiving TCP is in a non-synchronized state (i.e., SYN-SENT, SYN-RECEIVED), it returns to LISTEN on receiving an acceptable reset.  
如果接收的 TCP 处于非同步状态（即 SYN-SENT，SYN-RECEIVED），它在收到有效的 reset 时返回到 LISTEN。

If the TCP is in one of the synchronized states (ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, TIME-WAIT, CLOSE-WAIT, CLOSING), it aborts the connection and informs its user.  
如果 TCP 处于同步状态之一（ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, TIME-WAIT, CLOSE-WAIT, CLOSING），它将中止连接并通知其用户。

We discuss this latter case under "half-open" connections below.  
我们将在下面的 “half-open” 连接下讨论后面一种情况。

```
      TCP A                                        TCP B
  1.  CLOSED                                       CLOSED
  2.  SYN-SENT     --> <SEQ=100><CTL=SYN>          ...
  3.  SYN-RECEIVED <-- <SEQ=300><CTL=SYN>          <-- SYN-SENT
  4.               ... <SEQ=100><CTL=SYN>          --> SYN-RECEIVED
  5.  SYN-RECEIVED --> <SEQ=101><ACK=301><CTL=ACK> ...
  6.  ESTABLISHED  <-- <SEQ=301><ACK=101><CTL=ACK> <-- SYN-RECEIVED
  7.               ... <SEQ=101><ACK=301><CTL=ACK> --> ESTABLISHED
```

{{< center >}}
Simultaneous Connection Synchronization  
同时连接同步

Figure 10.

{{< /center >}}

```
      TCP A                                                TCP B
  1.  CLOSED                                               LISTEN
  2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               ...
  3.  (duplicate) ... <SEQ=1000><CTL=SYN>              --> SYN-RECEIVED
  4.  SYN-SENT    <-- <SEQ=300><ACK=1001><CTL=SYN,ACK> <-- SYN-RECEIVED
  5.  SYN-SENT    --> <SEQ=1001><CTL=RST>              --> LISTEN

  6.              ... <SEQ=100><CTL=SYN>               --> SYN-RECEIVED
  7.  SYN-SENT    <-- <SEQ=400><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED
  8.  ESTABLISHED --> <SEQ=101><ACK=401><CTL=ACK>      --> ESTABLISHED
```

{{< center >}}
Recovery from Old Duplicate SYN  
从之前重复 SYN 中恢复

Figure 11.

{{< /center >}}

As a simple example of recovery from old duplicates, consider figure 11.  
从之前重复 SYN 中恢复的简单示例，请参见图 11。

At line 3, an old duplicate SYN arrives at TCP B.  
在第 3 行，一个之前重复 SYN 到达了 TCP B。

TCP B cannot tell that this is an old duplicate, so it responds normally (line 4).  
TCP B 无法断定这是之前的 SYN，所以它正常响应（第 4 行）。

TCP A detects that the ACK field is incorrect and returns a RST (reset) with its SEQ field selected to make the segment believable.  
TCP A 检测到 ACK 字段不正确，然后返回一个 RST（重置），同时选择 SEQ 字段以使该 TCP 段可信。

TCP B, on receiving the RST, returns to the LISTEN state.  
TCP B 收到 RST 后，返回到 LISTEN 状态。

When the original SYN (pun intended) finally arrives at line 6, the synchronization proceeds normally.  
在第 6 行，当真正的 SYN（双关语）最终到达时，同步正常进行。

If the SYN at line 6 had arrived before the RST, a more complex exchange might have occurred with RST's sent in both directions.  
如果第 6 行的 SYN 在 RST 之前到达，则可能会发生更复杂的交换，双方都会发送 RST。

Half-Open Connections and Other Anomalies  
半开放连接和其他异常情况

An established connection is said to be "half-open" if one of the TCPs has closed or aborted the connection at its end without the knowledge of the other, or if the two ends of the connection have become desynchronized owing to a crash that resulted in loss of memory.  
如果其中一个 TCP 在另一个不知道的情况下关闭或中止了连接，或者连接的两端由于崩溃导致内存丢失而变得不同步，则已建立的连接被称为 "半开放"。

Such connections will automatically become reset if an attempt is made to send data in either direction.  
如果尝试向任一方向发送数据，这种连接将自动重置。

However, half-open connections are expected to be unusual, and the recovery procedure is mildly involved.  
然而，半开放连接被认为是不正常的，恢复过程也涉及到一些问题。

If at site A the connection no longer exists, then an attempt by the user at site B to send any data on it will result in the site B TCP receiving a reset control message.  
如果站点 A 的连接不再存在，那么站点 B 的用户试图在其上发送任何数据将导致站点 B 的 TCP 收到重置控制消息。

Such a message should indicate to the site B TCP that something is wrong, and it is expected to abort the connection.  
这种消息表明 B 的 TCP 有问题，并希望它能中止连接。

Assume that two user processes A and B are communicating with one another when a crash occurs causing loss of memory to A's TCP.  
假设两个用户进程 A 和 B 正在相互通信，当发生崩溃导致 A 的 TCP 丢失内存时。

Depending on the operating system supporting A's TCP, it is likely that some error recovery mechanism exists.
可能会存在一些错误恢复机制，这取决于 TCP A 所运行的操作系统。

When the TCP is up again, A is likely to start again from the beginning or from a recovery point.  
当 TCP 再次启动时，A 可能会从头或从某个恢复点重新启动。

As a result, A will probably try to OPEN the connection again or try to SEND on the connection it believes open.  
因此，A 可能会尝试再次打开连接或尝试在它认为已经打开的连接上发送。

In the latter case, it receives the error message "connection not open" from the local (A's) TCP.  
在后面一种情况下，它会收到来自本地(A) TCP 的错误消息 “Connection Not Open”。

In an attempt to establish the connection, A's TCP will send a segment containing SYN.  
在尝试建立连接时，A 的 TCP 将发送包含 SYN 的 TCP 段。

This scenario leads to the example shown in figure 12.  
这种情况的示例如图 12 所示。

After TCP A crashes, the user attempts to re-open the connection.  
在 TCP A 崩溃后，用户试图重新打开连接。

TCP B, in the meantime, thinks the connection is open.  
在此期间，TCP B 认为连接是打开的。

```
      TCP A                                           TCP B
  1.  (CRASH)                               (send 300,receive 100)
  2.  CLOSED                                           ESTABLISHED
  3.  SYN-SENT --> <SEQ=400><CTL=SYN>              --> (??)
  4.  (!!)     <-- <SEQ=300><ACK=100><CTL=ACK>     <-- ESTABLISHED
  5.  SYN-SENT --> <SEQ=100><CTL=RST>              --> (Abort!!)
  6.                                                   CLOSED
  7.  SYN-SENT --> <SEQ=400><CTL=SYN>              -->
```

{{< center >}}
Half-Open Connection Discovery  
半开放连接发现

Figure 12.

{{< /center >}}

When the SYN arrives at line 3, TCP B, being in a synchronized state, responds with an acknowledgment indicating what sequence it next expects to hear (ACK 100).  
在第 3 行，当 SYN 到达时，处于同步状态的 TCP B 以确认的方式回应，表明它接下来希望收到的序列（ACK 100）。

TCP A sees that this segment does not acknowledge anything it sent and, being unsynchronized, sends a reset (RST) because it has detected a half-open connection.  
TCP A 看到这个 TCP 段没有确认它所发送的任何东西，并且由于不同步，发送了一个重置（RST），因为它检测到一个半开放的连接。

TCP B aborts at line 5.  
在第 5 行，TCP B 终止。

TCP A will continue to try to establish the connection; the problem is now reduced to the basic 3-way handshake of figure 9.  
TCP A 会继续尝试建立连接；问题现在简化为图 9 中基础的三次握手。

An interesting alternative case occurs when TCP A crashes and TCP B tries to send data on what it thinks is a synchronized connection.  
另一种有趣的情况是，当 TCP A 崩溃，而 TCP B 尝试在它认为是同步的连接上发送数据时。

This is illustrated in figure 13.  
图 13 说明了这种情况。

In this case, the data arriving at TCP A from TCP B (line 2) is unacceptable because no such connection exists, so TCP A sends a RST.  
在这种情况下，从 TCP B 到达 TCP A 的数据（第 2 行）是无效的，因为不存在这样的连接，所以 TCP A 发送了一个 RST。

The RST is acceptable so TCP B processes it and aborts the connection.  
RST 是有效的，所以 TCP B 处理它并终止连接。

```
      TCP A                                           TCP B
  1.  (CRASH)                                   (send 300,receive 100)
  2.  (??)    <-- <SEQ=300><ACK=100><DATA=10><CTL=ACK> <-- ESTABLISHED
  3.          --> <SEQ=100><CTL=RST>                   --> (ABORT!!)
```

{{< center >}}
Active Side Causes Half-Open Connection Discovery  
活跃端导致半开放连接的发现

Figure 13.

{{< /center >}}

In figure 14, we find the two TCPs A and B with passive connections waiting for SYN.  
在图 14 中，我们发现两个 TCPs A 和 B 是被动连接等待 SYN。

An old duplicate arriving at TCP B (line 2) stirs B into action.  
一个以前重复的 SYN 到达 TCP B（第 2 行），导致 B 做出回应。

A SYN-ACK is returned (line 3) and causes TCP A to generate a RST (the ACK in line 3 is not acceptable).  
一个 SYN-ACK 被返回（第 3 行），并导致 TCP A 产生一个 RST（第 3 行的 ACK 是无效的）。

TCP B accepts the reset and returns to its passive LISTEN state.  
TCP B 接受重置，并返回到其被动的 LISTEN 状态。

```
      TCP A                                         TCP B
  1.  LISTEN                                        LISTEN
  2.       ... <SEQ=Z><CTL=SYN>                -->  SYN-RECEIVED
  3.  (??) <-- <SEQ=X><ACK=Z+1><CTL=SYN,ACK>   <--  SYN-RECEIVED
  4.       --> <SEQ=Z+1><CTL=RST>              -->  (return to LISTEN!)
  5.  LISTEN                                        LISTEN
```

{{< center >}}
Old Duplicate SYN Initiates a Reset on two Passive Sockets  
以前重复 SYN 在两个被动套接字上启动重置

Figure 14.

{{< /center >}}

A variety of other cases are possible, all of which are accounted for by the following rules for RST generation and processing.  
可能存在多种其他情况，所有这些情况都可以通过以下 RST 生成和处理规则解释。

Reset Generation  
重置生成

As a general rule, reset (RST) should be sent whenever a segment arrives which apparently is not intended for the current or a future incarnation of the connection.  
作为一般规则，当一个 TCP 段到达时，如果显然不是为当前或未来的连接准备的，就应该发送复位（RST）。

A reset should not be sent if it is not clear that this is the case.  
如果不清楚是这种情况，就不应该发送重置。

Thus, if any segment arrives for a nonexistent connection, a reset should be sent.  
因此，如果有任何段到发送到一个不存在的连接时，就应该发送一个重置。

If a segment ACKs something which has never been sent on the current connection, then one of the following two cases applies.  
如果一个 TCP 段 ACK（确认）了一些从未在当前连接上发送过的东西，那么分为以下两种情况。

1.If the connection is in any non-synchronized state (LISTEN, SYN-SENT, SYN-RECEIVED) or if the connection does not exist, a reset (RST) should be formed and sent for any segment that acknowledges something not yet sent.  
1.如果连接处于任何非同步状态（LISTEN、SYN-SENT、SYN-RECEIVED），或者连接不存在时，对于任何尚未发送的确认段，应该生成重置（RST）并发送。

The RST should take its SEQ field from the ACK field of the offending segment (if the ACK control bit was set), and its ACK bit should be reset (zero), except to refuse a initial SYN.  
RST 应该从违规段的 ACK 字段中获取其 SEQ 字段（如果 ACK 标志位被设置），并且其 ACK 位应该被重置（0），除非拒绝初始 SYN。

A reset is also sent if an incoming segment has a security level or compartment which does not exactly match the level and compartment requested for the connection.  
如果一个接收段的安全级别或分区与连接要求的级别和间隔不完全匹配，也会发送一个重置。

If the precedence of the incoming segment is less than the precedence level requested a reset is sent.  
如果接收段的优先级低于要求的优先级，则发送重置。

2.If the connection is in a synchronized state (ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, TIME-WAIT, CLOSE-WAIT, CLOSING), any unacceptable segment should elicit only an empty acknowledgment segment containing the current send-sequence number and an acknowledgment indicating the next sequence number expected to be received.  
2.如果连接处于同步状态（ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、TIME-WAIT、CLOSE-WAIT、CLOSING），任何无效的 TCP 段应该只会触发一个包含当前发送序列号和一个表示预期将收到的下一个序列号的空确认段。

Reset Processing  
重置处理

All reset (RST) segments are validated by checking their SEQ-fields.  
所有的重置（RST）段都通过检查其 SEQ 字段来验证。

A reset is valid if its sequence number is in the window.  
如果重置的序列号在窗口范围中，则重置有效。

In the case of a RST received in response to an initial SYN any sequence number is acceptable if the ACK field acknowledges the SYN.  
在响应初始 SYN 而接收 RST 的情况下，如果 ACK 字段确认 SYN，则任何序列号都是有效的。

The receiver of a RST first validates it, then changes state.  
RST 的接收者首先验证它，然后改变状态。

If the receiver was in the LISTEN state, it ignores it.  
如果接收器处于 LISTEN 状态，就会忽略它。

If the receiver was in SYN-RECEIVED state and had previously been in the LISTEN state, then the receiver returns to the LISTEN state, otherwise the receiver aborts the connection and goes to the CLOSED state.  
如果接收方处于 SYN-RECEIVED 状态，并且之前处于 LISTEN 状态，那么接收方返回到 LISTEN 状态，否则接收方中止连接，进入 CLOSED 状态。

If the receiver was in any other state, it aborts the connection and advises the user and goes to the CLOSED state.  
如果接收方处于任何其它状态，它将中止连接并通知用户并进入 CLOSED 状态。

### 关闭连接

3.5. Closing a Connection

CLOSE is an operation meaning "I have no more data to send."  
CLOSE 是一个操作，意思是 "我没有更多的数据要发送"。

The notion of closing a full-duplex connection is subject to ambiguous interpretation, of course, since it may not be obvious how to treat the receiving side of the connection.  
当然，关闭全双工连接的概念会有模糊的解释，因为如何处理连接的接收方可能并不明显。

We have chosen to treat CLOSE in a simplex fashion.  
我们选择以简单的方式来处理 CLOSE。

The user who CLOSEs may continue to RECEIVE until he is told that the other side has CLOSED also.  
主动关闭的用户可以继续接收，直到他被告知另一方也关闭了。

Thus, a program could initiate several SENDs followed by a CLOSE, and then continue to RECEIVE until signaled that a RECEIVE failed because the other side has CLOSED.  
因此，一个程序可以多次发送，然后关闭，再继续接收，直到有信号说接收失败，因为对方已经关闭。

We assume that the TCP will signal a user, even if no RECEIVEs are outstanding, that the other side has closed, so the user can terminate his side gracefully.  
我们假设，即使没有未完成的接收，TCP 也会通知用户对方已经关闭，所以用户可以优雅地中止自己这端。

A TCP will reliably deliver all buffers SENT before the connection was CLOSED so a user who expects no data in return need only wait to hear the connection was CLOSED successfully to know that all his data was received at the destination TCP.  
TCP 将在连接关闭前可靠地发送的所有缓冲区的数据，因此没有数据接收的用户只需等到连接被成功关闭，就能知道他的所有数据已经成功发送到目的地 TCP。

There are essentially three cases:  
主要有三种情况：

{{< indent >}} 1) The user initiates by telling the TCP to CLOSE the connection  
{{< indent >}} 1) 用户主动告诉 TCP 关闭连接

{{< indent >}} 2) The remote TCP initiates by sending a FIN control signal  
{{< indent >}} 2) 远程 TCP 通过发送 FIN 控制标志开始关闭

{{< indent >}} 3) Both users CLOSE simultaneously  
{{< indent >}} 3) 两个用户同时关闭

Case 1: Local user initiates the close  
情况 1：本地用户发起关闭

In this case, a FIN segment can be constructed and placed on the outgoing segment queue.  
在这种情况下，会生成一个 FIN 段，并将其加入到发送段队列中。

No further SENDs from the user will be accepted by the TCP, and it enters the FIN-WAIT-1 state.  
TCP 将不再接受用户的发送，并进入 FIN-WAIT-1 状态。

RECEIVEs are allowed in this state.  
在这种状态下，允许接收

All segments preceding and including FIN will be retransmitted until acknowledged.  
在 FIN 之前和包括 FIN 在内的所有段超时将被重传，直到被确认。

When the other TCP has both acknowledged the FIN and sent a FIN of its own, the first TCP can ACK this FIN.  
当另一个 TCP 既确认了 FIN 又发送了自己的 FIN 时，第一个 TCP 可以对这个 FIN 进行 ACK。

It should be noted that a TCP receiving a FIN will ACK but not send its own FIN until its user has CLOSED the connection also.  
应该注意的是，收到 FIN 的 TCP 会进行 ACK，但不会发送自己的 FIN，直到其用户也关闭了连接。

Case 2: TCP receives a FIN from the network  
情况 2：TCP 收到来自网络的 FIN

If an unsolicited FIN arrives from the network, the receiving TCP can ACK it and tell the user that the connection is closing.  
如果来自网络的未经请求的 FIN 到达，接收的 TCP 可以确认该 FIN 并告诉用户连接正在关闭。

The user should respond with a CLOSE, upon which the TCP can send a FIN to the other TCP.  
用户应该用 CLOSE 来回应，在此基础上，TCP 可以向其他 TCP 发送 FIN。

The TCP then waits until its own FIN is acknowledged whereupon it deletes the connection.  
然后，TCP 等待，直到它自己的 FIN 被确认，然后它删除连接。

If an ACK is not forthcoming, after a timeout the connection is aborted and the user is told.  
如果没有收到 ACK，在超时后，连接将被终止，并告诉用户。

Case 3: both users close simultaneously  
情况 3：两个用户同时关闭

A simultaneous CLOSE by users at both ends of a connection causes FIN segments to be exchanged.  
连接两端的用户同时关闭会交换 FIN 段。

When all segments preceding the FINs have been processed and acknowledged, each TCP can ACK the FIN it has received.  
当 FIN 之前的所有段都被处理并确认后，每个 TCP 可以对它所收到的 FIN 进行 ACK。

Both will, upon receiving these ACKs, delete the connection.  
两者都将在收到这些 ACK 后，删除连接。

```
      TCP A                                                TCP B
  1.  ESTABLISHED                                          ESTABLISHED
  2.  (Close)
      FIN-WAIT-1  --> <SEQ=100><CTL=FIN>               --> CLOSE-WAIT
  3.  FIN-WAIT-2  <-- <SEQ=300><ACK=101><CTL=ACK>      <-- CLOSE-WAIT
  4.                                                       (Close)
      TIME-WAIT   <-- <SEQ=301><CTL=FIN>               <-- CLOSING
  5.  TIME-WAIT   --> <SEQ=100><ACK=301><CTL=ACK>      --> CLOSED
  6.  (2 MSL)
      CLOSED
```

{{< center >}}
Normal Close Sequence  
正常关闭序列

Figure 15.

{{< /center >}}

```
      TCP A                                                TCP B
  1.  ESTABLISHED                                          ESTABLISHED
  2.  (Close)                                              (Close)
      FIN-WAIT-1  --> <SEQ=100><CTL=FIN>               ... FIN-WAIT-1
                  <-- <SEQ=300><CTL=FIN>               <--
                  ... <SEQ=100><CTL=FIN>               -->
  3.  CLOSING     --> <SEQ=100><ACK=301><CTL=ACK>      ... CLOSING
                  <-- <SEQ=300><ACK=101><CTL=ACK>      <--
                  ... <SEQ=100><ACK=301><CTL=ACK>      -->
  4.  CLOSED                                               CLOSED
```

{{< center >}}
Simultaneous Close Sequence  
同时关闭序列

Figure 16.

{{< /center >}}

### 优先级和安全性

3.6. Precedence and Security

The intent is that connection be allowed only between ports operating with exactly the same security and compartment values and at the higher of the precedence level requested by the two parts.  
目的是只允许在以完全相同的安全和隔间值运行的端口之间进行连接，并且两个部分要求的优先级较高。

The precedence levels are:  
优先级有：

```
    flash override - 111
    flash          - 110
    immediate      - 10X
    priority       - 01X
    routine        - 00X
```

The security levels are:
安全等级有：

```
    top secret    - 11
    secret        - 10
    confidential  - 01
    unclassified  - 00
```

The compartments are assigned by the Defense Communications Agency.  
隔间是由国防通信局分配的。

The defaults are precedence: routine, security: unclassified, compartment: zero.  
默认优先级：routine，安全：unclassified，隔间：zero。

A host which does not implement precedence or security feature should clear these fields to zero for segments it sends.  
没有实现优先权或安全功能的主机应将其发送的 TCP 段中这些字段清除为零。

A connection attempt with mismatched security/compartment values or a lower precedence value should be rejected by sending a reset.  
通过发送重置来拒绝安全/间隔值不匹配或优先级较低的连接尝试。

Note that TCP modules which operate only at the default value of precedence will still have to check the precedence of incoming segments and possibly raise the precedence level they use on the connection.  
请注意，只在默认优先级值下运行的 TCP 模块仍然需要检查接收段的优先级，并可能提高它们在连接上使用的优先级。

### 数据通信

3.7. Data Communication

Once the connection is established data is communicated by the exchange of segments.  
一旦建立了连接，就通过交换 TCP 段来传递数据。

Because segments may be lost due to errors (checksum test failure), or network congestion, TCP uses retransmission (after a timeout) to ensure delivery of every segment.  
由于 TCP 段可能因错误（校验和测试失败）或网络拥堵而丢失，TCP 使用重传（超时后）来确保每个段的交付。

Duplicate segments may arrive due to network or TCP retransmission.  
由于网络或 TCP 重传，可能会出现重复的 TCP 段。

As discussed in the section on sequence numbers the TCP performs certain tests on the sequence and acknowledgment numbers in the segments to verify their acceptability.  
正如在序列号一节中所讨论的，TCP 对段中的序列号和确认号进行某些测试，以验证其是否有效。

The sender of data keeps track of the next sequence number to use in the variable SND.NXT.  
数据发送方在变量 SND.NXT 中记录下一个要使用的序列号。

The receiver of data keeps track of the next sequence number to expect in the variable RCV.NXT.  
数据接收方在变量 RCV.NXT 中保存下一个期望的序列号。

The sender of data keeps track of the oldest unacknowledged sequence number in the variable SND.UNA.  
数据发送方在变量 SND.UNA 中跟踪最久的未确认的序列号。

If the data flow is momentarily idle and all data sent has been acknowledged then the three variables will be equal.  
如果数据流暂时处于空闲状态，并且所有发送的数据都被确认，那么这三个变量将是相等的。

When the sender creates a segment and transmits it the sender advances SND.NXT.  
当发送方创建一个 TCP 段并发送时，发送方会推进 SND.NXT。

When the receiver accepts a segment it advances RCV.NXT and sends an acknowledgment.  
当接收方接收一个 TCP 段时，它推进 RCV.NXT 并发送一个确认。

When the data sender receives an acknowledgment it advances SND.UNA.  
当数据发送方收到确认时，它会推进 SND.UNA。

The extent to which the values of these variables differ is a measure of the delay in the communication.  
这些变量值的不同程度是衡量通信延迟的一个标准。

Normally the amount by which the variables are advanced is the length of the data in the segment.  
通常情况下，变量推进的数量是 TCP 段中数据的长度。

However, when letters are used there are special provisions for coordination the sequence numbers, the letter boundaries, and the receive buffer boundaries.

End of Letter Sequence Number Adjustments

There is provision in TCP for the receiver of data to optionally communicate to the sender of data on a connection at the time of the
connection synchronization the receiver's buffer size.

If this is done the receiver must use this fixed size of buffers for the lifetime of the connection.

If a buffer size is communicated then there is a coordination between receive buffers, letters, and sequence numbers.

Each time a buffer is completed either due to being filled or due to an end of letter, the sequence number is incremented through the end of that buffer.

That is, whenever an EOL is transmitted, the sender advances its send sequence number, SND.NXT, by an amount sufficient to consume all the unused space in the receiver's buffer.

The amount of space consumed in this fashion is subtracted from the send window just as is the space consumed by actual data.

And, whenever an EOL is received, the receiver advances its receive sequence number, RCV.NXT, by an amount sufficient to consume all the unused space in the receiver's buffer.

The amount of space consumed in this fashion is subtracted from the receive window just as is the space consumed by actual data.
