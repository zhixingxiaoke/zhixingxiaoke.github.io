---
title: RFC793 TCP 协议中文翻译
weight: 2
draft: true
# bookFlatSection: false
# bookToc: true
# bookHidden: false
# bookCollapseSection: false
# bookComments: false
# bookSearchExclude: false
---

# RFC793 TCP 协议中文翻译

这是 RFC 上比较经典关于 TCP 协议标准的文档，它优化了 RFC761 提出的 TCP 规范，并在很长一段时间内作为 TCP 标准的参考文档，如果对 RFC761 感兴趣可以参考[RFC761 TCP 协议中文翻译](../translations/rfc761)。

原文：[Transmission Control Protocol](https://datatracker.ietf.org/doc/rfc793/)

## 封面

{{< center >}}
TRANSMISSION CONTROL PROTOCOL  
TCP 协议

DARPA INTERNET PROGRAM  
DARPA 互联网项目

PROTOCOL SPECIFICATION  
协议规范

September 1981  
1981 年 9 月

prepared for

Defense Advanced Research Projects Agency  
国防高级研究计划局  
Information Processing Techniques Office  
信息处理技术办公室  
1400 Wilson Boulevard  
威尔逊大道 1400 号
Arlington, Virginia 22209  
弗吉尼亚州阿灵顿 22209

by

Information Sciences Institute  
信息科学研究所  
University of Southern California  
南加州大学  
4676 Admiralty Way  
4676 金钟路  
Marina del Rey, California 90291  
加利福尼亚州玛丽安德尔湾 90291

{{< /center >}}

## 目录

{{< center >}}
TABLE OF CONTENTS
{{< /center >}}

PREFACE 前言

1.INTRODUCTION 介绍  
{{< indent >}} 1.1 Motivation 动机  
{{< indent >}} 1.2 Scope 范围  
{{< indent >}} 1.3 About This Document 关于本文  
{{< indent >}} 1.4 Interfaces 接口  
{{< indent >}} 1.5 Operation 操作

2.PHILOSOPHY 基本原理  
{{< indent >}} 2.1 Elements of the Internetwork System 互联网系统的要素  
{{< indent >}} 2.2 Model of Operation 运作模式  
{{< indent >}} 2.3 The Host Environment 主机环境  
{{< indent >}} 2.4 Interfaces 接口  
{{< indent >}} 2.5 Relation to Other Protocols 与其他协议的关系  
{{< indent >}} 2.6 Reliable Communication 可靠的通信  
{{< indent >}} 2.7 Connection Establishment and Clearing 连接的建立和清除  
{{< indent >}} 2.8 Data Communication 数据通信  
{{< indent >}} 2.9 Precedence and Security 优先级和安全性  
{{< indent >}} 2.10 Robustness Principle 稳健性原则

3.FUNCTIONAL SPECIFICATION 功能规范  
{{< indent >}} 3.1 Header Format 头部格式  
{{< indent >}} 3.2 Terminology 术语表  
{{< indent >}} 3.3 Sequence Numbers 序列号  
{{< indent >}} 3.4 Establishing a connection 建立连接  
{{< indent >}} 3.5 Closing a Connection 关闭连接  
{{< indent >}} 3.6 Precedence and Security 优先级和安全性  
{{< indent >}} 3.7 Data Communication 数据通信  
{{< indent >}} 3.8 Interfaces 接口  
{{< indent >}} 3.9 Event Processing 事件处理

GLOSSARY 术语表

REFERENCES 参考文献

## 前言

**PREFACE**

This document describes the DoD Standard Transmission Control Protocol
(TCP).  
本文描述了美国国防部标准传输控制协议（TCP 协议）。

There have been eight earlier editions of the ARPA TCP specification on which this standard is based, and the present text draws heavily from them.  
ARPA TCP 规范已经有 9 个早期版本，本文中的 TCP 标准是基于它们，并且很多内容都是借鉴它们的。

There have been many contributors to this work both in terms of concepts and in terms of text.  
在概念和编纂方面，都有很多人对这项工作做出贡献。

This edition clarifies several details and removes the end-of-letter buffer-size adjustments, and redescribes the letter mechanism as a push function.  
此版本澄清了几个细节并删除了 end-of-letter 和 buffer-size adjustments，因为 Push 功能，重新。

{{< right >}}
Jon Postel

Editor
{{< /right >}}

## 介绍

**1.INTRODUCTION**

The Transmission Control Protocol (TCP) is intended for use as a highly reliable host-to-host protocol between hosts in packet-switched computer communication networks, and especially in interconnected systems of such networks.  
传输控制协议（TCP）旨在作为分组交换计算机通信网络中主机之间的高度可靠的主机到主机协议使用，特别是在这种网络的互连系统中。

This document describes the functions to be performed by the Transmission Control Protocol, the program that implements it, and its interface to programs or users that require its services.  
本文描述了传输控制协议（TCP）所要执行的功能、实现它的程序以及它与需要其服务的程序或用户的接口。

### 动机

**1.1. Motivation**

Computer communication systems are playing an increasingly important role in military, government, and civilian environments.  
计算机通信系统在军事、政府和民用环境中发挥越来越重要的作用。

This document primarily focuses its attention on military computer communication requirements, especially robustness in the presence of communication unreliability and availability in the presence of congestion, but many of these problems are found in the civilian and government sector as well.  
本文着重关注军用计算机通信系统的要求，尤其是通信不可靠时的健壮性和通讯拥堵时的可用性，但是这些问题大多也存在于民用和政府部门的计算机通讯系统中。

As strategic and tactical computer communication networks are developed and deployed, it is essential to provide means of interconnecting them and to provide standard interprocess communication protocols which can support a broad range of applications.  
随着战略和战术计算机通信网络的开发和部署，使它们互联并提供标准的进程间通信协议变得很有必要，这样才能够让它们能够得到广泛的应用。

In anticipation of the need for such standards, the Deputy Undersecretary of Defense for Research and Engineering has declared the Transmission Control Protocol (TCP) described herein to be a basis for DoD-wide inter-process communication protocol standardization.  
鉴于对此类标准的需求，负责研究和工程的国防部副部长宣布本文所述的传输控制协议（TCP）为美国国防部范围内进程间通信协议标准化的基础。

TCP is a connection-oriented, end-to-end reliable protocol designed to fit into a layered hierarchy of protocols which support multi-network applications.  
TCP 是一个面向连接的、端到端的可靠协议，旨在适应支持多网络应用的协议分层结构。

The TCP provides for reliable inter-process communication between pairs of processes in host computers attached to distinct but interconnected computer communication networks.  
TCP 协议为处于同一网络中，但是处于不同计算机中的两个进程提供可靠的进程间通信。

Very few assumptions are made as to the reliability of the communication protocols below the TCP layer.  
TCP 层以下的通信协议被认为是不可靠的。

TCP assumes it can obtain a simple, potentially unreliable datagram service from the lower level protocols.  
TCP 假设它可以从更低的协议中获取简单但可能是不可靠的数据包服务。

In principle, the TCP should be able to operate above a wide spectrum of communication systems ranging from hard-wired connections to packet-switched or circuit-switched networks.  
原则上，TCP 协议应该可以在从硬线连接到分组交换或电路交换网络的广泛通信系统中运行。

TCP is based on concepts first described by Cerf and Kahn in [1].  
TCP 协议基于 Cerf 和 Kahn 最先提出的概念。

The TCP fits into a layered protocol architecture just above a basic Internet Protocol [2] which provides a way for the TCP to send and receive variable-length segments of information enclosed in internet datagram "envelopes".  
TCP 协议是适用于一个分层协议结构，它在 IP 协议之上，IP 协议为 TCP 层提供了一种发送和接收可变长度的信息段的网络数据包的方式。

The internet datagram provides a means for addressing source and destination TCPs in different networks.  
网络数据包提供了一种在不同网络中寻找 TCP 源地址和目的地址的方法。

The internet protocol also deals with any fragmentation or reassembly of the TCP segments required to achieve transport and delivery through multiple networks and interconnecting gateways.  
IP 协议也处理通过多个网络和网关实现传输和交付所需的 TCP 段的任何分段或重组。

The internet protocol also carries information on the precedence, security classification and compartmentation of the TCP segments, so this information can be communicated end-to-end across multiple networks.  
IP 协议还携带关于 TCP 段的优先级、安全分类和区段的信息，因此这些信息可以在多个网络中被端到端的进行传递。

{{< center >}}
Protocol Layering  
协议分层

```
+---------------------+
|     higher-level    |
+---------------------+
|        TCP          |
+---------------------+
|  internet protocol  |
+---------------------+
|communication network|
+---------------------+
```

Figure 1

{{< /center >}}

Much of this document is written in the context of TCP implementations which are co-resident with higher level protocols in the host computer.  
本文的大部分内容是在 TCP 实现的背景下编写的，这些实现与主机中更高级别的协议共存。

Some computer systems will be connected to networks via front-end computers which house the TCP and internet protocol layers, as well as network specific software.
有些计算机系统将会通过包含 TCP 和 IP 协议层以及网络软件的前置机连接到网络。

The TCP specification describes an interface to the higher level protocols which appears to be implementable even for the front-end case, as long as a suitable host-to-front end protocol is implemented.  
TCP 规范描述了一个到更高层协议的接口，只要实现了合适的主机到前端的协议，即使对于前端情况，该接口似乎也是可实现的。

### 范围

**1.2. Scope**

The TCP is intended to provide a reliable process-to-process communication service in a multinetwork environment.  
TCP 旨在在多网络环境中提供可靠的进程到进程通信服务。

The TCP is intended to be a host-to-host protocol in common use in multiple networks.  
TCP 旨在成为多网络环境中常用的主机到主机协议。

### 关于本文

**1.3. About this Document**

This document represents a specification of the behavior required of any TCP implementation, both in its interactions with higher level protocols and in its interactions with other TCPs.  
本文描述了所有 TCP 实现所需的行为规范，无论是与其它更高级的协议交互还是与其它 TCP 的交互。

The rest of this section offers a very brief view of the protocol interfaces and operation.  
本节的其余部分非常简要地介绍了协议接口和操作。

Section 2 summarizes the philosophical basis for the TCP design.  
第 2 节概述了 TCP 设计的哲学基础。

Section 3 offers both a detailed description of the actions required of TCP when various events occur (arrival of new segments, user calls, errors, etc.) and the details of the formats of TCP segments.  
第 3 节详细描述了当各种事件发生时（新段的到来、用户呼叫、错误等）TCP 所需的行动，以及 TCP 段格式的细节。

### 接口

**1.4. Interfaces**

The TCP interfaces on one side to user or application processes and on the other side to a lower level protocol such as Internet Protocol.  
TCP 一端连接到用户或应用程序进程，另一端连接到较低级别的协议，比如 IP 协议。

The interface between an application process and the TCP is illustrated in reasonable detail.  
相当详细地说明了应用程序进程和 TCP 之间的接口。

This interface consists of a set of calls much like the calls an operating system provides to an application process for manipulating files.  
这个接口由一组调用组成，很像操作系统为操作文件的应用进程提供的调用。

For example, there are calls to open and close connections and to send and receive letters on established connections.  
例如，有调用打开和关闭连接，以及在已建立的连接上发送和接收数据。

It is also expected that the TCP can asynchronously communicate with application programs.  
还期望 TCP 能够与应用程序进行异步通信。

Although considerable freedom is permitted to TCP implementors to design interfaces which are appropriate to a particular operating system environment, a minimum functionality is required at the TCP/user interface for any valid implementation.  
尽管允许 TCP 实现者有相当大的自由来设计适合特定操作系统环境的接口，但对于任何有效的实现，TCP/user 接口都需要最少的功能。

The interface between TCP and lower level protocol is essentially unspecified except that it is assumed there is a mechanism whereby the two levels can asynchronously pass information to each other.  
除了假设两个级别可以相互异步传递信息的机制之外，基本上没有指定 TCP 和较低级别协议之间的接口。

Typically, one expects the lower level protocol to specify this interface.  
通常情况下，是由低级别的协议指定这个接口。

TCP is designed to work in a very general environment of interconnected networks.  
TCP 被设计为可以在互连网络的非常普遍的环境中工作。

The lower level protocol which is assumed throughout this document is the Internet Protocol [2].  
本文中假定的较低级别协议是 IP 协议。

### 操作

**1.5. Operation**

As noted above, the primary purpose of the TCP is to provide reliable, securable logical circuit or connection service between pairs of processes.  
如上所述，TCP 的主要目的是在进程对之间提供可靠、安全的逻辑线路或连接服务。

To provide this service on top of a less reliable internet communication system requires facilities in the following areas:  
要在不太可靠的互联网通信系统之上提供这种服务，需要在以下方面的设施：

- Basic Data Transfer 基础数据传输
- Reliability 可靠性
- Flow Control 流量控制
- Multiplexing 多路复用
- Connections 连接
- Precedence and Security 优先级和安全性

The basic operation of the TCP in each of these areas is described in the following paragraphs.  
以下段落描述了 TCP 在每个方面的基本操作。

**Basic Data Transfer:**  
**基础数据传输**

The TCP is able to transfer a continuous stream of octets in each direction between its users by packaging some number of octets into segments for transmission through the internet system.  
TCP 能够在其用户之间的每个方向传输连续的字节流，将一些字节数据打包成段，通过互联网传输。

In general, the TCPs decide when to block and forward data at their own convenience.  
一般情况下，TCP 根据自己的情况来决定阻止和转发数据。

Sometimes users need to be sure that all the data they have submitted to the TCP has been transmitted.  
有时，用户需要确定他们提交给 TCP 的所有数据都已传输。

For this purpose a push function is defined.  
为此，定义了推送功能。

To assure that data submitted to a TCP is actually transmitted the sending user indicates that it should be pushed through to the receiving user.  
为了确保提交给 TCP 的数据确实被传输，发送用户表明应该将其推送到接收用户。

A push causes the TCPs to promptly forward and deliver data up to that point to the receiver.  
推送会使 TCP 迅速转发并将该点之前的数据传递给接收方。

The exact push point might not be visible to the receiving user and the push function does not supply a record boundary marker.  
确切的推送点对接收用户来说可能不可见，而且推送功能也不提供记录的边界标记。

**Reliability:**  
**可靠性**

The TCP must recover from data that is damaged, lost, duplicated, or delivered out of order by the internet communication system.  
TCP 必须从因特网通信系统损坏、丢失、复制或乱序传送的数据中恢复。

This is achieved by assigning a sequence number to each octet transmitted, and requiring a positive acknowledgment (ACK) from the
receiving TCP.  
这是通过给传输的每个字节分配一个序列号，并要求接收的 TCP 回复一个确认（ACK）来实现的。

If the ACK is not received within a timeout interval, the data is retransmitted.  
如果在规定的时间隔内没有收到 ACK，则重传数据。

At the receiver, the sequence numbers are used to correctly order segments that may be received out of order and to eliminate duplicates.  
在接收方，序列号用来按顺序排列可能接收到的乱序的片段，并消除重复的片段。

Damage is handled by adding a checksum to each segment transmitted, checking it at the receiver, and discarding damaged segments.  
通过在传输的每个片段上添加一个校验和，在接收方进行检查，并丢弃损坏的片段。

As long as the TCPs continue to function properly and the internet system does not become completely partitioned, no transmission errors will affect the users.  
只要 TCP 各端继续正常运行，网络系统也没有断开，传输错误就不会影响到用户。

TCP recovers from internet communication system errors.  
TCP 从互联网通信错误中恢复。

**Flow Control:**  
**流量控制**

TCP provides a means for the receiver to govern the amount of data sent by the sender.  
TCP 为接收方提供了一种方法来管理发送方发送的数据量。

This is achieved by returning a "window" with every ACK indicating a range of acceptable sequence numbers beyond the last segment successfully received.  
这是通过在每个 ACK 中返回一个 "窗口" 来实现的，窗口表示在成功接收的最后一个片段之外的可接受的序列号范围。

The window indicates an allowed number of octets that the sender may transmit before receiving further permission.  
该窗口表示发送方在收到进一步确认之前可以传输的字节数量。

**Multiplexing:**  
**多路复用**

To allow for many processes within a single Host to use TCP communication facilities simultaneously, the TCP provides a set of addresses or ports within each host.  
为了允许单个主机内的多个进程同时使用 TCP 进行通信，TCP 在每个主机内提供了一组地址或端口。

Concatenated with the network and host addresses from the internet communication layer, this forms a socket.  
从互联网通信层连接网络和主机地址，形成一个套接字。

A pair of sockets uniquely identifies each connection.  
一对套接字唯一标识每个连接。

That is, a socket may be simultaneously used in multiple connections.  
也就是说，一个套接字可以同时在多个连接中使用。

The binding of ports to processes is handled independently by each Host.  
每个主机单独处理端口与进程的绑定。

However, it proves useful to attach frequently used processes (e.g., a "logger" or timesharing service) to fixed sockets which are made known to the public.  
然而，事实证明，将常用的进程（例如，"logger"或 timesharing 服务）附加到固定的套接字上会很有用。

These services can then be accessed through the known addresses. Establishing and learning the port addresses of other processes may involve more dynamic mechanisms.  
通过已知地址就可以访问这些服务，建立和学习其他进程的端口地址可能涉及更多的动态机制。

Connections:  
连接

The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream.  
上述的可靠性和流量控制机制要求 TCP 初始化和维护每个数据流的某些状态信息。

The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.  
这些信息（包括套接字、序列号和窗口大小）的组合称为连接。

Each connection is uniquely specified by a pair of sockets identifying its two sides.  
每个连接都由标识其两端的一对套接字唯一指定。

When two processes wish to communicate, their TCP's must first establish a connection (initialize the status information on each side).  
当两个进程想要进行通信时，它们必须先建立 TCP 连接（初始化每一端的状态信息）。

When their communication is complete, the connection is terminated or closed to free the resources for other uses.  
当他们的通信完成后，连接被终止或关闭，以释放资源用于其他用途。

Since connections must be established between unreliable hosts and over the unreliable internet communication system, a handshake mechanism with clock-based sequence numbers is used to avoid erroneous initialization of connections.  
由于必须在不可靠的主机之间和通过不可靠的互联网通信系统建立连接，因此使用了基于时钟序列号的握手机制，以避免连接的错误初始化。

**Precedence and Security:**  
**优先级和安全性**

The users of TCP may indicate the security and precedence of their communication.  
TCP 的用户可以指定其通信的安全性和优先级。

Provision is made for default values to be used when these features are not needed.  
规定在不需要这些功能时，会使用默认值。

## 基本原理

**2.PHILOSOPHY**

### 互联网系统的要素

**2.1. Elements of the Internetwork System**

The internetwork environment consists of hosts connected to networks which are in turn interconnected via gateways.  
互联网络环境由连接到网络的主机组成，这些网络又通过网关互连。

It is assumed here that the networks may be either local networks (e.g., the ETHERNET) or large networks (e.g., the ARPANET), but in any case are based on packet switching technology.  
这里假设网络可以是本地网络（如 ETHERNET）或大型网络（如 ARPANET），但在任何情况下都是基于分组交换技术。

The active agents that produce and consume messages are processes.  
进程是产生和消费消息的活跃元素。

Various levels of protocols in the networks, the gateways, and the hosts support an interprocess communication system that provides two-way data flow on logical connections between process ports.  
网络、网关和主机中的各种级别的协议支持进程间通信系统，该系统在进程端口之间的逻辑连接上提供双向数据流。

The term packet is used generically here to mean the data of one transaction between a host and a packet switch.  
术语 "数据包" 在这里泛指主机和数据包交换机之间的一次事务处理数据。

The format of data blocks exchanged between the packet switches in a network will generally not be of concern to us.  
我们通常不会关心网络中分组交换机之间交换的数据块的格式。

Hosts are computers attached to a network, and from the communication network's point of view, are the sources and destinations of packets.  
主机是连接到网络的计算机，从通信网络的角度来看，主机是数据包的来源和目的地。

Processes are viewed as the active elements in host computers (in accordance with the fairly common definition of a process as a program in execution).  
进程被看作是主机中的活跃元素（根据相当普遍的定义，进程是一个正在执行的程序）。

Even terminals and files or other I/O devices are viewed as communicating with each other through the use of processes.  
甚至终端和文件或其他 I/O 设备也被看作是通过使用进程来相互通信的。

Thus, all communication is viewed as inter-process communication.  
因此，所有的通信都被看作是进程间的通信。

Since a process may need to distinguish among several communication streams between itself and another process (or processes), we imagine that each process may have a number of ports through which it communicates with the ports of other processes.  
因为一个进程可能需要区分它和另一个进程(或多个进程)之间的几个通信流，所以我们假设每个进程可能有许多端口，它通过这些端口与其他进程的端口进行通信。

### 运作模式

**2.2. Model of Operation**

Processes transmit data by calling on the TCP and passing buffers of data as arguments.  
进程通过调用 TCP 并将数据缓冲区作为参数来传输数据。

The TCP packages the data from these buffers into segments and calls on the internet module to transmit each segment to the destination TCP.  
TCP 将这些缓冲区中的数据打包成 TCP 段，并调用网络模块将每个 TCP 段传输到目的主机的 TCP。

The receiving TCP places the data from a segment into the receiving user's buffer and notifies the receiving user.  
接收 TCP 将 TCP 段中的数据放入接收用户的缓冲区，并通知接收用户。

The TCPs include control information in the segments which they use to ensure reliable ordered data transmission.  
TCP 把控制信息放在 TCP 段中，它们用于确保可靠有序的数据传输。

The model of internet communication is that there is an internet protocol module associated with each TCP which provides an interface to the local network.  
互联网通信的模型是有一个互联网协议模块与每个 TCP 相关联，它提供到本地网络的接口。

This internet module packages TCP segments inside internet datagrams and routes these datagrams to a destination internet module or intermediate gateway.  
这个互联网模块将 TCP 段封装在网络数据报中，并将这些数据报路由到目标互联网模块或中间网关。

To transmit the datagram through the local network, it is embedded in a local network packet.  
为了通过本地网络传输数据报，它被嵌入到本地网络数据包中。

The packet switches may perform further packaging, fragmentation, or other operations to achieve the delivery of the local packet to the destination internet module.  
分组交换机可以执行进一步的打包、分段或其他操作，以实现将本地数据包发送到目的地互联网模块。

At a gateway between networks, the internet datagram is "unwrapped" from its local packet and examined to determine through which network the internet datagram should travel next.  
在网关时，网络数据报从其本地数据包中 "解包" 并进行检查并决定该网络数据报接下来应通过哪个网络传输。

The internet datagram is then "wrapped" in a local packet suitable to the next network and routed to the next gateway, or to the final destination.  
然后，网络数据报在适合于下一个网络的本地数据包中被 "包装" ，并被路由到下一个网关或最终目的地。

A gateway is permitted to break up an internet datagram into smaller internet datagram fragments if this is necessary for transmission through the next network.  
如果有必要的话，允许网关将网络数据报分解成更小的网络数据报片段，再传输到下一个网络。

To do this, the gateway produces a set of internet datagrams; each carrying a fragment.  
为此，网关生成一组网络数据报；每个数据包携带一个片段。

Fragments may be broken into smaller ones at intermediate gateways.  
数据包片段可以在中间网关处分解成更小的片段。

The internet datagram fragment format is designed so that the destination internet module can reassemble fragments into internet datagrams.  
网络数据报片段格式的设计使得目的地的互联网模块可以将片段重组为网络数据报。

A destination internet module unwraps the segment from the datagram (after reassembling the datagram, if necessary) and passes it to the destination TCP.  
目的地互联网模块从数据报中解开 TCP 段(如果需要，在重组数据报之后)，并将其传递给 TCP。

This simple model of the operation glosses over many details.  
这个简单的运作模式掩盖了许多细节。

One important feature is the type of service.  
一个重要的特征是服务的类型。

This provides information to the gateway (or internet module) to guide it in selecting the service parameters to be used in traversing the next network.  
这为网关（或互联网模块）提供了信息，指导它选择遍历下一个网络时使用的服务参数。

Included in the type of service information is the precedence of the datagram.  
服务类型信息中包括数据报的优先级。

Datagrams may also carry security information to permit host and gateways that operate in multilevel secure environments to properly segregate datagrams for security considerations.  
数据报还可以携带安全信息，使得在多级安全环境中操作的主机和网关出于安全考虑可以适当地分离数据报。

### 主机环境

**2.3. The Host Environment**

The TCP is assumed to be a module in a time sharing operating system.  
假定 TCP 是分时操作系统中的一个模块。

The users access the TCP much like they would access the file system.  
用户访问 TCP 就像他们访问文件系统一样。

The TCP may call on other operating system functions, for example, to manage data structures.  
TCP 可以调用其他操作系统的功能，例如，管理数据结构。

The actual interface to the network is assumed to be controlled by a device driver module.  
假设到网络的实际接口由设备驱动模块控制。

The TCP does not call on the network device driver directly, but rather calls on the internet datagram protocol module which may in turn call on the device driver.  
TCP 不直接调用网络设备驱动程序，而是调用网络数据报协议模块，而后者又可能调用设备驱动程序。

The mechanisms of TCP do not preclude implementation of the TCP in a front-end processor.  
TCP 的机制并不排除在前端处理器中实现 TCP。

However, in such an implementation, a host-to-front-end protocol must provide the functionality to support the type of TCP-user interface described in this document.
然而，在这样的实现中，主机到前端协议必须提供支持本文描述的 TCP-用户接口类型的功能。

### 接口

**2.4. Interfaces**

The TCP/user interface provides for calls made by the user on the TCP to OPEN or CLOSE a connection, to SEND or RECEIVE data, or to obtain STATUS about a connection.  
TCP/用户接口提供了用户控制 TCP 的调用，用来打开或关闭连接、发送或接收数据或获取有关连接的状态。

These calls are like other calls from user programs on the operating system, for example, the calls to open, read from, and close a file.  
这些调用类似于操作系统上用户程序的其他调用，例如打开、读取和关闭文件的调用。

The TCP/internet interface provides calls to send and receive datagrams addressed to TCP modules in hosts anywhere in the internet system.  
TCP/互联网接口提供了调用，用来发送和接收寻址到互联网系统中任何地方的主机中的 TCP 模块的数据报。

These calls have parameters for passing the address, type of service, precedence, security, and other control information.  
这些调用有参数用于传递地址、服务类型、优先级、安全性和其他控制信息。

### 与其他协议的关系

**2.5. Relation to Other Protocols**

The following diagram illustrates the place of the TCP in the protocol hierarchy:  
下图说明了 TCP 在协议层次结构中的位置

```
       +------+ +-----+ +-----+       +-----+
       |Telnet| | FTP | |Voice|  ...  |     |  Application Level
       +------+ +-----+ +-----+       +-----+
             |   |         |             |
            +-----+     +-----+       +-----+
            | TCP |     | RTP |  ...  |     |  Host Level
            +-----+     +-----+       +-----+
               |           |             |
            +-------------------------------+
            |    Internet Protocol & ICMP   |  Gateway Level
            +-------------------------------+
                           |
              +---------------------------+
              |   Local Network Protocol  |    Network Level
              +---------------------------+

```

{{< center >}}
Protocol Relationships  
协议关系

Figure 2
{{< /center >}}

It is expected that the TCP will be able to support higher level protocols efficiently.  
预计 TCP 将能够有效地支持更高级别的协议。

It should be easy to interface higher level protocols like the ARPANET Telnet [3] or AUTODIN II THP to the TCP.  
应该很容易将更高层次的协议如 ARPANET Telnet[3]或 AUTODIN II THP 连接到 TCP。

### 可靠的通信

**2.6. Reliable Communication**

A stream of data sent on a TCP connection is delivered reliably and in order at the destination.  
通过 TCP 连接上发送的数据流在目的地可靠且有序地传送。

Transmission is made reliable via the use of sequence numbers and acknowledgments.  
通过使用序列号和确认机制，使得传输变得可靠。

Conceptually, each octet of data is assigned a sequence number.  
从概念上讲，每个字节的数据都分配有一个序列号。

The sequence number of the first octet of data in a segment is the sequence number transmitted with that segment and is called the segment sequence number.  
TCP 段中数据的第一个字节的序号是与该 TCP 段一起传输的序列号，称为 segment sequence number。

Segments also carry an acknowledgment number which is the sequence number of the next expected data octet of transmissions in the reverse direction.  
TCP 段还携带一个确认号码，这是期望对方传输的下一个字节数据包的序列号。

When the TCP transmits a segment, it puts a copy on a retransmission queue and starts a timer; when the acknowledgment for that data is received, the segment is deleted from the queue.  
当 TCP 传输一个 TCP 段时，它会将 TCP 段的一个副本放在重传队列中，并启动一个计时器；当收到该数据的确认时，则将该 TCP 段将从重传队列中删除。

If the acknowledgment is not received before the timer runs out, the segment is retransmitted.  
如果在定时器结束之前没有收到确认，则重传该 TCP 段。

An acknowledgment by TCP does not guarantee that the data has been delivered to the end user, but only that the receiving TCP has taken the responsibility to do so.  
TCP 的确认并不保证数据已经交付给最终用户，而只是表明接收的 TCP 已经接收了这份数据。

To govern the flow of data into a TCP, a flow control mechanism is employed.  
为了管理进入 TCP 的数据流，采用了流量控制机制。

The the data receiving TCP reports a "window" to the sending TCP.  
数据接收 TCP 向发送 TCP 报告一个窗口。

This window specifies the number of octets, starting with the acknowledgment number that the data receiving TCP is currently prepared to receive.  
该窗口指定字节的数量，从数据接收的 TCP 目前准备接收的确认号码开始。

### 连接的建立和清除

**2.7. Connection Establishment and Clearing**

To identify the separate data streams that a TCP may handle, the TCP provides a port identifier.  
为了识别 TCP 可以处理的单独数据流，TCP 提供了端口标识符。

Since port identifiers are selected independently by each operating system, TCP, or user, they might not be unique.  
由于端口标识符是由每个操作系统、TCP 或用户独立选择的，它们可能不是唯一的。

To provide for unique addresses at each TCP, we concatenate an internet address identifying the TCP with a port identifier to create a socket which will be unique throughout all networks connected together.  
为了给每个 TCP 提供唯一的地址，我们将识别 TCP 的网络地址与端口标识符连接起来，以创建一个套接字，该套接字在所有连接在一起的网络中是唯一的。

A connection is fully specified by the pair of sockets at the ends.  
一个连接完全由两端的一对套接字指定。

A local socket may participate in many connections to different foreign sockets.  
一个本地套接字可以参与许多与不同的外部套接字的连接。

A connection can be used to carry data in both directions, that is, it is "full duplex".  
一个连接可以用来双向传输数据，也就是说，它是 "全双工"。

TCPs are free to associate ports with processes however they choose.  
TCP 可以自由地将端口与进程联系起来，不管他们如何选择。

However, several basic concepts seem necessary in any implementation.  
然而，在任何实现中，有几个基本概念几乎都是必须的。

There must be well-known sockets which the TCP associates only with the "appropriate" processes by some means.  
有一些有名的套接字，TCP 通过某种方式将其与 "适当" 的进程联系起来。

We envision that processes may "own" ports, and that processes can only initiate connections on the ports they own.  
我们设想进程可以 "拥有" 端口，而且这些进程只能在它们拥有的端口上发起连接。

(Means for implementing ownership is a local issue, but we envision a Request Port user command, or a method of uniquely allocating a group of ports to a given process, e.g., by associating the high order bits of a port name with a given process.)  
实现所有权的方法是一个局部问题，但是我们设想了一个请求端口的用户命令，或者一个将一组端口唯一地分配给一个给定进程的方法，例如，通过将端口名称的高位 bit 与一个给定进程联系起来。

A connection is specified in the OPEN call by the local port and foreign socket arguments.  
在 OPEN 调用中，通过本地端口和外部套接字参数指定一个连接。

In return, the TCP supplies a (short) local connection name by which the user refers to the connection in subsequent calls.  
TCP 提供了一个（简短的）本地连接名称作为返回，用户在后续的调用中用这个名称来指代连接。

There are several things that must be remembered about a connection.  
关于连接，必须记住几件事。

To store this information we imagine that there is a data structure called a Transmission Control Block (TCB).  
为了存储这些信息，我们设想有一个叫做传输控制块（TCB）的数据结构。

One implementation strategy would have the local connection name be a pointer to the TCB for this connection.  
一种实现策略是将本地连接名称作为指向该连接的 TCB 的指针。

The OPEN call also specifies whether the connection establishment is to be actively pursued, or to be passively waited for.  
OPEN 调用还指定是主动连接建立，还是被动等待建立连接。

A passive OPEN request means that the process wants to accept incoming connection requests rather than attempting to initiate a connection.  
被动 OPEN 请求意味着进程想要接受进来的连接请求，而不是尝试启动连接。

Often the process requesting a passive OPEN will accept a connection request from any caller.  
被动 OPEN 的进程通常会接受来自任何调用者的连接请求。

In this case a foreign socket of all zeros is used to denote an unspecified socket.  
在这种情况下，使用全 0 的外部套接字来表示未指定的套接字。

Unspecified foreign sockets are allowed only on passive OPENs.  
未指定的外部套接字只允许在被动 OPEN 中使用。

A service process that wished to provide services for unknown other processes could issue a passive OPEN request with an unspecified foreign socket.  
想要为未知的其他进程提供服务的服务进程可以使用未指定的外部套接字发起被动 OPEN 请求。

Then a connection could be made with any process that requested a connection to this local socket.  
然后就可以与请求连接到此本地套接字的任何进程建立连接。

It would help if this local socket were known to be associated with this service.  
如果已知这个本地套接字与此服务相关联，将会非常有用。

Well-known sockets are a convenient mechanism for a priori associating a socket address with a standard service.  
well-known sockets 是一种便利的机制，可以先验地将套接字地址与标准服务联系起来。

For instance, the "Telnet-Server" process might be permanently assigned to a particular socket, and other sockets might be reserved for File Transfer, Remote Job Entry, Text Generator, Echoer, and Sink processes (the last three being for test purposes).  
例如，"Telnet-Server" 进程可能被永久分配给一个特定的套接字，而其他套接字可能被保留用于文件传输、远程作业输入、文本生成器、回声器和接收器进程（最后三个用于测试目的）。

A socket address might be reserved for access to a "Look-Up" service which would return the specific socket at which a newly created service would be provided.  
可以为访问 "查找" 服务保留套接字地址，该服务可以返回新创建服务的特定套接字。

The concept of a well-known socket is part of the TCP specification, but the assignment of sockets to services is outside this specification. (See [4].)
well-known socket 的概念是 TCP 规范的一部分，但将套接字分配给服务超出了该规范。(查看[4]。)

Processes can issue passive OPENs and wait for matching calls from other processes and be informed by the TCP when connections have been established.  
进程可以发起被动的 OPEN，等待来自其他进程的相应调用，并在连接建立后由 TCP 通知。

Two processes which issue calls to each other at the same time are correctly connected.  
两个在同一时间相互发出调用的进程可以正确建立连接。

This flexibility is critical for the support of distributed computing in which components act asynchronously with respect to each other.  
这种灵活性对于支持分布式计算至关重要，在分布式计算中，组件彼此异步地工作。

There are two principal cases for matching the sockets in the local passive OPENs and an foreign active OPENs.  
匹配本地被动 OPEN 和外部主动 OPEN 中的套接字有两种主要情况。

In the first case, the local passive OPENs has fully specified the foreign socket.  
在第一种情况下，本地被动 OPEN 已经明确指定了外部套接字。

In this case, the match must be exact.  
在这种情况下，匹配是精确的。

In the second case, the local passive OPENs has left the foreign socket unspecified.  
在第二种情况下，本地被动 OPEN 未指定外部套接字。

In this case, any foreign socket is acceptable as long as the local sockets match.  
在这种情况下，只要本地套接字匹配，任何外来套接字都是可以接受的。

Other possibilities include partially restricted matches.  
其他可能包括部分受限匹配。

If there are several pending passive OPENs (recorded in TCBs) with the same local socket, an foreign active OPEN will be matched to a TCB with the specific foreign socket in the foreign active OPEN, if such a TCB exists, before selecting a TCB with an unspecified foreign socket.  
如果有多个等待中的被动 OPEN（记录在 TCB 中）具有相同的本地套接字，则在选择具有未指定的外部套接字的 TCB 之前，外部活动 OPEN 将与拥有其特定外部套接字的 TCB 匹配（如果存在这样的 TCB）。

The procedures to establish connections utilize the synchronize (SYN) control flag and involves an exchange of three messages.  
建立连接的过程使用同步 (SYN) 控制标志并涉及三个消息的交换。

This exchange has been termed a three-way hand shake [3].  
这种交换被称为三次握手。

A connection is initiated by the rendezvous of an arriving segment containing a SYN and a waiting TCB entry created by a user OPEN command.  
通过包含 SYN 的到达段和一个由用户 OPEN 命令创建的等待的 TCB 条目的会合而发起连接。

The matching of local and foreign sockets determines when a connection has been initiated.  
本地套接字和外部套接字的匹配决定了连接何时开始。

The connection becomes "established" when sequence numbers have been synchronized in both directions.  
当序列号在连接双向同步时，连接就建立了。

The clearing of a connection also involves the exchange of segments, in this case carrying the FIN control flag.  
连接的清除也涉及到段的交换，在这种情况下，带有 FIN 控制标志。

## 数据通信

**2.8. Data Communication**

The data that flows on a connection may be thought of as a stream of octets.  
在一个连接上流动的数据可以被认为是一个字节流。

The sending user indicates in each SEND call whether the data in that call (and any preceeding calls) should be immediately pushed through to the receiving user by the setting of the PUSH flag.  
发送用户在每个 SEND 调用中指示是否应通过设置 PUSH 标志立即将该调用（以及任何先前的调用）中的数据推送给接收用户。

A sending TCP is allowed to collect data from the sending user and to send that data in segments at its own convenience, until the push function is signaled, then it must send all unsent data.
发送 TCP 可以从发送用户那里收集数据，并在自己合适的时候分片发送这些数据，在发出 PUSH 的信号时，它必须发送所有未发送的数据。

When a receiving TCP sees the PUSH flag, it must not wait for more data from the sending TCP before passing the data to the receiving process.  
当接收 TCP 看到 PUSH 标志时，在将数据传递给接收进程之前，它不能等待来自发送 TCP 的更多数据。

There is no necessary relationship between push functions and segment boundaries.  
推送功能和段边界之间没有必然联系。

The data in any particular segment may be the result of a single SEND call, in whole or part, or of multiple SEND calls.  
任何特定段中的数据可能是单个 SEND 调用（全部或部分）或多个 SEND 调用的结果。

The purpose of push function and the PUSH flag is to push data through from the sending user to the receiving user.  
推送功能和 PUSH 标志的目的是将数据从发送用户推送到接收用户。

It does not provide a record service.  
它不提供记录服务。

There is a coupling between the push function and the use of buffers of data that cross the TCP/user interface.  
推送功能与跨 TCP/用户接口的数据缓冲区的使用之间存在耦合。

Each time a PUSH flag is associated with data placed into the receiving user's buffer, the buffer is returned to the user for processing even if the buffer is not filled.  
每次 PUSH 标志与放入接收用户缓冲区的数据相关联时，即使缓冲区没有被填满，也会返回给用户进行处理。

If data arrives that fills the user's buffer before a PUSH is seen, the data is passed to the user in buffer size units.  
如果在收到 PUSH 之前到达的数据填满了用户的缓冲区，则数据将以缓冲区大小为单位传递给用户。

TCP also provides a means to communicate to the receiver of data that at some point further along in the data stream than the receiver is currently reading there is urgent data.  
TCP 还提供了一种方法来向数据的接收者传达，在数据流更远的地方中有比目前读取更紧急数据。

TCP does not attempt to define what the user specifically does upon being notified of pending urgent data, but the general notion is that the receiving process should take action to read through the end urgent data quickly.  
TCP 并不试图定义用户在收到待处理紧急数据的通知后具体做什么，但一般的情况是，接收进程应该采取行动，尽快读完最后的紧急数据。

### 优先级和安全性

**2.9. Precedence and Security**

The TCP makes use of the internet protocol type of service field and security option to provide precedence and security on a per connection basis to TCP users.
TCP 利用 IP 协议的服务类型字段和安全选项，在每个连接的基础上向 TCP 用户提供优先权和安全性。

Not all TCP modules will necessarily function in a multilevel secure environment, some may be limited to unclassified use only, and others may operate at only one security level and compartment.  
并非所有 TCP 模块都必须在多级安全环境中运行，有些模块可能仅限于公开使用，而其他模块可能仅在一个安全级别和区段中运行。

Consequently, some TCP implementations and services to users may be limited to a subset of the multilevel secure case.  
因此，某些 TCP 实现和对用户的服务可能仅限于多级安全情况的一个子集。

TCP modules which operate in a multilevel secure environment should properly mark outgoing segments with the security, compartment, and precedence.  
在多级安全环境中运行的 TCP 模块应正确标记传出 TCP 段的安全性、分区和优先级。

Such TCP modules should also provide to their users or higher level protocols such as Telnet or THP an interface to allow them to specify the desired security level, compartment, and precedence of connections.  
这样的 TCP 模块还应该为它们的用户或者更高层次的协议，例如 Telnet 或者 THP 提供一个接口，以便让它们指定所需的连接的安全级别、区段和优先级。

### 稳健性原则

**2.10. Robustness Principle**

TCP implementations should follow a general principle of robustness: be conservative in what you do, be liberal in what you accept from others.  
TCP 实现应该遵循一个一般的稳健性原则：在你做的事情上要保守，在你接受别人的事情上要自由。

## 功能规范

**3.FUNCTIONAL SPECIFICATION**

### 头部格式

**3.1. Header Format**

TCP segments are sent as internet datagrams. The Internet Protocol header carries several information fields, including the source and destination host addresses [2].  
TCP 段以互联网数据报的形式发送。IP 协议报头携带多个信息字段，包括源主机地址和目的主机地址。

A TCP header follows the internet header, supplying information specific to the TCP protocol. This ivision allows for the existence of host level protocols other than TCP.  
TCP 头部 在 IP 协议头部后面，提供 TCP 协议特定的信息。这种划分允许存在除 TCP 以外的主机级协议。

{{< center >}}
TCP Header Format  
TCP 头部格式

```
0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |          Source Port          |       Destination Port        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                        Sequence Number                        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                    Acknowledgment Number                      |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |  Data |           |U|A|P|R|S|F|                               |
  | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
  |       |           |G|K|H|T|N|N|                               |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |           Checksum            |         Urgent Pointer        |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                    Options                    |    Padding    |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                             data                              |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

Note that one tick mark represents one bit position.  
注意：一个刻度线代表一个比特位。

Figure 3.

{{< /center >}}

**Source Port**: 16 bits  
{{< indent >}} The source port number.  
{{< indent >}} 源端口号

**Destination Port**: 16 bits  
{{< indent >}} The destination port number.  
{{< indent >}} 目标端口号

**Sequence Number**: 32 bits  
{{< indent >}} The sequence number of the first data octet in this segment (except when SYN is present).  
{{< indent >}} 该段数据中第一个字节的序列号（有 SYN 标志除外）。  
{{< indent >}} If SYN is present the sequence number is the initial sequence number (ISN) and the first data octet is ISN+1.  
{{< indent >}} 如果存在 SYN，则序列号是初始序列号 (ISN)，第一个字节数据是 ISN+1。

**Acknowledgment Number**: 32 bits  
{{< indent >}} If the ACK control bit is set this field contains the value of the next sequence number the sender of the segment is expecting to receive. Once a connection is established this is always sent.  
{{< indent >}} 如果有 ACK 标志，这个字段表示发送者期望收到的下一个序列号的值。一旦建立了连接，一直会发送这个字段。

**Data Offset**: 4 bits  
{{< indent >}} The number of 32 bit words in the TCP Header. This indicates where the data begins. The TCP header (even one including options) is an integral number of 32 bits long.  
{{< indent >}} 这个数表示 TCP 头部的长度有多少个 32 bit，表示真正数据开始的位置。TCP 头部（即使包括选项部分）的长度是 32 bit 的整数倍。

**Reserved**: 6 bits  
{{< indent >}} Reserved for future use. Must be zero.  
{{< indent >}} 保留将来使用，全部为 0。

**Control Bits**: 8 bits (from left to right):  
{{< indent >}} URG: Urgent Pointer field significant 紧急标志  
{{< indent >}} ACK: Acknowledgment field significant 确认标志  
{{< indent >}} PSH: Push Function 推送标志  
{{< indent >}} RST: Reset the connection 重置标志  
{{< indent >}} SYN: Synchronize sequence numbers 同步标志  
{{< indent >}} FIN: No more data from sender 断开连接标志

**Window**: 16 bits  
{{< indent >}} The number of data octets beginning with the one indicated in the acknowledgment field which the sender of this segment is willing to accept.  
{{< indent >}} 从确认序号开始，发送方可以接收的字节数。

**Checksum**: 16 bits  
{{< indent >}} The checksum field is the 16 bit one's complement of the one's complement sum of all 16 bit words in the header and text.  
{{< indent >}} 检验和是头部和数据部分所有分割成 16 bit 数的经过二进制反码求和得到的数。  
{{< indent >}} If a segment contains an odd number of header and text octets to be checksummed, the last octet is padded on the right with zeros to form a 16 bit word for checksum purposes.  
{{< indent >}} 如果 TCP 段头部和数据部分是奇数个字节要进行校验，则在最后一个字节右边填充零，以形成一个 16 bit，用于校验。  
{{< indent >}} The pad is not transmitted as part of the segment.  
{{< indent >}} 填充不会作为 TCP 段的一部分进行传输。  
{{< indent >}} While computing the checksum, the checksum field itself is replaced with zeros.  
{{< indent >}} 在计算校验和时，校验和字段本身用零替换。

{{< indent >}} The checksum also covers a 96 bit pseudo header conceptually prefixed to the TCP header.  
{{< indent >}} 在校验和时还包括一个 96 bit 的伪头部，加在 TCP 头部前面。  
{{< indent >}} This pseudo header contains the Source Address, the Destination Address, the Protocol, and TCP length.  
{{< indent >}} 这个伪头部包含源地址、目标地址、协议和 TCP 长度。
{{< indent >}} This gives the TCP protection against misrouted segments.  
{{< indent >}} 这为 TCP 提供了防止错误路由 TCP 段的保护。  
{{< indent >}} This information is carried in the Internet Protocol and is transferred across the TCP/Network interface in the arguments or results of calls by the TCP on the IP.  
{{< indent >}} 这些信息在 IP 协议中携带，并在 TCP/网络接口上通过 TCP 对 IP 的调用的参数或结果进行传输。

{{< center >}}

```
+--------------------------+
|      Source Address      |
+--------------------------+
|    Destination Address   |
+--------------------------+
| zero | PTCL | TCP Length |
+--------------------------+
```

{{< /center >}}

{{< indent >}} The TCP Length is the TCP header plus the data length in octets (this is not an explicitly transmitted quantity, but is computed from the total length, and the header length), and it does not count the 12 octets of the pseudo header.  
{{< indent >}} TCP 长度是 TCP 报头加上数据部分的长度，单位是字节（这不是一个明确的传输量，而是从总长度和头部长度计算出来的），并且不包括 12 字节的伪头部。

**Urgent Pointer**: 16 bits  
{{< indent >}} This field communicates the current value of the urgent pointer as a positive offset from the sequence number in this segment.  
{{< indent >}} 这个字段表示当前紧急指针距离本段中序列号的正偏移。  
{{< indent >}} The urgent pointer points to the sequence number of the octet following the urgent data.  
{{< indent >}} 紧急指针指向紧急数据后的字节的序列号。  
{{< indent >}} This field should only be interpreted in segments with the URG control bit set.  
{{< indent >}} 这个字段只应在设置了 URG 标志的 TCP 段中使用。

**Options**: variable  
{{< indent >}} Options may occupy space at the end of the TCP header and are a multiple of 8 bits in length.  
{{< indent >}} 可选部分可能占用 TCP 头的末尾的空间，长度为 8bit 的倍数。  
{{< indent >}} All options are included in the checksum.  
{{< indent >}} 可选部分也包括在检验和的计算中。  
{{< indent >}} An option may begin on any octet boundary.  
{{< indent >}} 可选部分可以从任何字节边界上开始。  
{{< indent >}} There are two cases for the format of an option:  
{{< indent >}} 选项的格式有两种情况：

- Case 1: A single octet of option-kind.  
  情况 1: 一个字节的选项类型。
- Case 2: An octet of option-kind, an octet of option-length, and the actual option-data octets.  
  情况 2: 一个字节的选项类型、一个字节的选项长度和真正选项数据。

{{< indent >}} The option-length counts the two octets of option-kind and option-length as well as the option-data octets.  
{{< indent >}} 选项长度包括选项种类和选项长度的两个字节，以及选项数据的字节数。

{{< indent >}} Note that the list of options may be shorter than the data offset field might imply.  
{{< indent >}} 注意：选项列表可能比数据偏移字段要短。  
{{< indent >}} The content of the header beyond the End-of-Option option should be header padding (i.e., zero).  
{{< indent >}} 头部中在选项之外的内容是填充（即，0）。

{{< indent >}} A TCP must implement all options.  
{{< indent >}} TCP 必须实现所有选项。

{{< indent >}} Currently defined options include (kind indicated in octal):  
{{< indent >}} 目前定义的选项包括（种类以八进制表示）：

```
Kind     Length    Meaning
----     ------    -------
 0         -       End of option list.
 1         -       No-Operation.
100        -       Reserved.
105        4       Buffer Size.
```

{{< indent >}} Specific Option Definitions  
{{< indent >}} 具体选项定义

{{< indent >}} End of Option List

```
+--------+
|00000000|
+--------+
Kind=0
```

{{< indent >}} This option code indicates the end of the option list.  
{{< indent >}} 该选项代码表示选项列表的结束。  
{{< indent >}} This might not coincide with the end of the TCP header according to the Data Offset field.  
{{< indent >}} 根据数据偏移字段，这可能与 TCP 头的结尾不一致。  
{{< indent >}} This is used at the end of all options, not the end of each option, and need only be used if the end of the options would not otherwise coincide with the end of the TCP header.  
{{< indent >}} 这用于所有选项的末尾，而不是每个选项的末尾，并且仅在选项末尾与 TCP 头末尾不一致时才需要使用。

{{< indent >}} No-Operation

```
+--------+
|00000001|
+--------+
Kind=1
```

{{< indent >}} This option code may be used between options, for example, to align the beginning of a subsequent option on a word boundary.  
{{< indent >}} 该选项代码可以在选项之间使用，例如，在一个字的边界上对准后续选项的开头。  
{{< indent >}} There is no guarantee that senders will use this option, so receivers must be prepared to process options even if they do not begin on a word boundary.  
{{< indent >}} 不能保证发送者会使用这个选项，所以接收者必须准备好处理选项，即使它们不以字的边界开始。

{{< indent >}} Buffer Size

```
+--------+--------+---------+--------+
|01000101|00000100|    buffer size   |
+--------+--------+---------+--------+
Kind=105 Length=4

```

{{< indent >}} Buffer Size Option Data: 16 bits

{{< indent >}} If this option is present, then it communicates the receive buffer size at the TCP which sends this segment.  
{{< indent >}} 如果该选项存在，那么它在发送该段的 TCP 上传达接收缓冲区的大小。  
{{< indent >}} This field should only be sent in the initial connection request (i.e., in segments with the SYN control bit set).  
{{< indent >}} 该字段应该只在初始连接请求中发送（即在设置了 SYN 标志的段中）。  
{{< indent >}} If this option is not used, the default buffer size of one octet is assumed.  
{{< indent >}} 如果不使用这个选项，则假定默认的缓冲区大小为一个字节。

{{< indent >}} Padding: variable

{{< indent >}} The TCP header padding is used to ensure that the TCP header ends and data begins on a 32 bit boundary. The padding is composed of zeros.  
{{< indent >}} TCP 头的填充用于确保 TCP 头的结束和数据的开始都在 32 bit 边界上。填充是由零组成的。

### 术语表

**3.2. Terminology**

Before we can discuss very much about the operation of the TCP we need to introduce some detailed terminology.  
在我们非常深入地讨论 TCP 的运作之前，我们需要介绍一些复杂的术语。

The maintenance of a TCP connection requires the remembering of several variables.  
维护一个 TCP 连接需要记住几个变量。

We conceive of these variables being stored in a connection record called a Transmission Control Block or TCB.  
我们设想这些变量被存储在一个叫做传输控制块或 TCB 的连接记录中。

Among the variables stored in the TCB are the local and remote socket numbers, the security and precedence of the connection, pointers to the user's send and receive buffers, pointers to the retransmit queue and to the current segment.  
TCB 中存储的变量包括本地和远程套接字编号、连接的安全性和优先级、指向用户的发送和接收缓冲区的指针、指向重传队列和当前段的指针。

In addition several variables relating to the send and receive sequence numbers are stored in the TCB.  
此外，与发送和接收序列号相关的几个变量存储在 TCB 中。

Send Sequence Variables  
发送序列变量

```
SND.UNA - send unacknowledged
SND.NXT - send next
SND.WND - send window
SND.UP  - send urgent pointer
SND.WL1 - segment sequence number used for last window update
SND.WL2 - segment acknowledgment number used for last window update
ISS     - initial send sequence number
```

Receive Sequence Variables  
接收序列变量

```
RCV.NXT - receive next
RCV.WND - receive window
RCV.UP  - receive urgent pointer
IRS     - initial receive sequence number
```

The following diagrams may help to relate some of these variables to the sequence space.  
下图可能有助于将其中一些变量与序列空间联系起来。
{{< center >}}

```
    1         2          3          4
----------|----------|----------|----------
SND.UNA    SND.NXT    SND.UNA
                     +SND.WND

1 - old sequence numbers which have been acknowledged
2 - sequence numbers of unacknowledged data
3 - sequence numbers allowed for new data transmission
4 - future sequence numbers which are not yet allowed
```

Send Sequence Space

Figure 4.

{{< /center >}}

The send window is the portion of the sequence space labeled 3 in figure 4.  
发送窗口是图 4 中标记为 3 的序列空间的一部分。

{{< center >}}

```
  1          2          3
----------|----------|----------
RCV.NXT    RCV.NXT
          +RCV.WND

1 - old sequence numbers which have been acknowledged
2 - sequence numbers allowed for new reception
3 - future sequence numbers which are not yet allowed
```

Receive Sequence Space

Figure 5.

{{< /center >}}

The receive window is the portion of the sequence space labeled 2 in figure 5.  
接收窗口是图 5 中标记为 2 的序列空间的一部分。

There are also some variables used frequently in the discussion that take their values from the fields of the current segment.  
还有一些在讨论中经常使用的变量，它们的值来自当前段的字段。

Current Segment Variables
当前段变量

```
SEG.SEQ - segment sequence number
SEG.ACK - segment acknowledgment number
SEG.LEN - segment length
SEG.WND - segment window
SEG.UP  - segment urgent pointer
SEG.PRC - segment precedence value
```

A connection progresses through a series of states during its lifetime.  
一个连接在其生命周期中会经历一系列的状态。

The states are: LISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT and the fictional state CLOSED.  
这些状态是：LISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT 以及虚构的状态 CLOSED。

CLOSED is fictional because it represents the state when there is no TCB, and therefore, no connection.  
CLOSED 是虚构的，因为它代表了没有 TCB 的状态，也就是没有连接。

Briefly the meanings of the states are:  
简而言之，这些状态的含义是：

**LISTEN** - represents waiting for a connection request from any remote TCP and port.  
**LISTEN** - 表示等待来自任何远程 TCP 和端口的连接请求。

**SYN-SENT** - represents waiting for a matching connection request after having sent a connection request.  
**SYN-SENT** - 表示在发送了一个连接请求后等待一个匹配的连接请求。

**SYN-RECEIVED** - represents waiting for a confirming connection request acknowledgment after having both received and sent a connection request.  
**SYN-RECEIVED** - 表示在收到和发送连接请求后，等待确认连接请求的确认。

**ESTABLISHED** - represents an open connection, data received can be delivered to the user. The normal state for the data transfer phase of the connection.  
**ESTABLISHED** - 代表一个已建立的连接，收到的数据可以传递给用户，是连接数据传输阶段的正常状态。

**FIN-WAIT-1** - represents waiting for a connection termination request from the remote TCP, or an acknowledgment of the connection termination request previously sent.  
**FIN-WAIT-1** - 表示等待来自远程 TCP 的连接终止请求，或等待之前发送的终止连接请求的确认。

**FIN-WAIT-2** - represents waiting for a connection termination request from the remote TCP.  
**FIN-WAIT-2** - 表示等待来自远程 TCP 的连接终止请求。

**CLOSE-WAIT** - represents waiting for a connection termination request from the local user.  
**CLOSE-WAIT** - 表示等待本端用户的连接终止请求。

**CLOSING** - represents waiting for a connection termination request acknowledgment from the remote TCP.  
**CLOSING** - 表示等待来自远程 TCP 的连接终止请求确认。

**LAST-ACK** - represents waiting for an acknowledgment of the connection termination request previously sent to the remote TCP (which includes an acknowledgment of its connection termination request).
**LAST-ACK** - 表示等待对先前发送到远程 TCP 的连接终止请求的确认（其中包括对其连接终止请求的确认）。

**TIME-WAIT** - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.  
**TIME-WAIT** - 表示等待足够的时间来确保远程 TCP 收到其连接终止请求的确认。

**CLOSED** - represents no connection state at all.  
**CLOSED** - 表示没有连接的状态。

A TCP connection progresses from one state to another in response to events.  
TCP 连接根据事件从一个状态转换到另一个状态。

The events are the user calls, OPEN, SEND, RECEIVE, CLOSE, ABORT, and STATUS; the incoming segments, particularly those containing the SYN and FIN flags; and timeouts.  
这些事件是用户调用 OPEN、SEND、RECEIVE、CLOSE、ABORT 和 STATUS；收到 TCP 段，特别是包含 SYN 和 FIN 标志的段；以及超时。

The state diagram in figure 6 only illustrates state changes, together with the causing events and resulting actions, but addresses neither error conditions nor actions which are not connected with state changes.  
图 6 中的状态图只说明了状态的变化，以及引起的事件和触发的行为，但既没有涉及错误条件，也没有涉及与状态变化无关的行为。

In a later section, more detail is offered with respect to the reaction of the TCP to events.  
在后面的章节中，将提供关于 TCP 对事件反应的更多细节。

NOTE BENE: this diagram is only a summary and must not be taken as the total specification.  
注意：此图只是一个摘要，不能作为全部规范。

```
                              +---------+ ---------\      active OPEN
                              |  CLOSED |            \    -----------
                              +---------+<---------\   \   create TCB
                                |     ^              \   \  snd SYN
                   passive OPEN |     |   CLOSE        \   \
                   ------------ |     | ----------       \   \
                    create TCB  |     | delete TCB         \   \
                                V     |                      \   \
                              +---------+            CLOSE    |    \
                              |  LISTEN |          ---------- |     |
                              +---------+          delete TCB |     |
                   rcv SYN      |     |     SEND              |     |
                  -----------   |     |    -------            |     V
 +---------+      snd SYN,ACK  /       \   snd SYN          +---------+
 |         |<-----------------           ------------------>|         |
 |   SYN   |                    rcv SYN                     |   SYN   |
 |   RCVD  |<-----------------------------------------------|   SENT  |
 |         |                    snd ACK                     |         |
 |         |------------------           -------------------|         |
 +---------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +---------+
   |           --------------   |     |   -----------
   |                  x         |     |     snd ACK
   |                            V     V
   |  CLOSE                   +---------+
   | -------                  |  ESTAB  |
   | snd FIN                  +---------+
   |                   CLOSE    |     |    rcv FIN
   V                  -------   |     |    -------
 +---------+          snd FIN  /       \   snd ACK          +---------+
 |  FIN    |<-----------------           ------------------>|  CLOSE  |
 | WAIT-1  |------------------                              |   WAIT  |
 +---------+          rcv FIN  \                            +---------+
   | rcv ACK of FIN   -------   |                            CLOSE  |
   | --------------   snd ACK   |                           ------- |
   V        x                   V                           snd FIN V
 +---------+                  +---------+                   +---------+
 |FINWAIT-2|                  | CLOSING |                   | LAST-ACK|
 +---------+                  +---------+                   +---------+
   |                rcv ACK of FIN |                 rcv ACK of FIN |
   |  rcv FIN       -------------- |    Timeout=2MSL -------------- |
   |  -------              x       V    ------------        x       V
    \ snd ACK                 +---------+delete TCB         +---------+
     ------------------------>|TIME WAIT|------------------>| CLOSED  |
                              +---------+                   +---------+
```

{{< center >}}
TCP Connection State Diagram  
TCP 连接状态图

Figure 6.
{{< /center >}}

### 序列号

**3.3. Sequence Numbers**

A fundamental notion in the design is that every octet of data sent over a TCP connection has a sequence number.  
TCP 设计中的一个基本概念是，通过 TCP 连接发送的每个字节的数据都有一个序列号。

Since every octet is sequenced, each of them can be acknowledged.  
由于每个字节都是有顺序的，所以每个字节都可以被确认。

The acknowledgment mechanism employed is cumulative so that an acknowledgment of sequence number X indicates that all octets up to but not including X have been received.  
TCP 所采用的确认机制是累积性的，因此序列号为 X 的确认表示已经收到了之前但不包括 X 的所有字节。

This mechanism allows for straight-forward duplicate detection in the presence of retransmission.  
这种机制使得在存在重传的情况下可以直接进行重复检测。

Numbering of octets within a segment is that the first data octet immediately following the header is the lowest numbered, and the following octets are numbered consecutively.  
TCP 段内字节的编号是，TCP 头后的第一个字节数据是最小的编号，后面字节的编号是连续递增。

It is essential to remember that the actual sequence number space is finite, though very large.  
需要记住，实际的序列号范围是有限的，尽管非常大。

This space ranges from 0 to 2\*\*32 - 1.  
这个范围是从 0 到 2\*\*32-1 。

Since the space is finite, all arithmetic dealing with sequence numbers must be performed modulo 2\*\*32.  
由于范围是有限的，所有处理序列号的运算都必须模 2\*\*32。

This unsigned arithmetic preserves the relationship of sequence numbers as they cycle from 2\*\*32 - 1 to 0 again.  
这种无符号算术保留了序列号之间的关系，因为它们从 2\*\*32-1 再重新到 0。

There are some subtleties to computer modulo arithmetic, so great care should be taken in programming the comparison of such values.  
计算机模运算有一些细微的差异，所以在编程比较这些值时应该非常小心。

The symbol "=<" means "less than or equal" (modulo 2\*\*32).  
符号 "=<" 表示 "小于或等于" (模 2\*\*32)。

The typical kinds of sequence number comparisons which the TCP must perform include:  
TCP 中需要操作的典型的序列号比较包括：

(a) Determining that an acknowledgment refers to some sequence number sent but not yet acknowledged.  
(a) 确定一个确认是对应某个已发送但尚未确认的序列号。

(b) Determining that all sequence numbers occupied by a segment have been acknowledged (e.g., to remove the segment from a retransmission queue).  
(b) 确定 TCP 段所占用的所有序列号都已被确认（例如，从重传队列中删除该 TCP 段）。

(c) Determining that an incoming segment contains sequence numbers which are expected (i.e., that the segment "overlaps" the receive window).  
(c) 确定一个收到的 TCP 段包含预期的序列号（即该 TCP 段与接收窗口"重叠"）。

In response to sending data the TCP will receive acknowledgments.  
TCP 将收到确认作为对发送数据的响应。

The following comparisons are needed to process the acknowledgments.  
在处理确认时需要进行以下比较。

SND.UNA = oldest unacknowledged sequence number  
SND.UNA = 最早的未确认的序列号

SND.NXT = next sequence number to be sent  
SND.NXT = 下一个要发送的序列号

SEG.ACK = acknowledgment from the receiving TCP (next sequence number expected by the receiving TCP)  
SEG.ACK = 来自接收 TCP 的确认（接收 TCP 所期望的下一个序列号）。

SEG.SEQ = first sequence number of a segment  
SEG.SEQ = TCP 段的第一个序列号

SEG.LEN = the number of octets occupied by the data in the segment (counting SYN and FIN)  
SEG.LEN = 段落中的数据所占的字节数 (包括 SYN 和 FIN)

SEG.SEQ+SEG.LEN-1 = last sequence number of a segment  
SEG.SEQ+SEG.LEN-1 = TCP 段的最后一个序列号

A new acknowledgment (called an "acceptable ack"), is one for which the inequality below holds:  
一个新的确认（即 "可接受的确认"），会满足以下不等式。  
SND.UNA < SEG.ACK =< SND.NXT

A segment on the retransmission queue is fully acknowledged if the sum of its sequence number and length is less than the acknowledgment value in the incoming segment.  
如果重传队列中的一个 TCP 段的序列号和长度之和小于收到段的确认值，则该段被完全确认。

When data is received the following comparisons are needed:  
当收到数据时，需要进行以下比较：

RCV.NXT = next sequence number expected on an incoming segments, and is the left or lower edge of the receive window  
RCV.NXT = 下一个预期收到 TCP 段的序列号，也是接收窗口的左边界或下限。

RCV.NXT+RCV.WND-1 = last sequence number expected on an incoming segment, and is the right or upper edge of the receive window  
RCV.NXT+RCV.WND-1 = 最后一个预期收到 TCP 段的序列号，也是接收窗口的右边界或上限。

SEG.SEQ = first sequence number occupied by the incoming segment  
SEG.SEQ = 收到 TCP 段的第一个序列号

SEG.SEQ+SEG.LEN-1 = last sequence number occupied by the incoming segment  
SEG.SEQ+SEG.LEN-1 = 收到 TCP 段的最后一个序列号

A segment is judged to occupy a portion of valid receive sequence space if  
在下列情况下，一个 TCP 段被判断为占据了有效接收序列范围的一部分

RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND

or  
或

RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND

The first part of this test checks to see if the beginning of the segment falls in the window, the second part of the test checks to see if the end of the segment falls in the window; if the segment passes either part of the test it contains data in the window.  
该测试的第一部分检查段的开头是否落在窗口中，测试的第二部分检查段的结尾是否落在窗口中；如果该段通过了测试的任何一部分，则它在窗口中包含数据。

Actually, it is a little more complicated than this. Due to zero windows and zero length segments, we have four cases for the acceptability of an incoming segment:  
实际上，情况比这更复杂一些。由于零窗口和零长度的 TCP 段，我们有四种情况来判断一个收到的 TCP 段是否可接受：

```
Segment Receive  Test
Length  Window
------- -------  -------------------------------------------
    0       0     SEG.SEQ = RCV.NXT
    0      >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
   >0       0     not acceptable
   >0      >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND or
                  RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND
```

Note that when the receive window is zero no segments should be acceptable except ACK segments.  
请注意，当接收窗口为零时，除了 ACK 段外，不应接受其他 TCP 段。

Thus, it should be possible for a TCP to maintain a zero receive window while transmitting data and receiving ACKs.  
因此，TCP 应该有可能在传输数据和接收 ACK 的同时保持一个零接收窗口。

However, even when the receive window is zero, a TCP must process the RST and URG fields of all incoming segments.  
然而，即使接收窗口为零，TCP 也必须处理所有接收段的 RST 和 URG 字段。

We have taken advantage of the numbering scheme to protect certain control information as well.
我们还利用了编号方案来保护某些控制信息。

This is achieved by implicitly including some control flags in the sequence space so they can be retransmitted and acknowledged without confusion (i.e., one and only one copy of the control will be acted upon).  
这是通过在序列空间中隐含地包括一些控制标志来实现的，使得它们可以被重发和确认而不会产生混淆(即，将对控制的一个且仅一个副本进行操作)。

Control information is not physically carried in the segment data space.  
控制信息不实际在 TCP 段数据空间中携带。

Consequently, we must adopt rules for implicitly assigning sequence numbers to control.
因此，我们必须采用隐式分配序列号的规则来控制。

The SYN and FIN are the only controls requiring this protection, and these controls are used only at connection opening and closing.  
SYN 和 FIN 是唯一需要这种保护的控制，而且这些控制只在连接打开和关闭时使用。

For sequence number purposes, the SYN is considered to occur before the first actual data octet of the segment in which it occurs, while the FIN is considered to occur after the last actual data octet in a segment in which it occurs.  
就序列号而言，SYN 被认为发生在其所在 TCP 段的实际数据第一个字节之前，而 FIN 被认为发生在其所在段的实际数据的最后一个字节之后。

The segment length includes both data and sequence space occupying controls.  
TCP 段的长度包括数据和占用序列空间的控制信息。

When a SYN is present then SEG.SEQ is the sequence number of the SYN.  
当存在 SYN 时，SEG.SEQ 是 SYN 的序列号。

**Initial Sequence Number Selection**  
**初始序列号的选择**

The protocol places no restriction on a particular connection being used over and over again.  
该协议不限制反复使用特定连接。

A connection is defined by a pair of sockets.  
一个连接是由一对套接字确定的。

New instances of a connection will be referred to as incarnations of the connection.  
连接的新实例会用来表示连接。

The problem that arises owing to this is -- "how does the TCP identify duplicate segments from previous incarnations of the connection?"  
由此产生的问题是 -- "TCP 如何识别来自以前连接中的重复段？"

This problem becomes apparent if the connection is being opened and closed in quick succession, or if the connection breaks with loss of memory and is then reestablished.  
如果快速连续地打开和关闭连接，或者如果连接因内存丢失而断开，然后重新建立，则此问题会变得明显。

To avoid confusion we must prevent segments from one incarnation of a connection from being used while the same sequence numbers may still be present in the network from an earlier incarnation.  
为了防止出现混乱，我们必须防止使用来自先前连接中有相同序列号的数据段。

We want to assure this, even if a TCP crashes and loses all knowledge of the sequence numbers it has been using.  
我们要保证这一点，即使 TCP 崩溃并失去了它使用的序列号的所有信息。

When new connections are created, an initial sequence number (ISN) generator is employed which selects a new 32 bit ISN.  
当创建新连接时，使用初始序列号(ISN)生成器选择新的 32 位 ISN。

The generator is bound to a (possibly fictitious) 32 bit clock whose low order bit is incremented roughly every 4 microseconds.  
发生器跟一个（可能是虚拟的）32 位时钟绑定，其低位大约每 4 微秒递增一次。

Thus, the ISN cycles approximately every 4.55 hours.  
因此，ISN 大约每 4.55 小时循环一次。

Since we assume that segments will stay in the network no more than tens of seconds or minutes, at worst, we can reasonably assume that ISN's will be unique.  
由于我们假设 TCP 段在网络中的停留时间不超过几十秒或几分钟，即使在最坏的情况下，我们仍然可以地假设 ISN 将是唯一的。

For each connection there is a send sequence number and a receive sequence number.  
对于每个连接，都有一个发送序列号和一个接收序列号。

The initial send sequence number (ISS) is chosen by the data sending TCP, and the initial receive sequence number (IRS) is learned during the connection establishing procedure.  
初始发送序列号（ISS）由发送方的 TCP 选择，初始接收序列号（IRS）在连接建立过程中得到。

For a connection to be established or initialized, the two TCPs must synchronize on each other's initial sequence numbers.  
如果要建立或初始化的连接，两个 TCP 必须同步对方的初始序列号。

This is done in an exchange of connection establishing messages carrying a control bit called "SYN" (for synchronize) and the initial sequence numbers.  
这是通过交换建立连接的信息来完成的，这些信息带有一个称为 "SYN"（用于同步）的控制位和初始序列号。

As a shorthand, messages carrying the SYN bit are also called "SYNs".  
简而言之，携带 SYN 位的消息也称为 "SYNs"。

Hence, the solution requires a suitable mechanism for picking an initial sequence number and a slightly involved handshake to exchange the ISN's.  
因此，该解决方案需要一个合适的机制来挑选初始序列号，并需要一个稍微复杂的握手来交换 ISN。

The synchronization requires each side to send it's own initial sequence number and to receive a confirmation of it in acknowledgment from the other side.  
同步需要每一方发送自己的初始序列号，并从另一方的 ACK 中得到确认。

Each side must also receive the other side's initial sequence number and send a confirming acknowledgment.  
每一方还必须收到另一方的初始序列号，并发送确认的 ACK。

(1) A --> B SYN my sequence number is X  
(1) A --> B 同步自己的序列号 X

(2) A <-- B ACK your sequence number is X  
(2) A <-- B 确认你的序列号是 X

(3) A <-- B SYN my sequence number is Y  
(3) A <-- B 同步自己的序列号 Y

(4) A --> B ACK your sequence number is Y  
(4) A --> B 确认你的序列号是 Y

Because steps 2 and 3 can be combined in a single message this is called the three way (or three message) handshake.  
由于第 2 和第 3 步可以结合在一个消息中，这被称为三次（或三次信息）握手。

A "three way handshake" is necessary because sequence numbers are not tied to a global clock in the network, and TCPs may have different mechanisms for picking the ISN's.
"三次握手" 是必要的，因为序列号没有绑定到网络中的全局时钟，并且 TCP 可能有不同的机制来挑选 ISN。

The receiver of the first SYN has no way of knowing whether the segment was an old delayed one or not, unless it remembers the last sequence number used on the connection (which is not always possible), and so it must ask the sender to verify this SYN.
第一个 SYN 的接收者没有办法知道这个 TCP 段是否是一个旧的延迟段，除非它记得连接上使用的最后一个序列号（这并不总是可能的），所以它必须要求发送者验证这个 SYN。

The "three way handshake" and the advantages of a "clock-driven" scheme are discussed in [3].  
在[3]中讨论了 "三次握手 "和 "时钟驱动" 方案的优势。

**Knowing When to Keep Quiet**  
**知道什么时候该保持静默**

To be sure that a TCP does not create a segment that carries a sequence number which may be duplicated by an old segment remaining in the network, the TCP must keep quiet for a maximum segment lifetime (MSL) before assigning any sequence numbers upon starting up or recovering from a crash in which memory of sequence numbers in use was lost.  
为了确保 TCP 不会创建一个携带与网络中旧 TCP 段中序列号重复的 TCP 段，TCP 在启动时或从丢失当前使用序列号内存的崩溃中恢复时，在分配任何序列号之前保持最大网段寿命（MSL）的静默时间。

For this specification the MSL is taken to be 2 minutes.  
在本规范中，MSL 是 2 分钟。

This is an engineering choice, and may be changed if experience indicates it is desirable to do so.  
这是一个工程选择，它可能会根据经验改变。

Note that if a TCP is reinitialized in some sense, yet retains its memory of sequence numbers in use, then it need not wait at all; it must only be sure to use sequence numbers larger than those recently used.  
请注意，如果一个 TCP 在某种情况被重新初始化，但保留了其正在使用的序列号的内存，那么它不需要等待；它只需要确保使用比最近使用的序列号大的序列号。

**The TCP Quiet Time Concept**  
**TCP 静默时间的概念**

This specification provides that hosts which "crash" without retaining any knowledge of the last sequence numbers transmitted on each active (i.e., not closed) connection shall delay emitting any TCP segments for at least the agreed Maximum Segment Lifetime (MSL) in the internet system of which the host is a part.

In the paragraphs below, an explanation for this specification is given.

TCP implementors may violate the "quiet time" restriction, but only at the risk of causing some old data to be accepted as new or new data rejected as old duplicated by some receivers in the internet system.

TCPs consume sequence number space each time a segment is formed and entered into the network output queue at a source host.

The duplicate detection and sequencing algorithm in the TCP protocol relies on the unique binding of segment data to sequence space to the extent that sequence numbers will not cycle through all 2\*\*32 values before the segment data bound to those sequence numbers has been delivered and acknowledged by the receiver and all duplicate copies of the segments have "drained" from the internet.

Without such an assumption, two distinct TCP segments could conceivably be assigned the same or overlapping sequence numbers, causing confusion at the receiver as to which data is new and which is old.

Remember that each segment is bound to as many consecutive sequence numbers as there are octets of data in the segment.

Under normal conditions, TCPs keep track of the next sequence number to emit and the oldest awaiting acknowledgment so as to avoid mistakenly using a sequence number over before its first use has been acknowledged.

This alone does not guarantee that old duplicate data is drained from the net, so the sequence space has been made very large to reduce the probability that a wandering duplicate will cause trouble upon arrival.

At 2 megabits/sec. it takes 4.5 hours to use up 2\*\*32 octets of sequence space.

Since the maximum segment lifetime in the net is not likely to exceed a few tens of seconds, this is deemed ample protection for foreseeable nets, even if data rates escalate to l0's of megabits/sec. At 100 megabits/sec, the cycle time is 5.4 minutes which may be a little short, but still within reason.

The basic duplicate detection and sequencing algorithm in TCP can be defeated, however, if a source TCP does not have any memory of the sequence numbers it last used on a given connection.

For example, if the TCP were to start all connections with sequence number 0, then upon crashing and restarting, a TCP might re-form an earlier connection (possibly after half-open connection resolution) and emit packets with sequence numbers identical to or overlapping with packets still in the network which were emitted on an earlier incarnation of the same connection.

In the absence of knowledge about the sequence numbers used on a particular connection, the TCP specification recommends that the source delay for MSL seconds before emitting segments on the connection, to allow time for segments from the earlier connection incarnation to drain from the system.

Even hosts which can remember the time of day and used it to select initial sequence number values are not immune from this problem (i.e., even if time of day is used to select an initial sequence number for each new connection incarnation).

Suppose, for example, that a connection is opened starting with sequence number S.

Suppose that this connection is not used much and that eventually the initial sequence number function (ISN(t)) takes on a value equal to the sequence number, say S1, of the last segment sent by this TCP on a particular connection.

Now suppose, at this instant, the host crashes, recovers, and establishes a new incarnation of the connection.

The initial sequence number chosen is S1 = ISN(t) -- last used sequence number on old incarnation of connection!

If the recovery occurs quickly enough, any old duplicates in the net bearing sequence numbers in the neighborhood of S1 may arrive and be treated as new packets by the receiver of the new incarnation of the connection.

The problem is that the recovering host may not know for how long it crashed nor does it know whether there are still old duplicates in the system from earlier connection incarnations.

One way to deal with this problem is to deliberately delay emitting segments for one MSL after recovery from a crash- this is the "quite time" specification.

Hosts which prefer to avoid waiting are willing to risk possible confusion of old and new packets at a given destination may choose not to wait for the "quite time".

Implementors may provide TCP users with the ability to select on a connection by connection basis whether to wait after a crash, or may informally implement the "quite time" for all connections.

Obviously, even where a user selects to "wait," this is not necessary after the host has been "up" for at least MSL seconds.

To summarize: every segment emitted occupies one or more sequence numbers in the sequence space, the numbers occupied by a segment are "busy" or "in use" until MSL seconds have passed, upon crashing a block of space-time is occupied by the octets of the last emitted segment, if a new connection is started too soon and uses any of the sequence numbers in the space-time footprint of the last segment of the previous connection incarnation, there is a potential sequence number overlap area which could cause confusion at the receiver.
